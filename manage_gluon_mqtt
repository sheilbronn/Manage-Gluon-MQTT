#!/usr/bin/env ash
# shellcheck shell=ash

#
# manage_gluon_mqtt
#
# Monitor and control Freifunk nodes (Gluon) - by command line and MQTT
#
# Repo: https://github.com/sheilbronn/Manage-Gluon-MQTT

# Some fixed constants and prelimenary (fixed) settings ...
# semi-hungarian notation for vars: i(n)teger, (s)tring, (d)irectory, (c)ommand, (b)oolean usage, (f)ile, (h)ost, (_) local meaning only

# manage_gluon_mqtt -m localhost -v -c noop,ignore,echo,date,loop,filecopy,wifidown,wifiup,wifistatus,limit,ffcond,gluonreconfigure,site,gluondata,speedtest,status,printmap,localclients,nodeinfo,neighbours,statistics,showsite,memory

nWifiSleep=7 # seconds to sleep after "wifi up"
dGluon="/lib/gluon"
sSite="" #  will be set to something like "ffmuc".... but you could also freeze it here
fMacIDs="/srv/openhab-conf/phones" # file is only for presence detection in mapping known phones to known people at....
fNul=/dev/null
MP=mosquitto_pub
LH=localhost

cCmv()	{ command -v "$@" >$fNul ;} # find out whether a command exists
cLower() { { [ "$*" ] && echo "$*" || cat ;} | awk '{print tolower($0)}' ;}
cPid() { sh -c 'echo $$' ;}
# echo TEST: ; cPid ; cPid ; exit 

alias cTrd="tr -d"
alias cSanitize="cTrd -c A-Za-z0-9_.%,\ -" # remove special, leave spaces and ,._-
alias cOut='echo "$ssh_data"'

if cCmv busybox ; then
	alias awk="busybox awk" # && cCmv goawk && alias awk=goawk # FIXME: remove experiment with goawk
	alias sed="busybox sed"
	alias tr="busybox tr"
	alias grep="busybox grep"
	alias xargs="busybox xargs -r"
fi
	[ "$(ech"o" -e)" = "-e" ] && alias ECHO="echo" || alias ECHO="echo -e" # some echo's know -e, some not. /bin/echo would be needed for color generalized interpretation, in case -e not understood
	alias e="ech"o
	# alias e="printf \"%b %b %b\\n\""
	alias l=loc"al" # special quoting needed when compressing script for reduced storage
	alias c=con"tinue"
	alias r=ret"urn"

set -o noglob  # set noglob will limit security and escaping problems
sMe="$(echo ${0##*/} | cTrd -c A-Za-z0-9_.-)" # script fails on purposes when name contains white space
sMe2="$(echo ${sMe%.sh} | cTrd _)"
sMID="$sMe2-$$"
sID=$(e $sMID | cTrd -c a-zA-Z0-9) # sanitize the ID
sManufacturer=Linux
export ssh_rc=0
export ssh_data=

dUser=$HOME/.${sMe%.sh}
fHost=/proc/sys/kernel/hostname
sArea=$(cat $fHost 2>$fNul || hostname || e unknown)
[ $sArea = openHABianPi -o $sArea = unknown ] && sArea="${sArea}-$( awk -F: '{print $5$6}' </sys/class/net/eth0/address )"
sArea=$(cLower "$sArea") # lowercase only
sSsidBase=UNKNOWN # would be an an error
sPubIfs= # will be determined on first call to every host, then cached
nMqttSleep=1199 # 1190
sHassPrefix=homeassistant/sensor
hPubMqtt=test.mosquitto.org
basetopic=xyz  # default MQTT topic prefix

ifipv6=bat0 # maybe assumption too broad, FIXME: need error reports
sGrepSsid='.*'

umask -S u=rwx,g=rx,o= # no rights for others
alias cX="local - && set +x" # stop the local verbosity

# Notes for future enhancements:
# ping ff host and up/down own public if accordingly
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8ba && echo yes ) || echo no
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8be && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iw dev client0 del ; echo if downed )
# scan repeatedly for public Wifi and up/down own public if accordingly:
# ( { for i in 1 1 1 1 2 ; do iw dev mesh0 scan ; sleep $i ; done } | fgrep -w '6e:a3:09:ea:31:e1' && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iw dev $sPubIf0 del ; echo if downed )
# ( { for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | egrep -A 9 -w '6e:a3:09:ea:31:e0' | grep SSID:.muenchen.freifunk.net/muc_sued && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iwinfo | grep $sPubIf0 && iw dev $sPubIf0 del ; echo if downed )

cHelp() {
  echo "Usage: $sMe ... -v -m mqttserver -p -s host -c command ...
   Execute commands on Gluon/Freifunk/OpenWrt nodes using uci and other commands. Returns output on stdout and/or MQTT.
   Either automatic (e.g. key-based) access to the Freifunk node using SSH or remote execution is supported.
   Implemented commands:" 1>&2
   _cel='\)(\s*#.*|)$' # = comment til eol
  grep -E "^\s*[a-z_|-]+$_cel" "$0" | sed -E -e "s,$_cel,," -e 's,\|, ,g'  | xargs echo 1>&2 # extract coammands from this shell script
}

cSortAndTailFile() {
	cX
	local fTmp=$dTmp/tf
	local nCol="${3:-1}"

	[ -r "$1" ] && [ -w "$1" ] && sort -k $((nCol+1)) "$1" | uniq -f "$nCol" | tail -"${2:-20}" | sort -k $((nCol+1)) > $fTmp &&
			cat "$fTmp" > "$1" && rm -f "$fTmp"
	[ "$bVeryVerbose" ] && dbg "cSortAndTailFile($1,$2,$3): lines: $(wc -l <"$1")"
	}

cExtractVals() {
	local _tmp="$(e "$@" | xargs -n 1)"
	_tmp="${_tmp#*=}"
	# dbg "cExtractVals returns: <$_tmp>" 1>&2
	e "$_tmp"
	}

cExpand() { # expand some shortcuts: $w: site, %s: host name of target, %g: intended MQTT group
	[ "$*" ] && awk -v a="$*" "BEGIN {gsub(\"%w\",\"$sSite\",a);gsub(\"%s\",\"$hTarget\",a);gsub(\"%g\",\"$mqttGroup\",a);print a}"
	}
# echo $(cExpand w=%w s=%s g=%g) ; exit 0

_helper() {
		cOut|awk -F= "/^$1=/"' {gsub("\"","") ; print $2}' 
    }
cGetOSData() {
	cX
	local _val="$(cCRead $hTarget.os_data 1)"

	if [ -z "$_val" ] ; then
		cSsh "cat /usr/lib/os-release" || return $? # cancel func
		if [ "$ssh_data" ] ; then
			_val="$(cOut|awk -F= '
				BEGIN { lim="{*os*:{" } END {printf "}}"}
				{ gsub("\"", "*", $2) ; printf lim "*" tolower($1) "*:" $2 ; lim="," }' )" # generate new value
			 cCWrite .os_data	"$_val"  # cache new obtained value
			 cCWrite .os_pretty_name	"$(_helper PRETTY_NAME)"
			 cCWrite .os_name	"$(_helper NAME)"
			 cCWrite .os_id	"$(_helper ID)"
		fi
	fi
	printf %s "$_val"
	}

cGetSitecode() { # $1=cachetimeout
	cX
	local _data="$(cCRead $hTarget.site 10)" # site code is quite stable...
	if [ -z "$_data" -o "$1" ] ; then
		[ -z "$1" ] && _data="$(cCRead $hTarget.sitenotfound 1)" # dont do it every time, read a default for the rest of the time
		if [ -z "$_data" -o "$1" ] ; then
			cSsh "[ -d $dGluon ] && jsonfilter -e @.site_code <$dGluon/site.json || echo UNDET" 2>$fNul
			if [ "$ssh_data" ] ; then
				_data="$ssh_data"
				cCWrite .site "$_data"
			else
				_data="$(cMostFrequentSite)" #  hack: use my local standard
			fi
			[ -z "$1" ] && cCWrite .sitenotfound "$_data"
		fi
	fi
	sSite="$_data"
	dbg cGetSitecode "sSite=$sSite arg1=$1"
	}

cMostFrequentSite() {
		cX ; set +o noglob # needed here
		_tmp="$(cat "$dCache"/*.site 2>$fNul | sort | uniq -c | awk '{print $2;exit}' )"
		e "${_tmp:-UNKNOWN}"
	}

cGetHostname() { # $1=host $2=cachetimeout
	cX
	local _key="${1:-$hTarget}.hostname"
	local _data="$(cCRead "$_key" "${2:-9}" )"
	if [ -z "$_data" ] ; then
		cSsh "tr A-Z a-z <$fHost" || ssh_data="${1:-$hTarget}"
		dbg cGetHostname "ssh_data=$ssh_data"
	fi
	cCWrite $_key "$ssh_data"
	cEcho
}

cGetPubIF() { # $1=cachetimeout  ## TODO ## -1 for forced reloading
	sPubIfs=""
	sPubIf0=""
	sPubIf1=""
	local _data="$(cCRead $hTarget.ifs "${2:-9}")"
	if [ -z "$_data" ] ; then
		cSsh "command -v iwinfo >$fNul && iwinfo" || { cErr "iwinfo not found:" ; return $? ;} # only iwinfo works for this
		# echo "$ssh_data" > /tmp/x
		# _data="$( { cOut ; echo "" ;} |awk '/^$/ {print (l~/Mode: Master;.*;Encryption: none/?l:"");l="";next} {gsub("^ +",";") ; gsub("  +",";") ;l=l$0 ;next}' )"
		_data="$( { cOut ; echo "" ;} |awk '/^$/ {if (l~/Mode: Master;.*;Encryption: none/) print l;l="";next} {gsub("^ +",";") ; gsub("  +",";") ;l=l$0 ;next}' )"
		dbg REMOTE "interfaces returned: $_data"
		[ "$_data" ] && cCWrite .ifs "$_data" #  .... cache result only if at least one public Freifunk if is up and running
	fi
	sPubIfs="$(e "$_data" | awk -F";" '{printf $1 " "}')"
	# set global variables $sPubIfs, $sPubIf0, $sPubIf1 and sSsidBase as side effects...
	if [ -z "$sPubIfs" ] ; then
		sPubIfs="ERROR"
		_msg="No interface(s) determinable: sPubIfs=$sPubIfs"
		dbg PUBLIC "$_msg"
		cErr "$_msg"
		sSsidBase=""
		return 1
	fi
	sPubIf0="$(e "$sPubIfs" | cut -d" " -f1)" # 1st interface
	sPubIf1="$(e "$sPubIfs" | cut -d" " -f2)" # 2nd interface if any (e.g. 5 Ghz)
	dbg PUBLIC "interface(s): if0=$sPubIf0,if1=$sPubIf1 (ifs=$sPubIfs)"
	sSsidBase="$(e "$_data" | awk -F";" '{print $2;exit}' | cTrd \" | awk -F": " '{ gsub("/.*","",$2) ; print $2 }' )"
}

cTableToJSON() { # table is to be piped in. numerical values are made unquoted. $1: (optional) number of missing headers, e.g. 1 in free -t
	cX
	awk -v missHead="${1:-0}" '
		BEGIN { OFS=""
			getline
			for (i=1; i<=NF; i++) names[i+missHead] = $i   # read the headers
			printf "{"
		} {
			printf lim "*%s*:{", gensub(":", "", 1, tolower($1)) # remove any ":"
			for(i=2;i<=NF;i++) {
				dq=($i ~ /^-?[0-9]+$[0-9.]*$/) ? "" : "*" # FIXME: Check: Is 99. really a JSON number ?
				printf "*%s*:%s%s%s%s" , names[i] , dq,$i,dq, i==NF ? "" : ","
			}
			printf "}"
			lim=",\n"
		}
		END {print "}"} '
  }
  # { echo spalte1 spalte2 ; echo a1 12 13 ; echo b1 b2;} | cTableToJSON 1 ; exit

cDelSimpleJsonAttr() { # $1: attr, $2: JSON-string  # but only covers very simple cases, i.e. with quotes or not  :(
    # jq -c "del($1)" <<< "$2"
	# attr="$1"
	#                     a) not the last in the set (,)            b) only one or last in the set
	echo "$2" | sed -E -e "s;\"$1\":(\"[^\"]*\"|[^,}]*)[ ]*,;;" -e "s;[ ]*,[ ]*\"$1\":(\"[^\"]*\"|[^,}]*)[ ]*};;"
}

cFirstJsonAttr() { # take string and extract the value of the first attribute if JSON, whole string otherwise. eliminating any non-alpha chars
	cX
	local m="$*" # if [ "$1" ] ; then attr="$*" ; else attr="$(cat)" ; fi      # $1 or stdin
	if [ "${m#{}" != "$m" ]  ; then
		e "$m" | sed -e 's/[,}].*//g' -e 's/[^:]*://' -e 's/[^a-zA-Z0-9]*//g' # JSON
	else
		e "$m" # non-JSON
	fi
}
# set -x ; x='{ eins:"first" , zwei="second" }' ; cFirstJsonAttr "$x" ; cFirstJsonAttr "blabla,bla:blub" ; exit # TEST

cWordsToJsonArry() {
	cX
	awk 'BEGIN {printf "["} {printf lim "*" $0 "*" ; lim="," } END {printf "]"}'
  }

cGetGluonDomainsStarred() {
	local _data="$(cCRead $1.gluondomains 1)"

	if [ -z "$_data" ] ; then
		cSsh "ls -1 "$dGluon/domains" 2>&1" || return $?  # cancel func
		_data="$ssh_data"
		if [ "$_data" ] ; then
			_data="$(e "$_data" | sed -e 's/[^_]*_//' -e 's/.json//')"
			cCWrite $1.gluondomains "$_data"
		fi
	fi
	printf %s "$_data" | cWordsToJsonArry
}

cLogger() {
		logger -p daemon.$1 -t "$sMe $hTarget" "$2"
	}

cErr() {
	cX
	_tmp="$1"
	[ "$1" = : ] && _tmp="ssh to $sSshUser for $cmd failed" # default msg is ....
	[ "$1" != "${1%:}" ] && _tmp="${_tmp%:} (rc=$ssh_rc,$ssh_msg)" # if $1 ends in :, then add rc and msg
	shift 1 
	ECHO "${OnRed}ERROR$Rst:" "$_tmp" "$@" 1>&2
	[ -t 2 ] || cLogger error "$_tmp" "$@"
	}

cErrAndExit() {
	cX
	cErr "$* ... Exiting."
	exit 1
	}

cEcho() { # output stuff unless to be quiet
	cX
	[ "$bQuiet" ] && return
	o="${*:-$ssh_data}"
	# local _out="$*"
	# [ "$1" = "${1#\{\*}" ] && ECHO EINS
	# [ "$1" = "${1#\{\*}" ] && ECHO ZWEI
	# FIXME:  [ "$1" = "${1#\{\*}" -a "$1" = "${1#\[\*}" ] && _out="$(cStarredToJSON "$*" | json_pp)"  # expand (only) "starred" pseudo-JSON
	ECHO "$Cyan$o$Rst"
	cLogger info "$o"
	}

dbg() { # output its args to stderr if option -v was set
	cX

	[ "$bVerbose" ] || return 1
	{ [ "$#" = 2 ] && ECHO "$Yellow$1:$Rst" "$2" || ECHO "${Yellow}debug$Rst" "$*" ;} 1>&2
	[ "$bVeryVerbose" ] && cLogger info "$*"
	return 0
	}

for d in /var/log /tmp ; do # find a suitable writable dir. Prefer /var/log over /tmp on openhabian (because of zram).
	dCache=$d/${sMe%.sh}.$(id -nu)
	dTmp=$dCache/$$
	dbg dTmp $dTmp
	[ -d "$dCache" ] || { mkdir -p "$dCache" 2>$fNul && chmod o-rwx "$dCache" ;} && mkdir "$dTmp" && break || id # ... && chmod o-rwx $dTmp
done

cDirFromStoreType() { [ $1 = cache ] && e $dCache || e $dUser ;}

cStoreWrite() { # write a key/value pair to a dir: key,value,dir,filesuffix # if key starts with "." prefix the hTarget
	cX 
	_dir="$(cDirFromStoreType $3)"
	_f="$_dir/$([ "${1#.}" = "$1" ] || printf $hTarget)$1"
	_t=STORE_WRITE
	if [ -z "$1" ] ; then
		e "$_t: #INVALIDPARAM#"
		cErrAndExit "$_t($1, \"$2\", $_dir) = #INVALIDPARAM#"
	fi
	mkdir -p $_dir && echo "$2" > "$_f"
	_rc=$?
	dbg $_t "($1,\"$2\",$3) = $_rc"
  }
cUserWrite() {  # write a key/value pair permanently across script invocations
	cStoreWrite "$1" "$2" persisted
	}
cCWrite() { # write a key/value pair to be cached across script invocations from the same user
	cStoreWrite "$1" "$2" cache
	}
	# echo TEST: ; set -x ; cCWrite test1 shouldnotfail ; ls -al $_f ; cCWrite "" shouldfail ; exit 
cStoreRead() { # read key/value pair from cache or user storage  (1:key, 2:cachetime, 2: filesuffix, 3:dir)
	cX
	local _fn="$(cDirFromStoreType $3)/$1"
	local _maxcachedays=${2:-2}
	local _res=""
	local _val=""
	local _deloutput

	if [ -z "$1" ] ; then
		_res="#INVALIDPARAM#"
		cErrAndExit "STORE_READ($1,...) with $_res"
	elif [ ! -r $_fn ] ; then
		_res="#NOTFOUND#"
	else
		[ "$4" = cache ] && _deloutput="$( find $_fn -mtime +"$_maxcachedays" | head -1 | xargs -t rm 2>&1)" # cache invalidated after n days and remove file
		if [ "$_deloutput" ] ; then
			_res="#NOTFOUND#" # cache is invalid
		else
			_val="$(cat $_fn)" && _res="#OK#"  # read value from cache file
			[ "$_val" ] || _res="#EMPTY#"
		fi
	fi
	dbg STORE_READ "($1,$2,${_fn#/var/log},${3%ed})=\"$(cShortenString "$_val" 23)\",$_res)"
	printf %s "$_val"
	[ "$_val" ] # return 1 if empty, 0 otherwise
  }

cCRead() { # read a key/value pair to be cached across script invocations from the same user; empty cache after $2=n day(s)
	cX
	cStoreRead "$1" "$2" cache
  }

cUserRead() { # read a user-specific key/value pair across script invocations
	cX
	cStoreRead "$1" "$2" persisted
	}

if [ -t 1 ] ; then
	C='\e[' # https://gist.github.com/bcap/5682077#file-terminal-control-sh
	Yellow="${C}33m" ; Cyan="${C}36m" ; OnRed="${C}41m" ; Rst="${C}0m"
	Reg="${C}22;24m" ; RegF="${C}39m" ; RegB="${C}49m"  # Reset all coloring and style
fi

cShortenString() { # shorten string $1 to at most $2 chars plus ....
	cX
	printf "%.${2:-5}s%s" "$1" "$( [ ${#1} -gt "${2:-5}" ] && printf "...")"
	}

jsonfilter_func() {  #  jsonfilter_func(filterexpr,moreparam)=result
	cX
	local _data
	if [ "$jsonfilter" = jsonfilter ] ; then
		_data=$(jsonfilter -e "@$1" $2) # $2 is unquoted to avoid complaint when missing
	elif [ "$jsonfilter" = jq ] ; then
		_data=$(jq -r "$1" $2)
	else
		cErrAndExit '$jsonfilter is undefined'
	fi
	printf %s "$_data"
  }

cGetMacVendor() {
	cX
	local _short="$(echo "$1" | cut -d- -f1-3)"
	vendor="$(cCRead "mac-$_short.macvendor" 14 | cut -d" " -f1-2)"
	if [ -z "$vendor" ] ; then
		vendor="$(wget -q -O - "https://api.macvendors.com/$1" | cut -d" " -f1-2)"
		cCWrite "mac-$_short.macvendor" "$vendor"
	fi
	echo "$vendor"
}
# set -x ; cGetMacVendor 38:b4:d3:de:58:2e ; exit

shorten_ethernet_addr_in_json() { # remove some bytes für anonymization
	[ "$1" = skip ] && cat && return 0
	sed -e 's/\([*"][a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]:\)[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]\(:[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9][*"]\)/\1...\2/g' "$@"
	}

cProbe() { # returns 0, if command is to be executed, 1 if not, and 255 if last ssh connection failed
	cX # any local command line command is always trusted for now:
	[ "$cmdsToDo" != bridge ] && { [ $ssh_rc = 255 ] && return 255 || return 0 ; } # if host wasn't reachable (255) don't tray again
	[ "$hMqtt" != $LH ] && { cEcho "Untrusted MQTT $1 command .$cmd. ignored for .$fHost." ; return 1;} # for now: only trust commands from a MQTT broker on the same host.
	return 0 # FIXME: covered by catchall
	}
alias cProbeGET="cProbe GET || continue"
alias cProbeSET="cProbe SET || continue" # FIXME: logic not implemented consistently
alias cProbeNOMQTT="cProbe NOMQTT || continue" # FIXME: covered by catchall

bMosqFile=$( [ -r $HOME/.config/$MP ] && echo yes)

cMqtt() { # cMqtt(topic,msg, options) # expanding a leading / in topic to $sSite/$hTarget/
	cX
	[ "$cMPub" = : ] && return
	dbg PUB_MQTT "$1  $2 ${3:+OPTIONS=$3}${bVeryVerbose:+ (hMqtt=$hMqtt;hTarget=$hTarget)}"
	local _topic="$1"
	[ "$1" != "${1#/}" ] && _topic="$sSite/$hTarget$1" # ... expand shortcuts starting with "/"
	for h in $hMqtt ; do
		$cMPub ${h:+-h $h} ${sMID:+-i $sMID} -t "$_topic" -m "$2" -i "${sSite}_$hTarget" $3	|| dbg "$cMPub(host=$h): rc=$?" #  $3  passed without quotes on purpose
	done
	}

cStarredToJSON() {
	awk -v a="$*" 'BEGIN { gsub("\"","'\''",a) ; gsub("*","\"",a) ; print a }' # " => ' , then * => "
	}

cMqttStarred() {		# cMS(expandableTopic,message,moreMsoquittoOptions)
		cX
		[ "$hMqtt" -o "$homie" -o "$bMosqFile" ] && [ $cMPub != : ] &&
			cMqtt "$1" "$(cStarredToJSON "$2")" "$3" # ...  replace double quotes by single quotes and stars by double quotes
	}
	alias cMS=cMqttStarred

cMqttReply() {
		cX
		local _cmd="${cmd%%[0-9]*}" # clean trailing digits from the MQTT command
		local _tmp="$2"
		[ "$2" != "${2%:}" ] && _tmp="${2%:} (rc=$ssh_rc${ssh_msg:+,$ssh_msg})" # if $2 ends in :, then append ssh_rc and ssh_msg
		cMS /$_cmd/log "{*status*:*$1*${_tmp:+,*details*:*$_tmp*}${3:+,$3}${fPipe:+, *daemon*:*yes*}}"
		[ "$1" != OK -a "$1" != ONGOING ] && cLogger info "$1: $_tmp $3"
		dbg REPLIED "$1: $_tmp : $3"
	}
	alias cMR=cMqttReply

cBeacon() {
	_pubcmd="$cMPub -h $hPubMqtt" # caution: Freifunk/Gluon seems to need IPV6 connectivity, not all brokers have it!
	# _pubcmd="$cMPub -h broker.hivemq.com" # caution: Freifunk/Gluon seems to need IPV6 connectivity, not all brokers have it!
	_topic="\"$sSite/\`tr A-Z a-z < $fHost\`/installation\"" # tr shall run on remote host with apostrophes!
	dbg SENDING "MQTT message: $_pubcmd $_topic"
	cSsh "$_pubcmd -t $_topic -r -m TEST_$cmd"
	_rc=$ssh_rc
	if [ $ssh_rc != 0 ] ; then
		cErr "$_pubcmd -t $_topic -r -m TEST_$cmd had failed with $ssh_rc ($ssh_msg) on remote host (check why!)"
	else
		dbg SENDING "$_pubcmd $_topic had succeeded, now removing this (retained) msg again..."
		cSsh "mosquitto_sub -h $hPubMqtt -t $_topic -v -C 1 -W 5 --remove-retained"
	fi
	return $_rc
}

# Parameters for cHassAnnounce:
# $1: MQTT "base topic" for states of all the device(s), e.g. "rtl/433" or "ffmuc"
# $2: Generic device model, e.g. a certain temperature sensor model
# $3: MQTT "subtopic" for the specific device instance,  e.g. ${model}/${id}. ("..../set" indicates writeability)
# $4: Text for specific device instance and sensor type info, e.g. "(${id}) Temp"
# $5: JSON attribute carrying the state
# $6: device "class" (of sensor, e.g. none, temperature, humidity, battery),
#     used in the announcement topic, in the unique id, in the (channel) name,
#     and FOR the icon and the device class
# Side effects using global variables:
# $sID:    , $sManufacturer: ... used in device description
# Examples:
# cHassAnnounce "$basetopic" "Rtl433 Bridge" "bridge/state"  "(0) SensorCount"   "value_json.sensorcount"   "none"
# cHassAnnounce "$basetopic" "Rtl433 Bridge" "bridge/state"  "(0) MqttLineCount" "value_json.mqttlinecount" "none"
# cHassAnnounce "$basetopic" "${model}" "${model}/${id}" "(${id}) Battery" "value_json.battery_ok" "battery"
# cHassAnnounce "$basetopic" "${model}" "${model}/${id}" "(${id}) Temp"  "value_json.temperature_C" "temperature"
# cHassAnnounce "$basetopic" "${model}" "${model}/${id}" "(${id}) Humid"  "value_json.humidity"       "humidity"

# cHassAnnounce "ffmuc"     "$ad_devname" "$node/publi../localcl.."     "Readable Name"  ""   "$icontype"
# cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set"      "Radio channel 2.4GHz" "" "counter"
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort/set" "Public SSID Short"  "" "wifi"  # 5: value_json.count
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"          "Public SSID"        "" "wifi"  # 5: value_json.count
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "" "counter"
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" "switch"

cHassAnnounce() {
	cX
	dbg cHassAnnounce "$*"
    local _topicpart="${3%/set}" # if $3 ends in /set it is settable, but remove /set from state topic
	local _command_topic_str="$( [ "$3" != "$_topicpart" ] && echo ",*cmd_t*:*~/set*" )"  # determined by suffix ".../set"
    # local _name="$(e "${2:+$2-}$4" | tr " " "-" | cTrd "[)()]/" )"
    local _dev_class="${6:-none}"
	local _state_class
	local _jsonpath
	local _jsonpath_red
	local _value_template_str
    if [ "$5" ] ; then
		_jsonpath="${5#value_json.}" #  "${_jsonpath//[ \/-]/}"
		_jsonpath_red="$(e "$_jsonpath" | cTrd "][. /-_" )"    # cleaned and reduced, needed in unique id's
		_value_template_str=",*value_template*:*{{ $5 }}*"
		local _devid="$(basename "$_topicpart")"
		local _configtopicpart="$(e "$_topicpart" | cTrd "][ /-" )"
		local _dev_unique_id="$sMe2$2" #   ="${sID}$2"
	    local _dev_name="$2 ${_devid}" # "$2 ${_devid^}"
	else
		local _devid="$2"
		local _configtopicpart="$(e "$_topicpart" | cTrd "][ /-" | cLower )"
		local _dev_unique_id="${sMe2}$2" # remove the trailing process-id
	    local _dev_name="$2"
    fi
    local _topic="${sHassPrefix}/$1${_configtopicpart}$_jsonpath_red/$_dev_class/config"  # e.g. homeassistant/sensor/rtl433bresser3ch109/{temperature,humidity}/config
    local _sensortopic="${1:+$1/}$_topicpart"
	# local *friendly_name*:*${2:+$2 }$4*,

    local _icon_str=",*icon*:*mdi:mdi-$_dev_class*"  # mdi icons: https://cdn.materialdesignicons.com/5.4.55/
    local _unit_str=""
    # local _channelname="$_dev_name ${_dev_class}" # ${_dev_class^}"
   	local _channelname="$_dev_name $4" # take something meaningfull
    case "$_dev_class" in
        temperature*)	_unit_str=",*unit_of_measurement*:*°C*"	; _state_class="measurement" ;;
        humidity)		_unit_str=",*unit_of_measurement*:*%*"	; _state_class="measurement" ;;
        counter)		_unit_str=",*unit_of_measurement*:*#*"	; _state_class="total" ;; # UOM must have a content to trigger recognition as a number on OpenHab
		clock)			_icon_str=",*icon*:*mdi:clock-outline*" ;;
        switch)			_icon_str=",*icon*:*mdi:mdi-toggle-switch*" ;;
		none)			_icon_str="" ;;
        # battery*)     _unit_str=",*unit_of_measurement*:*B*" ;;  # 1 for "OK" and 0 for "LOW".
    esac
	local _dev_model="$2$( [ "$2" != "$_devid" ] && echo " on channel $_devid" )"
    local _device_string="*device*:{*identifiers*:[*$_dev_unique_id*],*manufacturer*:*$sManufacturer*,*model*:*$_dev_model*,*name*:*$_dev_name*,*sw_version*:*$sMe*}"
    local _msg="*name*:*$_channelname*,*~*:*$_sensortopic*,*state_topic*:*~*,$_device_string,*device_class*:*$_dev_class*"
	_msg="$_msg,*unique_id*:*${sMe2}${_configtopicpart}$_jsonpath_red*${_unit_str}${_value_template_str}${_command_topic_str}$_icon_str${_state_class:+,*state_class*:*$_state_class*}"

   	cMS "$_topic" "{$_msg}" "-r" # publish retained announcement
  }

cMqttSub() {
		mosquitto_sub ${hMqtt:+-h $hMqtt} ${sMID:+-i $sMID} "$@" || dbg ERROR "mosquitto_sub to $hMqtt terminated/failed." # would fail when used with multiple hosts...
	}

cHomieReady() {
		local - # && set -x
		_ret="$(cMqttSub -W 2 -C 1 -t "homie/$1/\$state" 2>$fNul | cSanitize)" # security!
		[ "$_ret" = ready ] # return value
	}

hLine() {
		[ "$homie" -a -z "$bHassOnly" -o "$1" = \$state ] && cMqtt "homie/$homie/$1" "$2" "$3"
	}

hMeta() {
		cX
		dbg hMeta "($1,$2,$3)"
		local _msg="$2" ; [ "$bDeleteAnnouncement" ] && _msg="" # bDeleteAnnouncement used in side effect from global var
		local _topic="$(e "$1" | sed -e 's,\([^/]*\)$,$\1,' )" # ... insert a $ before last part of topic 

		hLine "$_topic" "$_msg" -r
	}

hMulti() { # 1: topic, 2: name, 3: retained, 4: settable, 5: datatype, 6: unit, 7: format
		# cX
		# hMulti publicwifi/clientscount "Public WiFi client count" false "" integer "#" "-1:9999"
		# dbg2 "hMulti($1,$2,$3,$4,$5,$6)"
		o="$1"
		if [ "$bDeleteAnnouncement" ] ; then
			cHassAnnounce "" "$ad_devname" "homie/$hTarget/$o" "$2"  ""  sensor
		else
						hMeta $o/name "$2"
			[ "$3" ] && hMeta $o/retained	"${3:-true}"  # default: true
			[ "$4" ] && hMeta $o/settable	"${4:-false}" # default: false
			[ "$5" ] && hMeta $o/datatype	"$5"
			[ "$6" ] && hMeta $o/unit	"$6"
			[ "$7" ] && hMeta $o/format	"$7"

			cHassAnnounce "" "$ad_devname" "homie/$homie/$o$( [ "$4" = true ] && echo "/set" )" "$2" "" sensor
			# cHassAnnounce "" "$ad_devname" "$sSite/$hTarget/statistics"         "Public Wifi RX bytes"   "value_json.traffic.rx" "counter"
			# cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi TX bytes"   "value_json.traffic.tx" "counter"
		fi
	}

cBothMqtt() {
		cMS		"/$1" "$2"
		hLine	"$1" "$2"
	}

cEchoPub() {
		cEcho	"$2"
		cBothMqtt "$cmd/$1" "${3:-$2}"
		# cMS		"/$cmd/$1" "${3:-$2}"
		# hLine	"$cmd/$1" "${3:-$2}"
	}

announce_disco() { # $1: <homie-host>,  $2: "-d" if retained advertisements are to be deleted.
	# NB: $hTarget and optionally $bDeleteAnnouncement must have been set!

	local -
	local _nDay="$(cCRead $hTarget.AnnounceDay 9999)"

	if [ "$2" = "-d" -o "$bDeleteAnnouncement" ] ; then
		cMqtt "debug/$1" "DELETE ANOUNCEMENTS BEGIN: $1,bDeleteAnnouncement=$bDeleteAnnouncement"
		bDeleteAnnouncement="yes" # used in side effect in hMeta, will be resetted further down
		# use "remove-retained" feature from newer mosquitto-clients versions:
		_top="homie/$homie/#"
		cMqttSub -W 1 -t "$_top" --remove-retained --retained-only >$fNul 2>&1
		_rc=$?
		[ "$_rc" -ne 0 -a "$_rc" -ne 27 ] && dbg "Removal of retained topics below $_top returned $_rc"
	else
		# cMqtt "debug/$1" "MQTT ANOUNCEMENTS BEGIN (arg2=$2)"
		[ "$sSshUser" = "NOUSER" ] && { hLine '$stats/uptime' "$(cut -d. -f1 </proc/uptime)" ;}
		# cHomieReady "$1" ; echo DEBUG: $?
		if [ "$_nDay" ] && [ "$(date +%j)" -eq "$_nDay" ] && [ -z "$bForceMQTTAnnounce" ] && cHomieReady "$1" ; then
			dbg announce_disco ": skip announcements, homie state is ready... (bForceMQTTAnnounce=$bForceMQTTAnnounce)" # (re-)announce ONLY IF restart or new day or necessary
			return 0
		fi
		dbg announce_disco ": WILL ANNOUNCE ... (arg1=$1,arg2=$2, bForceMQTTAnnounce=$bForceMQTTAnnounce)"
		os_data="$(cGetOSData)"
		ad_devname="$(e "$1" | awk '{print toupper(substr($i,1,1)) substr($i,2) }' )"
		ad_fwid="$(cCRead $hTarget.os_id 9)"
		ad_fwname="$(cCRead $hTarget.os_name 9)"
		ad_fwversion="$(cCRead $hTarget.os_pretty_name 9)"
		ad_impl="$(cCRead $hTarget.os_id 9)"
		dbg announce_disco "($1,$2): announcing ad_devname=$ad_devname,ad_fwname=$ad_fwname,ad_fwversion=$ad_fwversion,ad_impl=$ad_impl"
	fi
	if [ -z "$bDeleteAnnouncement" ] ; then
		hMeta homie "3.0.1"
		hMeta state init
		hMeta name  "$ad_devname"

		[ "$ad_fwname"    -o "$2" ] && hMeta fw/name        "$ad_fwname"
		[ "$ad_fwversion" -o "$2" ] && hMeta fw/version     "$ad_fwversion"
		[ "$ad_impl"      -o "$2" ] && hMeta implementation "$ad_impl"
		
		sManufacturer="$ad_fwversion"

		# hMeta $1 "stats/interval" 600
		# hMulti() { # 1: name, 2: retained, 3: settable, 4: datatype, 5: unit, 6: format }
		# Defaults are ... settable=false   retained=true
		hMeta nodes		"publicwifi,gluondata,radio"
		hMeta radio/name       "Wifi Radio"
		hMeta radio/type       "Wifi Radio Hardware"
		hMeta radio/properties "channel24"
		hMulti radio/channel24         "Radio channel 2.4"        false "" integer ""  "1:13"

		hMeta publicwifi/name       "Public Wifi"
		hMeta publicwifi/type       "Public Wifi Network"
		hMeta publicwifi/properties "clientscount,state,ssidshort,ssid"
		hMulti publicwifi/clientscount "Public WiFi client count" false "" integer "#" "-1:9999"
		# hMulti publicwifi/lastdate "Last date sent" false "" DateTime "" ""
		hMulti publicwifi/state        "Public WiFi state"        "" true boolean "" ""

		_gluondomains=$(cCRead $hTarget.gluondomains 9)
		if [ "$_gluondomains" ] ; then
			_wifi_domains="$(e "$_gluondomains" | cTrd "][*" | awk -F= '{ printf lim $1 ; lim="," }' )" # rough hack...
			dbg wifi_domains "$_wifi_domains"
				# 1: root, 2: name, 3: retained, 4: settable, 5: datatype, 6: unit, 7: format
			hMulti publicwifi/ssidshort "Public WiFi short SSID" false true enum "" "$_wifi_domains" # rough hack...
		else
			hMulti publicwifi/ssidshort "Public WiFi short SSID" false "" string "" ""
		fi
			hMulti publicwifi/ssid      "Public WiFi SSID"       false true string "" ""

		hMeta gluondata/name       "Node Data"
		hMeta gluondata/type       "Gluon Data"
		hMeta gluondata/properties "autoupdater-branch,autoupdater-enabled,gluon-version,release,model,core-domain"
		hMulti gluondata/autoupdater-branch "Autoupdater Branch" false "" string "" ""
		hMulti gluondata/autoupdater-enabled "Autoupdater Enabled" false "" boolean "" ""
		hMulti gluondata/gluon-version "Gluon Version" false "" string "" ""
		hMulti gluondata/release "Local Release" false "" string "" ""
		hMulti gluondata/model "Hardware Model" false "" string "" ""
		hMulti gluondata/core-domain "Core Domain" false "" string "" ""
		hMulti gluondata/gluon-domains "Gluon Domains" false "" string "" ""
		hMeta state ready
	fi

	# https://www.home-assistant.io/docs/mqtt/discovery/
	if [ "$bDeleteAnnouncement" ] ; then
	    _topic="$sHassPrefix/#" # deletes eveything below "homeassistant/sensor/..." !
		dbg "Removing all announcements matching $_topic ... (timeout ok)"
		cMqttSub -W 1 -t "$_topic" --remove-retained --retained-only >$fNul
		_rc=$?
		[ "$_rc" -ne 0 -a "$_rc" -ne 27 ] && dbg "Removal of retained topics below $_topic returned $_rc"
		cMS "$sSite/$1/state" "{*event*:*cleaned*,*note*:*removed all announcements starting with $_topic*}"
	else
		cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set" "Radio channel 2.4GHz" "" "counter"
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort/set" "Public SSID Short"  "" "wifi" 
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"      "Public SSID"        "" "wifi" 
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "value_json.count" "counter" # 5: value_json.count
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" "switch"
		# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/lastdate"    "Last date wifi check" "" "clock"
	fi
	cMqtt "debug/$1" "HOMIE/HASS ANOUNCEMENTS END (bDeleteAnnouncement=$bDeleteAnnouncement)"

	bDeleteAnnouncement="" # end of side effect
	cCWrite .AnnounceDay "$(date +%j)" # support reducing re-announcements to only once per day
  }

OPTIND=1         # reset to 1 in case getopts has been used previously in the shell.
# Initialize our own variables:
bQuiet=""
bVerbose=""

bDoAll=""
commands="" # commands="mesh-id"
sUciQuery=""
sUciVal=""
cMPub=mosquitto_pub
cCmv $cMPub || { cMPub=":" ; dbg "Variable/command cMPub=*$cMPub* (: is dummy)." ;}

jsonfilter=$(command -v jq ) || jsonfilter=$(command -v jsonfilter) || cErrAndExit "jsonfilter or jq must be made available."
jsonfilter=$(basename "$jsonfilter")
cCmv json_pp || alias json_pp=cat
# alias cBeautify="jq -Sm" ; cCmv jq || alias cBeautify="cat"

[ $# -eq 0 ] && { cHelp ; exit 1 ;} # at least one parameter on the command line is required

while getopts "?h:Gvxql:as:pPR:f:m:g:n:c:o:w:" opt   # https://wiki.bash-hackers.org/howto/getopts_tutorial
do
    case $opt in
    \?) cHelp
		[ $cMPub = : ] && cErrAndExit "$MP is not installed (consider running \"-c install\"!"
        exit 1
        ;;
    h|s) ffhosts="$OPTARG" # one or more Freifunk node(s)
		if expr index ."$ffhosts" "+*" >$fNul # substitute '+' or a '*'' for a set of predefined hosts
		then
			# multiple "host1,host2,host3" (without double quotes)
			# values used for + or * should be stored in the file $dUser/myhosts.persisted:

			_tmp="$(cUserRead myhosts)" || cErrAndExit "config for collection of hosts is missing ($dUser/myhosts.persisted)"
			ffhosts="$(e "$ffhosts" | sed "s/[+*]/$_tmp/g" | cSanitize)" # replace + and sanitize
			bWorkAllClients="yes"
		fi
        ;;
    G) [ "$nGiveHost" ] && nGiveHost=2 || nGiveHost=1 # file descriptor to send output to: -G = stdout, -G -G = stderr
		;;
    v) [ "$bVerbose" ] && bVeryVerbose="yes" && nMqttSleep=60 || nMqttSleep=230 # not to small to allow for gathering status in between !
		bVerbose="yes"
		;;
	x) bVerbose="yes" && bTrace="yes"
		set -o xtrace
        ;;
	l)  ;;
	q) bQuiet="yes"
		;;
	a) [ "$bDoAll" ] && bDoExperiment="yes" # set after -a -a ...
		bDoAll="yes"
		bForceMQTTAnnounce="yes" # -a forces auto-discovery announcements even if retained before' ...
		;;
	m)	[ "$OPTARG" -a $cMPub = : ] && cErr "$MP is missing!"
		case "$OPTARG" in     # see http://www.steves-internet-guide.com/mqtt-hosting-brokers-and-servers/
		test)	_m=$hPubMqtt ;;
		eclipse) _m="mqtt.eclipseprojects.io"   ;;
        hivemq)	_m="broker.hivemq.com"   ;;
        emqx)	_m="broker.emqx.io"   ;;
		dash)  _m="broker.mqttdashboard.com"    ;; # https://moxd.io/2015/10/17/public-mqtt-brokers/
		*)	_m="$(e "$OPTARG" | cSanitize | tr "," " ")" ;; # clean up for sec purposes, allow comma to seperate multiple hosts
		esac
		hMqtt="${hMqtt:+$hMqtt }$_m"
		;;
	g) mqttGroup="$OPTARG"
		;;
	p|P) homie="yes" ; [ $opt = p ] && bHassOnly="yes"
		[ $cMPub = : ] && cErrAndExit "MQTT client $MP is not installed, but -$opt was requested..."
		;;
	R) sArea="$OPTARG"
		;;
	f) fCopy="$OPTARG"
		commands=filecopy
		;;
	n) one_additional_option="$OPTARG"
		sGrepSsid="$OPTARG"
		;;
    c) commands="$OPTARG" # one or more, comma-seperated command to be executed
        ;;
    o) sUciQuery="$OPTARG" ; commands=uciquery
		# echo sUciQuery="$sUciQuery"
        ;;
    w) sUciVal="$OPTARG" ; commands=uciwrite
		# echo sUciVal="$sUciVal"
        ;;
    esac
done

shift "$((OPTIND-1))"   # Discard the options parsed so far and leave the rest of the cmd line...

# [ "$bQuiet"	] || alias cEcho=": cEcho"
[ "$bVerbose"	] || alias dbg="false dbg"
[ "$bVeryVerbose" ] && alias dbg2=dbg || alias dbg2="false dbg2"

if [ "$homie" -o "$hMqtt" -o "$bMosqFile" ] ; then # enable MQTT
	: dbg "MQTT commands real."
else
	dbg2 "MQTT commands aliased."
	alias cMS=": cMS"
	alias hLine=": hLine"
	alias hMeta=": hMeta"
	alias cMqttReply=": cMqttReply"
fi

if [ -d $dGluon -o -x /usr/sbin/print_map.sh ] ; then   # I'm running on Gluon (which is based on OpenWrt)
	[ "$hMqtt" -o "$bMosqFile" ] || hMqtt=$hPubMqtt
	fMacIDs="/tmp/phones"
else                                      # on rest-of-world (e.g. Raspi or some fullblown OpenWrt)
	[ "$hMqtt" -o "$bMosqFile" ] || hMqtt=$LH
	fMacIDs="/srv/openhab-conf/phones"
fi

fCollection=""
fSleep=$dTmp/sl

ffhosts="$(e "${ffhosts:-$LH}" | tr -s "," " " | cLower)" # if none given, take localhost
for hFull in $ffhosts # do it for each given host (maybe just one)...
do
	ssh_rc=0 # reset for connection result caching
	if [ "$hFull" = localhost ] ; then
		sSshUser="NOUSER"
		cSsh() {
			ssh_msg=""
			ssh_data="$(eval "$@")"
			ssh_rc=$?
			[ $ssh_rc -eq 127 ] && ssh_msg="CMD NOT FOUND"
			return $ssh_rc
		  }
		hTarget="$sArea"
	else
		sSshUser="root@$hFull"
		cSsh() {
			# cEcho "$sSshUser:" "$@" 1>&2
			cX
			ssh_msg=""
			[ "$bVeryVerbose" ] && dbg SSH "Running $sSshUser: $*"
			_r="$(ssh $sSshUser -q "$@")"
			ssh_rc=$?
			ssh_data="$(echo "$_r" | cTrd '`')"
			if [ $ssh_rc -gt 0 ] ; then
				[ $ssh_rc -eq 255 ] && ssh_msg="UNREACHABLE"
				[ $ssh_rc -eq 127 ] && ssh_msg="COMMAND NOT FOUND"
				dbg SSH " $sSshUser RETURNED $ssh_rc ($ssh_msg)" 1>&2
				cLogger error "$* = $ssh_rc"
			fi
			return $ssh_rc
  		  }	
		# remove any trailing "-<letter>"  also the domain name
		hTarget=$(e "$hFull" | awk '{ $0=tolower($0) ; gsub("\\..*","") ; gsub("-[a-z]$","") ; print }' )
	fi
	_string="" && [ "$sSshUser" = "${sSshUser%${hTarget}-e}" -a "$sSshUser" = "${sSshUser%${hTarget}}" ] && _string="($hTarget) "
	[ "$bVerbose" -o "$nGiveHost" ] && ECHO "\n######## ${sSshUser#root@} $_string//${commands:+ $commands //} $*" "########" >& ${nGiveHost:-1}

	cGetSitecode # reusing value for all other nodes, too.
	fTmpMqtt=$dTmp/mqtt.$hFull
	sNewSSID=""
	if [ "$sUciQuery" ] ; then
		cSsh "uci show $1"
		_val="$ssh_data"
		if [ "$bDoAll" ] ; then
			echo "$_val"
		else
			_val="$(cExtractVals "$_val")"
			if [ -z "$sUciVal" ]  ; then
				echo "$_val" # it was a query only = no writes
			elif [ "$(e "$_val" | wc -l)" -gt 1 ] ; then
				cErrAndExit "key :$sUciQuery: returned more than one line!"
			else
				cSsh "uci set $sUciQuery=$sUciVal && uci commit $sUciQuery"
				cOut
			fi
		fi	
	else
		cmdsToDo="$commands"

		if [ "$cmdsToDo" = bridge ] ; then
			# prepare subscibing for MQTT messages...
			mqttGroup="$(cExpand $mqttGroup)"
			fPipe=$dTmp/p
			{ mkfifo $fPipe && chmod go-rwx $fPipe ;} || cErrAndExit "Could not create $fPipe (rc=$?)."
			for t in $hTarget $mqttGroup ; do
				_p="-t $sSite/$t"
				_subscriptions="$_p/+/get $_p/+/+/get $_p/+/set $_p/+/+/set"
			done
			[ "$homie" ] && _subscriptions="$_subscriptions -t homie/$hTarget/+/+/set"
				trap_child() {
					[ "$1" ] && cErr "TRAP_CHLD: param=$1"
				}		
				trap 'trap_child' CHLD

			dbg "SUBSCRIBING to MQTT broker: \"$hMqtt $_subscriptions\", homie=$homie, fPipe=$fPipe"
			_last_will_options="--will-qos 0 --will-topic $sSite/$hTarget/bridge/log --will-payload {\"status\":\"OFF\"}"
			# cMqttSub -F "MQTT %t %p" -R $_subscriptions $_last_will_options > $fPipe &    # ... doesn't work: mosquitto_sub exits if pipe not ready....  
			cMqttSub -F "MQTT %t %p" -R $_subscriptions $_last_will_options | awk -v f="$fPipe" '{ print $0 > f ; close(f) }' & #  pipe non-stale commands from MQTT broker
			readonly nPidMosq=$!
			dbg "SUBSCRIBED: nPidMosq=$nPidMosq"
			cmd="bridge" && cMR ON "Subscribed $(awk -v a="$_subscriptions" 'BEGIN {gsub("-t ","",a) ; print a}' )"
			
			_ms=5 #  pipe periodic stuff into the pipe to make it wakeup at most every $_ms seconds
			while sleep $_ms ; do [ -r "$fSleep" ] && nMqttSleep="$(awk "{ print \$1<$_ms ? 0 : \$1-$_ms ;exit}" "$fSleep" )" ; echo PERIODIC noop "${nMqttSleep}secs" ; sleep "$nMqttSleep" || true ; done  > $fPipe &
			readonly nPidPeriodic=$!
			
			if cCmv ubus ; then  #  .. and enable a listener for the ubus bus:
				( ubus listen & echo $! > $dTmp/ubusPid ) | awk '{print "UBUS LISTEN " $0 ; fflush()}' > $fPipe &
				readonly nPidUbus="$(cat $dTmp/ubusPid)"
				dbg UBUS "Background ubus listen pid is: $(pgrep -lfa "ubus listen")"
				ubus send $sMe '{"debug":"started"}'
			fi

			dbg "Started procs: nPidMosq=$nPidMosq,nPidPeriodic=$nPidPeriodic,nPidUbus=$nPidUbus,fPipe=$fPipe"
			
			trap_function() {
					cmd="bridge" && cMR ONGOING "trapped signal."
					rm -f $fPipe
					kill $nPidPeriodic $nPidMosq $nPidUbus 2>$fNul || true
 					dbg "$sMe: killed $nPidMosq $nPidPeriodic $nPidUbus, sent MQTT, now stopping at $(date)"
				}		
			trap 'trap_function' INT QUIT TERM SEGV
		fi
		# NB: OpenHab Homie autodiscovery doesn't like uppercase characters at the beginning...
		[ "$homie" ] && os_data="$(cGetOSData)" && homie="$(cLower $hTarget)" &&  # change "yes" to $hTarget
			 [ "$cmdsToDo" != "homie-delete" ] && announce_disco "$homie"

		dbg LOOP "START (cmdsToDo=$cmdsToDo)"
		while [ "$cmdsToDo" ] ; do
			if [ "$cmdsToDo" = bridge ]  ;  then
				cmd=""
				dbg READ "Will read $fPipe ..."
				read -r sPipeType cmd cmdopts <$fPipe
				_rc=$?
				dbg RAW "Read sPipeType=$sPipeType,cmd=$cmd,cmdopts=$cmdopts,rc=$_rc"
				if [ "$_rc" -ne 0 ] ; then
					if [ -p $fPipe ] ; then
						_msg="Read error from pipe (rc=$_rc)"
						cMR ERROR "$_msg"
						cErrAndExit "$_msg: $( ls $fPipe 2>&1 )"
					else
						cMR OFF "Exiting (read_rc=$_rc)."
						exit 0
					fi
				fi				
				if [ "$sPipeType" = UBUS ] ; then
					dbg READ "TYPE=$sPipeType,$cmd,$cmdopts"
					cMqtt /ubus/log "$cmdopts" 
					# cOut | sed ':a;s/^\(\([^"]*"[^"]*"[^"]*\)*[^"]*\) /\1/;ta'  # would remove spaces
					# cOut | awk -F\" '{OFS="\"";for(i=2;i<NF;i+=2)gsub(/ /,"@",$i);print}'   # would remove spaces
					cmdsToDo="bridge"
					continue
				elif [ "$sPipeType" = PERIODIC ] ; then
					dbg "\nREAD" "TYPE=$sPipeType,$cmd,$cmdopts ($(date +%T))"
					[ "$bVerbose" ] && cMS /bridge/state "{*TelePeriod*:$nMqttSleep}" # FIXME: might have been modified in subshell
					[ "$cmdopts" != noop ] && cmdsToDo="wifistatus,statistics,bridge"
					continue
				elif [ "$sPipeType" = MQTT ] ; then
					_prefix="$(e "$cmd" | awk -v FS=/ '{print $1 "/" $2}' )"
					cmdopts="$(cFirstJsonAttr "$cmdopts")"
					cmdopts="$(cExpand "${cmdopts%(null)}")"
					dbg READ "command: $cmd  $cmdopts (prefix=$_prefix, sSite=$sSite)"
					case "$_prefix" in
					"homie/$hTarget"|"$sSite/$hTarget"|"$sSite/${mqttGroup:-$hTarget}")
						cmd="$(e "$cmd" | cut -d/ -f3- )" ; cmd="${cmd%/get}"
						# cmd="$(e "$cmd" | awk -v FS=/ 'NF && NF-1 { print $3 ( $4 && $4 == "get" ? "" : "/" $4 ) ( $5 && $5 == "get" ? "" : "/" $5 ) }' )"
						case "$cmd" in
						localclients*|publicwifi/localclients*)				cmd="localclients" ;;
						publicwifi/ssidshort/set) cmd="wifissid_$cmdopts" ;;
						radio/channel24/set)		cmd="channel24" ;;
						publicwifi/state/set) 	{ [ "$cmdopts" = true  -o "$cmdopts" = ON  ] && cmd="wifiup" ;} ||
												{ [ "$cmdopts" = false -o "$cmdopts" = OFF ] && cmd="wifidown" ;} ||
												cErr "Illegal cmdopts=$cmdopts"
											;;
						wifistatus*|radio/channel24|publicwifi/state|publicwifi/ssidshort|publicwifi/ssid) cmd="wifistatus" ;;
						wifiup*)		cmd="wifiup"   ;;
						wifidown*)		cmd="wifidown" ;;
						echo*)			cmd="echo"   ;;
						loop*)			cmd="loop"   ;;
						sSite*)			cmd="sSite"  ;;
						gluon-data*)	cmd="gluondata" ;;
						machine-data*)	cmd="machine-data" ;;
						wifissid*)	cmd="wifissid_$cmdopts" ;;
						esac
						;;
					*) cmd="$(e "$cmd" | awk -v FS=/ 'NF && NF-1 {print ($(NF-1)) }' )"
						;; # extract second last part of topic, must have at least one /
					esac
					cmd=${cmd%/get} && cmd=${cmd%/GET}
					dbg READ "Remapped MQTT to command: $cmd"
				else
					cErrAndExit "Unknown sPipeType=$sPipeType from pipe $fPipe (rc=$_rc)"
				fi
			else
			    	 cmd="$(e "$cmdsToDo"	| cut -d, -f1 )"
				cmdsToDo="$(e "$cmdsToDo"	| cut -d, -f2- -s )"
			     cmdopts="$(e "$cmd"		| cut -d+ -f2- -s )" # split further...
				     cmd="$(e "$cmd"		| cut -d+ -f1 )"
			fi		
			    cmd="$(e "$cmd" 	| cSanitize)" # for security reasons
			cmdopts="$(e "$cmdopts" | cSanitize)"
			[ "$bVeryVerbose" ] && dbg COMMAND " $cmd ($cmdopts) (REMAIN: $cmdsToDo)"
			case "$cmd" in
			help) # really unstable implementation by grepping the script code for case branches that look like a command ....
				cProbeGET
				_msg="$( awk '$1 ~ /^[a-z]{3,}[a-z|]+)/ { gsub(/)/,"",$1); gsub(/\|/," ",$1); if ($1=="help") doit="y" ; if (doit) printf $1 " " }' "$0")"
				cEcho "$_msg"
				cMR OK "Command $cmd($cmdopts): $_msg"				
				;;
			bridge|noop|ignore|echo|date)
				dbg COMMAND "cmd=$cmd,$cmdopts,($(date +%T))"
				[ $cmd = echo ] && { cMR OK "Command $cmd($cmdopts=$(cExpand "$cmdopts")) from $(cat $fHost) at $(date +%c)" ; [ "$cmdopts" = TESTERROR ] && cErr "Test error" ;}
				[ $cmd = date ] && { _msg="$(date) (PID=$(cPid))" ; cEcho "$_msg" ; cMR OK "Command $cmd($cmdopts): $_msg" ;}
				;;
			beacon)
				cProbeGET
				cBeacon
				;;
			autossh)
				cProbeSET
				_ml="$((${cmdopts:-12} * 3600 - 15	))" # Default = almost 12 hours
				dbg AUTOSSH "maxlife=${_ml}s : ffhosts=$ffhosts"
				# if [ "${ffhosts#"$hFull"}" != "$ffhosts" ] ; then # do it for all hosts at once, in the first iteration

					# AUTOSSH_GATETIME    # how long must an ssh session be established before we decide it really was established
					#                       (in seconds). Default is 30 seconds; use of -f  flag sets this to 0.
					# AUTOSSH_LOGFILE     # file to log to (default is to use the syslog facility)
					# AUTOSSH_LOGLEVEL    # level of log verbosity, corresponding to the levels used by syslog; so 0-7 with 7 being the chattiest
					export AUTOSSH_MAXLIFETIME=$_ml # set the maximum time to live (seconds) # 604800s = 1 week
					export AUTOSSH_MAXSTART=-1    # max times to restart (default -1 means no limit)
					# AUTOSSH_MESSAGE     # message to append to echo string (max 64 bytes)
					# AUTOSSH_PATH        # path to ssh if not default
					export AUTOSSH_PIDFILE=$dTmp/autossh.pid     # write pid to this file
					export AUTOSSH_POLL=40        # how often to check the connection (default 600 seconds)
					# AUTOSSH_FIRST_POLL  # time before first connection check (seconds)
					# AUTOSSH_PORT        # port to use for monitor connection
					# AUTOSSH_DEBUG       # turn logging to maximum verbosity and log to                           stderr
					[ "$bVerbose" ] && env | grep AUTOSSH | xargs 1>&2
					# set -x #  manage_gluon_mqtt -m localhost -c bridge -v
					if [ "var1" ] ; then
						_mpcmd="$cMPub -r -h localhost -t $sSite/$hTarget/autossh/checktime"
						cSsh "d=\$(date '+%c (heartbeat)') && $_mpcmd -m \"\$d\" && $sMe -m localhost -c memory"
						_msg="${cmdopts:+($cmdopts) }"
						if [ $ssh_rc = 0 ] ; then
							cMR OK "${_msg}already had MQTT listener, doing nothing."
						else
							_msg="${_msg}check result: ${ssh_msg:-$ssh_rc}, "
							if [ $ssh_rc = 127 ] ; then
								_msg="${_msg}no $MP? - run -c install first!"
								dbg AUTOSSH "$_msg"
								cErr "$_msg"
								cMR ERROR "$_msg:"
							elif [ $ssh_rc = 255 ] ; then
								_msg="${_msg}doing nothing."
								dbg AUTOSSH "$_msg"
								cMR ERROR "$_msg:"
							else
								_msg="${_msg}will start autossh ($cmdopts) and run check"
								dbg AUTOSSH "$_msg"
								_spec="[::]:1883:localhost:1883" # "[::]:1883:localhost:1883"
								# this line must be in /etc/config/dropbear:
								# option GatewayPorts 'on'
								autossh -f -N -T ${bVeryVerbose:+-v} -R "$_spec" $hFull "$sMe -m localhost -c bridge ${mqttGroup:+-g $mqttGroup}" # || dbg AUTOSSH "rc=$?"
								sleep 3
								_pid="$(cat $AUTOSSH_PIDFILE)"
								dbg AUTOSSH "pid=$_pid"
								cSsh "date '+%c (restarted autossh)' | $_mpcmd -l"
								# cSsh "netstat -l | grep 1883"
								cMR OK "Command $cmd $cmdopts executed."
							fi
						fi
#DELETE_BEGIN#
					else
						# nPidAutoSSH=$! # nPidAutoSSH="$(cat $AUTOSSH_PIDFILE)"
						# dbg AUTOSSH "pid=$nPidAutoSSH for: $ffhosts"
						sleep 10
						trap_autossh() {
							cmd="autossh" && cMR ONGOING "exiting."
							jobs
							wait $nPidAutoSSH
							kill $nPidAutoSSH 2>$fNul || :
							dbg AUTOSSH "Killed nPidAutoSSH=$nPidAutoSSH, now stopping at $(date)"
						}		
						trap 'trap_autossh' EXIT
#DELETE_END#
					fi
				# fi
				;;
			loop)
				cProbeGET
				cmdopts="${cmdopts:-5}"
				cMR ONGOING "$cmd'ing $cmdopts times"
				if [ 2 -le "$cmdopts" -a 11 -ge "$cmdopts" ] ; then
					_cmd='cSsh date -u +%s'
					$_cmd ; startval="$ssh_data" && cEcho "$startval"
					for i in $( seq $((cmdopts - 1)) ) ; do
						$_cmd
						dbg $cmd "$ssh_data"
					done && cEcho
					cMR OK "Command $cmd: Performed $cmdopts-times /bin/date in $(( ssh_data - startval)) seconds: $startval-$ssh_data"
				else
					cMR ERROR "$cmd: Invalid parameter '$cmdopts'"
				fi
				;;
			install)
				cProbeNOMQTT
				cSsh "id -nu"
				_user="$(cOut|cSanitize)"
				# sNewName="$cmdopts"
				if [ -z "$_user" ] ; then
					cErr "targetuser on targethost could not be determined remotely. Debug your SSH setup:"
					continue # abort case
				fi

				if [ "$hFull" != localhost -o "$(dirname "$0")" != /sbin ] && [ "$_user" = root ] ; then
					cEcho "Remote targetuser is $_user: Will try to copy this script to /sbin later..."
					cmdsToDo="filecopy${cmdsToDo:+,$cmdsToDo}"
					fCopy="$0"
				fi

				os_data="$(cGetOSData)"
				dbg "$os_data"

				cSsh "df -PhT"
				_sizedata="$ssh_data" # TODO: duplicated code from "mountsizes", save result for later

				# ... try to install mosquitto if not there yet
				cSsh "command -v $MP"
				if [ "$ssh_data" ] ; then
					cEcho "$MP already installed on $hFull..."
				else
					cEcho "$MP not found on $hFull... trying to determine install cmd ..."
					cSsh "command -v opkg || command -v apt || echo nothing" 2>$fNul
					_scmd="$(basename "$ssh_data")" && _c="$_scmd update && $_scmd install mosquitto"
					case "$_scmd" in
					opkg|X)
						# FIXME on newer Gluon - might needed for SSL downloads:
						# 1) temporarily change https to http for "openwrt_packages" in /etc/opkg/distfeeds.conf
						# 2) opkg install libustream-tls && opkg install ca-certificates  #   or opkg ... --no-check-certificate
						_c="$_c-client-nossl"
						;;
					apt|X)
						_c="$_c-clients"
						;;
					nothing|X)
						cErrAndExit "ERROR: opkg / apt not found on $hFull. Stopping..." || continue # never gets here afterwards
						;;
					esac
					cEcho "Executing: $_c (please wait)"
					cSsh "$_c" # || { cEcho "cSsh failed: $_c, aborting ..." ; continue ;}
					_msg="$ssh_data (rc=$ssh_rc)"
					dbg INSTALL "$_msg" || echo "Installer returned $_msg"
				fi
				[ $ssh_rc -ne 0 ] && { cEcho "cSsh failed: $_c, aborting ..." ; continue ;}

				# PS1='\[\033[31;1m\]\h \[\033[32;1m\]$PWD\[\033[0m\] \[\033[31m\]\$\[\033[0m\] ' # nicer prompt on OpenWrt
				# FIXME: ensure that its done only once...
				echo PS1=\''\[\033[31;1m\]\h \[\033[32;1m\]$PWD\[\033[0m\] '\' | cSsh 'mkdir -p /etc/profile.d && cat >> /etc/profile.d/my.sh' 

				# now comes a Gluon-specific part - determine Gluon by checking for the UCI entry autoupdater_branch
				cSsh "uci get autoupdater.settings.branch"
				dbg autoupdater_branch "$ssh_data"
				if [ -z "$ssh_data" -o -z "$bDoAll" ] ; then  # empty data = probably Non-Freifunk					
					cEcho "Done partly install for target $hTarget (autoupdater_branch=$ssh_data,bDoAll=$bDoAll)..."
					ssh_data="$_sizedata" # inject the previously saved size data...
					cmdsToDo="mountsizes_prev${cmdsToDo:+,$cmdsToDo},mountsizes"
					continue # quit installation here, unless on Gluon or $bDoAll = yes
				fi
				cCWrite .autoupdater_branch "$ssh_data"
				
				if [ "yup" -a -z "$bDoExperiment" ] ; then # skip for now
					# similar to https://ffmuc.net/wiki/doku.php?id=knb:ssh#webseite_des_ff-knoten_aus_dem_lan_aufrufen :
					# uci set firewall.wan_http=rule
					# uci set firewall.wan_http.name=wan_http
					# uci set firewall.wan_http.src=wan
					# uci set firewall.wan_http.proto=tcp
					# uci set firewall.wan_http.dest_port=80
					# uci set firewall.wan_http.target=ACCEPT
					# uci commit
					# /etc/init.d/firewall reload
					# uci delete firewall.wan_http
					
					# TRY LATER: wan over wifi: https://harz.freifunk.net/wiki/doku.php/anleitungen/gulon/wwan

					cEcho "autoupdater config found ... assuming Gluon node ... add firewall rules for incoming MQTT..."
					# works for Ulmer Software w/o Gluon, too... DONT KNOW IF NECESSARY ON ALL GLUON VERSIONS
					cSsh "xargs ${bVerbose:+-t} -n 1 uci set ; uci commit" << EOF
						firewall.wan_mqtt=rule
						firewall.wan_mqtt.name='wan_mqtt'
						firewall.wan_mqtt.src=wan
						firewall.wan_mqtt.proto='tcp'
						firewall.wan_mqtt.dest_port='1883'
						firewall.wan_mqtt.target='ACCEPT'
						firewall.mesh_mqtt=rule
						firewall.mesh_mqtt.name='mesh_mqtt'
						firewall.mesh_mqtt.src=mesh
						firewall.mesh_mqtt.proto='tcp'
						firewall.mesh_mqtt.dest_port='1883'
						firewall.mesh_mqtt.target='ACCEPT'
EOF
					cSsh "/etc/init.d/firewall reload" || dbg "Failed to reload firewall."
					cOut
				fi
				
				if [ "$bDoExperiment" ] ; then 
					cEcho "... adding other firewall rules for outgoing MQTT..."
					# works for Ulmer Software w/o Gluon, too... DONT KNOW IF NECESSARY ON ALL GLUON VERSIONS
					{
					# echo firewall.any_mqtt=rule
					# echo firewall.any_mqtt.src_port='1883'
					# echo firewall.any_mqtt.dest='mesh'
					# echo firewall.any_mqtt.name='any_mqtt'
					# echo firewall.any_mqtt.target='ACCEPT'
					# echo firewall.any_mqtt.proto='tcp'
					for x in loc_client wan mesh ; do
						_r="${x}_mqtt"
						echo firewall.$_r.name="$_r"
						echo firewall.$_r=rule
						echo firewall.$_r.dest_port="1883"
						echo firewall.$_r.src="$x"
						echo firewall.$_r.target="ACCEPT"
						echo firewall.$_r.proto="tcp"
					done
					} | cSsh "xargs ${bVerbose:+-t} -n 1 uci set ; uci commit"
					
					cSsh "/etc/init.d/firewall reload" || dbg "Failed to reload firewall."
					cOut
					exit 55
				fi
				
				if cBeacon ; then
					if cSsh "crontab -l | grep \"$sMe\"" ; then
						cEcho
						dbg MODIFY "A crontab line containing '$sMe' was found... Leaving crontab unmodified."
					else
						cEcho "crontab entry with '$sMe' not found... adding a simple one... pls modify it later!!"
						_line="0 * * * * sleep 50 ; $sMe -c echo+LOCALCHIME,machine-data,statistics -r -m $hPubMqtt,localhost"
						cSsh "{ crontab -l ; echo \"$_line\" ;} | crontab - ; ${bVerbose:+echo crontab is now: ; crontab -l}"
						cEcho
					fi
				fi

				_f=~/.ssh/id_rsa_piraten.pub
				[ -r "$_f" ] && { dbg PUBKEY "Copying $_f" || echo "Public key file: $_f";} && 
						cat $_f | cSsh 'cat >> /tmp/pubkey ; ls -al /tmp/pubkey'

				# ... still not implemented: installing it as an MQTT daemon on Gluon ...
				_f=/etc/rc.local
				cSsh "cat $_f"
				if cOut|grep $sMe ; then
					dbg MODIFY "The $_f line containing '$sMe' was found above... Leaving $_f unmodified."
				else
					cEcho "$_f entry with '$sMe' not found... adding a simple one... pls modify it later!!"
					_line="\( sleep 240 \; $sMe -c echo+BOOTED,machine-data,statistics -m $hPubMqtt,localhost \; \) \&"
					# sed -i -e '$s/exit 0/exit 0\naaa/g' rc.local
					cSsh "sed -i.sav -e  \"s/^exit 0/$_line\\nexit 0/\" $_f ; 	${bVerbose:+echo $_f is now: ; cat $_f }"
					cEcho
				fi
				;;
			filecopy|selfcopy)
				cProbeNOMQTT
				fCopy="${fCopy:-$cmdopts}"
				fCopy="${fCopy:-$0}"
				fPath="$fCopy"
				fBase="$(basename "$fPath")"
				#DELETE_BEGIN#   # Delete the following script part when compressing the script
				_fn=$dCache/$fBase.$(date +%M)
				cp -Lpr "$fPath" $_fn &&
					sed '/[ \t]#DELETE_BEGIN#/,/[ \t]#DELETE_END#/d' -i $_fn &&
					# -e 's,"yes",y,g'
					sed -e 's/^[ \t]*//' -e 's/\(^[ \t]*\| \+\)#\($\|#*[\t ]\+[^"].*$\)//g' -e 's/() *{/(){/' -e 's/[\t ]*\t[\t ]*/\t/g' -e '/^$/d' -e 's/ *; */;/'  -e 's/   *"/ "/g' -e 's/"   */" /g' -e 's,\$( ,$(,g' -e 's, )",)",g'  -e 's,\$(echo ,$(e ,g' -e 's,\t*$,,g' -e 's,^local ,l ,'  -e 's,^echo ,e ,'  -e 's,\<continue$,c,'  -e 's,\<return\>,r,' -e 's,_msg\>,_m,'  -e 's,\<cMqtt,cM,g'  -i $_fn &&
					#      ^Whitespace      WhiteSpace # Comment                          () *{            Whitesp tab Whitespace        emptyline   WS around ;     WS bef Dou Qts  WS after DblQts  spaceAfter$(     spaceBefore)"    echo to e after $(     tab at eol      local to alias l      echo to e         continue to c            return to r         suffix _msg to _m  command with cMqtt...
						cp -p $_fn /tmp &&
							sed -E -i $_fn  -e 's,[ \t]*(&&|;|>|>>|\|)[ \t]*,\1,g' -e '/awk|printf|test|:/!s,"([a-z0-9/-][a-z0-9/._-]+)",\1,g' && #  -e 's,[^\)]\) [^a-zA-Z],),g'  &&
						#             white space around && or ; or | , but not << or <    strings > 1c in double quotes   #FRAGILE
						bash -x -n $_fn && cCmv ash && ash -x -n $_fn # smoke test the syntax of compressed script
				_rc=$?
				dbg $cmd "$fPath ($( wc -c < $fPath )) trimmed to $_fn ($( wc -c < $_fn )) : rc=$_rc" # && cp $_fn /tmp/$(basename $_fn).$(date +%M)
				[ $_rc != 0 ] && cErrAndExit "Reducing script $_fn returned error $_rc!"
				{ cp -p $_fn $_fn.save ; cp -p $_fn $dCache/$fBase.last ;} # 2>$fNul
				fPath=$_fn
				#DELETE_END#
				if _t="/sbin/$fBase" ; scp -p ${bQuiet:+-q} "$fPath" "$sSshUser:$_t" ; then
					_msg="$fPath copied to $_t"
					cMR OK "path=$_t"
				elif _t="/tmp/$fBase" ; scp -p "$fPath" "$sSshUser:$_t" && cSsh "rm /sbin/$fBase ; ln -s $_t /sbin" ; then
					_msg="$fPath copied to /tmp and linked to /sbin"
					cMR OK "path=$_t"
				else
					_msg="scp $fPath to /sbin or /tmp both failed."
					cMR ERROR "$_msg"
				fi
				dbg FILECOPY "$_msg"			
				cSsh "$fBase -m localhost,$hPubMqtt -c echo+FILECOPY ; sleep 1 ; [ -r .config/$MP ] && $fBase -c echo+FILECOPY" 2>$fNul & # dont wait for this...
				sleep 1
				#DELETE_BEGIN#
				rm $_fn
				#DELETE_END#
				;;
			sh)
				cProbeNOMQTT
				for i in $(seq "${cmdopts:-1}") ; do
					cMR ONGOING "Trying shell (i=$i)"
					ssh $sSshUser && break
					sleep 5
				done ;;
			homie-update|discovery-update)
				cProbeGET
				_cmd="cat /proc/uptime"
				homieuptime="$( [ "$hFull" = localhost ] && $_cmd || $0 -h "$hFull" "$_cmd"  )" && hLine "\$stats/uptime" "$(e "$homieuptime" | cut -d. -f1 )"
				cmdsToDo="localclients,wifistatus,gluondata,machine-data,$cmdsToDo"
				;;
			homie-delete|discovery-delete)
				cProbeSET
				homie="$(cLower $hTarget)" # duplicated code...
				announce_disco "$homie" -d
				;;
			wifidown) # stop Freifunk public interface
				cProbeSET
				cGetPubIF # also sets sPubIfs and sSsidBase
				dbg PREPARING "$cmd on host $hTarget (if=$sPubIf0,$sPubIf1) ..."
				cSsh "{ iw dev $sPubIf0 del ${sPubIf1:+; iw dev $sPubIf1 del >$fNul} ;} 2>&1"
				_tmp="$(cOut|xargs)"

				if [ $ssh_rc -eq 237 -o $ssh_rc -eq 1 ] ; then
					cMR OK "$_tmp (_rc=$ssh_rc)"
					hLine publicwifi/clientscount 0 && _tmp=""
				elif [ -z "$_tmp" -a $ssh_rc != 0 ] ; then
					cMR ERROR "tempstr=$_tmp:"
					hLine publicwifi/clientscount 0 && _tmp=""
				else
					cMR OK "tempstr=$_tmp"
				fi
				dbg wifidown "Now starting wifistatus"
				cmdsToDo="wifistatus${cmdsToDo:+,$cmdsToDo}"
				;;
			wifiup|wifistatus|ffup|ffstatus) ## determine status of open/guest wifi network, n.b. ff... are being obsoleted
				cProbeGET
				cGetPubIF || { cMR ERROR "public interfaces undeterminable:" ; continue ;} 
				dbg PREPARING "$cmd on host $hTarget (if=$sPubIfs) ..."
				_scmd="command -v iw >$fNul 2>&1 && iw $sPubIf0 info || uci show wireless.client_radio0.ssid || uci show wireless.ap_gn_g.ssid" # .. fallback to uci-setting ... and ignoring any 2nd interface for now
				ssh_data=""
				if [ $cmd = wifiup ] ; then
					cProbeSET
					cMR ONGOING "Running $_scmd"
					cSsh "wifi up && sleep $nWifiSleep && $_scmd"
				elif [ "$sNewSSID" ] ; then
					ssh_rc=0
					dbg REUSED "sNewSSID=$sNewSSID"
				else
					cMR ONGOING "Running $_scmd"
					cSsh "$_scmd"
				fi
				ssh_data="$(cOut|tail -14)" # shorten away the long redundant error msg from stdout from iw
				if [ -z "$sNewSSID" ] ; then # ... was cached or if not cached, not unreachable
					# set -x
					sNewSSID="$(cOut|sed -n -e '/\.ssid=/{s/.*=//;p;q}' -e '/ssid/{s/\tssid //;p;q}')" # coerced uci and iw output to get results # for iwinfo: -e '/ESSID:/{s/[^:]*: //;s/\"//g;p;q}' 
					if [ $ssh_rc = 0 ] && [ "${ssh_data#"Interface $sPubIf0"}" != "${ssh_data}" -o "${ssh_data#wlan}" != "${ssh_data}" ] ; then
						dbg SUCCESS "tempstr=$ssh_data"
						# cEcho "$sNewSSID"
						sChannel24="$(cOut|awk '$1=="channel" {print $2}' )" # works for iw
						cMS 	/publicwifi/state	ON
						hLine	publicwifi/state	true
						cBothMqtt 	radio/channel24 	"$sChannel24"
						# cMS 	/radio/channel24 	"$sChannel24"
						# hLine	radio/channel24	"$sChannel24"
					else
						if [ "$ssh_data" ] ; then
							dbg "command=$cmd, rc=$ssh_rc, ssh_data=$ssh_data"
							if [ $ssh_rc = 255 ] || cOut | grep -w -q -E "open failed|connect failed" ; then # unreachable
								cMR OFF "rc=$ssh_rc ($ssh_msg)"
								( sleep 60 ; echo PERIODIC noop "sooner" )  > $fPipe & # inject for sooner retry
							elif [ "${ssh_data#"$sPubIf0"}" = "${ssh_data}" ] ; then
								cMR OFF "rc=$ssh_rc (interface missing or down)"
							else
								cMR ERROR "rc=$ssh_rc // $(cOut|xargs)"
							fi
						fi
						cMS 	/publicwifi/state	OFF
						hLine	publicwifi/state	false
						# cEchoPub publicwifi/clientscount 0
						cBothMqtt 	publicwifi/clientscount 0
						# cMS 	/publicwifi/clientscount 0
						# hLine	publicwifi/clientscount 0
					fi
				fi
				if [ "$sNewSSID" ] ; then
					cEcho "$sNewSSID"
					_ssid="$( printf %s "$sNewSSID" | sed -e 's,.*/,,' -e 's/"//g'  )"
					cMR OK "$sNewSSID"
					cBothMqtt publicwifi/ssidshort "$_ssid"
					# cMS		/publicwifi/ssidshort "$_ssid"
					# hLine	publicwifi/ssidshort "$_ssid"
					cBothMqtt publicwifi/ssid "$sNewSSID"
					# cMS 	/publicwifi/ssid "$sNewSSID"
					# hLine	publicwifi/ssid "$sNewSSID"
					sNewSSID="" # delete cached SSID
				else	
					cMR ERROR "SSID is empty:"
				fi
				;;
			ffcond)
				continue # FIXME
				cProbeGET
				cGetPubIF || { cMR ERROR "public interfaces undeterminable:" ; continue ;} # also sets sPubIfs and sSsidBase
				cSsh '{ for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | tee $dCache/wifis ; echo ++++++++++++ ; iwinfo | grep sPubIf0'
				ifresult="$(cOut|grep -A 3 '++++++++++' | grep -m 2 "client0 *ESSID:" )"
				cErrAndExit "UNFINISHED CODE" # FIXME
				if cOut|grep -A 9 -w '6e:a3:09:ea:31:e00' | grep -w "SSID:.$sSsidBase"
				then
					# client0   ESSID: "muenchen.freifunk.net/welt"
					cEcho "To be upped..."
					[ -z "$ifresult" ] && cmdsToDo="wifiup${cmdsToDo:+,$cmdsToDo}"
				else	
					cEcho "To be downed..."
					[ "$ifresult" ] && cmdsToDo="wifidown${cmdsToDo:+,$cmdsToDo}"
				fi
				dbg cmdsToDo "$cmdsToDo"
				# ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )	) || ( iwinfo | fgrep client0 && iw dev client0 del ; echo if downed )
				;;
			ffchannel24|ffchannel24-*|channel24|channel24-*|radiochannel24set)   # FIXME: only implemented for 2.4Ghz (=first) radio
				cProbeGET
				cGetPubIF 0 # sets sPubIfs, sSsidBase, and channel
				_val="$cmdopts"
				[ "$_val" ] || _val=$cmd
				_val="${_val#ffchannel24-}"	&& _val="${_val#ffchannel24}"
				_val="${_val#channel24-}"	&& _val="${_val#channel24}"
				cmd="channel24"
				if [ "$_val" ] ; then
					if [ "$(e "$_val" | cTrd "[0-9]" )" ] || [ "$_val" -lt 1 -o "$_val" -gt 13 ] ; then
						cMR ERROR "Illegal channel: $_val"
						continue
					else
						_r0=wireless.radio0.channel
						cMR ONGOING "Setting $_r0=$_val (if=$sPubIf0,$sPubIf1)"
						cSsh "uci set $_r0=$_val && wifi up && sleep $nWifiSleep && iwinfo $sPubIf0 info | grep -wi channel 2>&1" # FIXME: ignoring any 2nd interface # iwinfo $sPubIf0 info
						dbg "_result=****$ssh_data****"
					fi
				fi
				cmdsToDo="wifistatus${cmdsToDo:+,$cmdsToDo}" # ... implicitly followed by a wifistatus
				# FIXME: more code to be added
				# ...
				;;
			limit|limit-*)
				cProbeSET
				_tmp="$cmdopts"
				[ "$_tmp" ] || _tmp=$cmd
				_tmp=$(e "${_tmp#limit-}" | cTrd -c 0-9) # for security reasons
				cmd="limit"
				# cErrAndExit "UNIMPLEMENTED"  # FIXME
				if [ $_tmp -lt 50 -a $_tmp -ne 0 ] ; then
					cMR ERROR "Illegal limit: $_tmp"
					continue
				fi
				cMR ONGOING "Setting gluon.mesh_vpn.limit_*gress=$_tmp"
				cSsh "uci set gluon.mesh_vpn.limit_ingress=$_tmp && uci set gluon.mesh_vpn.limit_egress=$_tmp && gluon-reconfigure 2>&1" # FIXME: ignoring any 2nd interface # iwinfo $sPubIf0 info
				dbg "_result=****$ssh_data****"
				# FIXME: more code to be added
				# ...
				;;
			wifissid|wifissid_*|wifissid-*)
				# dbg "cmd=$cmd,cmdopts=$cmdopts"
				cProbeGET
				cGetPubIF # sets sPubIfs and sSsidBase
				# _tmp="${cmdopts:-welt}"
				_tmp="${cmd#wifissid_}"
				_tmp="${_tmp#wifissid-}"
				_tmp="${_tmp#wifissid}"
				_tmp="${_tmp:-$cmdopts}"
				# [ -z "$_tmp" ] && cEcho "Empty shortssid from cmd=$cmd ($cmdopts), using 'welt'"
				_ssid="$(e "${_tmp:-welt}" | cTrd '}{)( ,=' )"
				dbg _ssid "$_ssid"
				cmd="wifissid"
				# further checks for allowed and legal  SSID values amongst gluon domains ....
				if [ "$_ssid" = OFFLINE -o "$_ssid" = MYHOSTNAME -o "$_ssid" = %s ] || expr "$(cGetGluonDomainsStarred $hTarget)" : ".*\*${_ssid}[*]" >$fNul ; then
					cMR ONGOING "Intended SSID suffix: $_ssid"
					otherssid="$sSsidBase/$_ssid"
					dbg INTENDEDSSID "$otherssid"
				else
					cMR ERROR "Illegal shortssid: $_ssid"
					cMS /gluondata/gluon-domains "$(cGetGluonDomainsStarred $hTarget)"
					cEcho "Illegal shortssid: $_ssid"
					continue
				fi
				# echo ================
				cSsh ": set -x &&
						_hn=\"\$(tr A-Z a-z <$fHost)\" &&
						other=\"\$( printf %s \"$otherssid\" | sed -e \"s/MYHOSTNAME/\$_hn/\" -e \"s/%s/\$_hn/\" )\"  &&
						otheresc=\"\$( ec\"ho\" \"\$other\" | sed -e 's,/,\\\\/,' )\"  &&
						iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/'  -e '1q' | awk \"{print} /\$otheresc/ { exit(99) }\" &&
						uci set wireless.client_radio0.ssid=\$other ${sPubIf1:+&& uci set wireless.client_radio1.ssid=\$other} &&
				        wifi up && sleep $nWifiSleep ;
						iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDNEW/' -e '1q' " # FIXME: ignoring any 2nd interface
				# echo ----------------
				dbg RESULT "=***$ssh_data***"

				if [ -z "$ssh_data" ] ; then
					_log="error: $ssh_rc ($ssh_msg) OR ssh data empty, aborting command $cmd..."
					cEcho "$_log"
					cMR ERROR "$_log"
				else
					prev_ssid="$(cOut|grep -m 1 SSIDPREV: | cut -d: -f2 | xargs)"
					sNewSSID="$(cOut|grep -m 1 SSIDNEW:  | cut -d: -f2 | xargs)"
					_log="previous=$prev_ssid, new=$sNewSSID"
					if [ "$prev_ssid" = "$sNewSSID" ] ; then
						_log="$_log (no change)"
					else
						sNewSSID=""
					fi
					dbg "$_log"
					cMR OK "$_log"
					cmdsToDo="wifistatus${cmdsToDo:+,$cmdsToDo}" # ... implicitly followed by a wifistatus
				fi
				;;
			gluonreconfigure)
				cProbeSET
				cGetPubIF # sets sPubIf* and sSsidBase
				cMR	ONGOING "Affected Interface(s): $sPubIfs"
				# 6 seconds needed for interface!
				cSsh "iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' ; gluon-reconfigure | tail -3 ; wifi up  ; sleep $nWifiSleep ; iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDNEW/' -e '1q' "
				dbg $cmd "$ssh_data"
				prev_ssid="$(cOut	|grep SSIDPREV	| cut -d: -f2 )"
				new_ssid="$( cOut	|grep SSIDNEW	| cut -d: -f2 )"
				cEcho "$hTarget: Ran gluon-reconfigure, previously $prev_ssid, then wifi up, then $new_ssid. id=$(id -nu)/$(id -u)\n"
				if [ "$prev_ssid" != "$new_ssid" ] ; then
					cmdsToDo="localclients${cmdsToDo:+,$cmdsToDo}"
				fi
				cmdsToDo="wifistatus${cmdsToDo:+,$cmdsToDo}" # ... implicitly followed by a wifistatus
				;;
			site)
				cProbeGET
				cGetSitecode FRESH
				[ "$sSite" ] && { cmd=gluondata cEchoPub site $sSite; true ;}|| { sSite=UNKNOWN ; cMR ERROR ;}
				;;
			gluondata)
			  os_data="$(cGetOSData)"
			  if [ -z "$os_data" ] ; then
			  	cMR ERROR "Empty OS data"
			  else
			    # get all infos in one call (line by line):
				cSsh "{ uci get autoupdater.settings.branch && uci get autoupdater.settings.enabled && uci get gluon.core.domain ;
					lua -e 'print(require(\"platform_info\").get_model())' ; cat $dGluon/gluon-version ; cat $dGluon/release ;} 2>&1"
	
				cEchoPub os-data "$os_data"	
				cEchoPub autoupdater-branch 	"$(cOut|sed -n 1p)"
				cEchoPub autoupdater-enabled	"$(cOut|sed -n -e 2s/0/false/ -e 2s/1/true/ -e 2p)"
				cEchoPub core-domain	"$(cOut|sed -n 3p)"
				cEchoPub model	"$(cOut|sed -n 4p)"
				cEchoPub gluon-version	"$(cOut|sed -n 5p)"				
				cEchoPub release	"$(cOut|sed -n 6p )" "$(cOut|sed -n -e 's/^v//' -e 6p)"
				cEchoPub gluon-domains	"$(cGetGluonDomainsStarred $hTarget)"
				cEchoPub site $sSite
			  	cMR OK
			  fi
			  ;;
			machine-data)
				os_data="$(cGetOSData)"
				dbg os_data "$os_data"
				cSsh "command -v $MP || echo no ; cat /proc/version /proc/cpuinfo"
				_data="$(cOut|awk -v os_data="$os_data" '
					NR==1 { mpub=$1 }
					NR==2 { lxversion=$3 ; FS=": " }
					/^machine|^Hardware/ { FS=": " ; printf "{*mosquitto*:*%s*,*linuxversion*:*%s*,*machine*:*%s*,%s}", mpub, lxversion, $2, substr(os_data,2,length(os_data)-2) ; exit 0 }
					' )"
				if [ "$_data" ] ; then
					cEcho "$(cStarredToJSON "$_data")"
					cMS /$cmd "$_data"
				else
					cMR ERROR "$cmd failed: no output"
				fi
				;;
			speedtest|speedtest0*)
				cProbeGET
				_spparam="${bVerbose:+-q}" ; _spparam="-q --no-check-certificate"
				sLastSpeed="$(cCRead $hTarget.lastspd 1)" && sLastSpeed=",*lastSpeedMb*:$sLastSpeed"
				_spcmd="$(cCRead $hTarget.lastspdcmd 2)" # prefer the previous one for at most 2 days
				[ -z "$_spcmd" -o $cmd = "speedtest0" -o $cmd != "${cmd#"$_spcmd"}" ] && _spcmd=$cmd # make it at least as big as the previous max (cache will time out after 2 days anyway):
				case "$_spcmd" in
					speedtest)	_url=1MB	;;
					speedtest0)	_url=5MB	;;
					speedtest00)	_url=10MB	;;
					speedtest000)	_url=50MB	;;
					speedtest0000)	_url=100MB	;;
					speedtest00000)	_url=1GB	;;
					*)				cErr "speedtestcmd '$_spcmd' too excessive or fetching failed!"
									cMR ERROR "Last result ${_val}s or file size ${filesize}B too small"
									cCWrite .lastspdcmd speedtest0
									continue
				esac
				_url="http://speedtest.tele2.net/$_url.zip" ; 
				# _url="http://ipv6.download.thinkbroadband.com:8080/$_url.zip"
				# dbg SPEEDTEST "$_url ..."
				cMR ONGOING "Trying $_url"
				cSsh "date -u +%s; wget $_spparam -O - $_url | wc -c ; date -u +%s"
				if [ $ssh_rc = 0 ] ; then
					starttime="$(cOut|sed -n 1p)"
					filesize="$(cOut|sed -n 2p)"
					endtime="$(	cOut|sed -n 3p)"
					_val="$((endtime - starttime))"
					speedMB="$( awk "BEGIN { printf \"%.1f\" , $filesize*8 / ($_val+0.000001) / 1048576}" )"
					if [ "$filesize" -lt 10000 ] ; then
						dbg "File size ${filesize}B for $_url too small, will abort."
						_spcmd="speedtest000000" # head for abort
						cmdsToDo="${_spcmd}${cmdsToDo:+,$cmdsToDo}"
					elif [ "$_val" -lt 11 ] ; then
						_spcmd="${_spcmd}0" # try next bigger size
						_s="Result ${_val}s too small for file size ${filesize}B"
						dbg "$_s, redo with $_spcmd"
						cMR ONGOING "$_s. Retrying larger file." "*speedMb*:*$speedMB*"
						cCWrite .lastspdcmd "$_spcmd" # cache bigger file speedtest for next time
						cmdsToDo="${_spcmd}${cmdsToDo:+,$cmdsToDo}"
					else
						cEcho "$speedMB"
						cMS /speedtest "{*speedMb*:$speedMB,*filesize*:$filesize,*elapsedtime*:$_val,*unit*:*Mb/s*${sLastSpeed}}"
						cCWrite .lastspd "$speedMB"
					fi
				else
					cEcho "ERROR: $ssh_rc"
					cMR ERROR "{*ERROR*:*$ssh_rc*,*url*:*$_url*${sLastSpeed}}"
				fi
				;;
			status)
				cSsh "cat /proc/uptime /proc/loadavg"
				_data="$(cOut|awk '
					NR==1 { uptime=sprintf("%d", $1) }
					NR==2 { printf "{*uptime*:%s,*load*:%.2f}", uptime ,$1 }' )" # uptime in seconds
				cEcho
				cMS /$cmd "$_data"
				;;
			printmap)
				cProbeGET
				cSsh "print_map.sh" || continue # Freifunk node info as JSON for non-Gluon systems, e.g. from Ulm
				cOut|json_pp
				cMS /$cmd "$ssh_data"
				;;
			localclients)
				cProbeGET
				fCollection=$dTmp/clientcollection
				touch $fCollection && chmod g+w $fCollection
				fClients=$fCollection.$hTarget
				[ -r $fMacIDs ] || touch $fMacIDs

				cSsh "batctl tl"
				if [ $ssh_rc != 0 ] ;  then
					_msg="Connection $sSshUser failed:"
					cErr "$_msg"
				  	cMR ERROR "$_msg"
				else
					cOut|awk '$3=="[....W.]" {printf "%s\n", $1}' | sort > $fClients
				
					awk "{ print strftime(\"%Y-%m-%d_%H:%M:%S \") \$0 \" $hTarget\" ; fflush() ; next }" $fClients >> $fCollection
					dbg "***" " fCollection=$fCollection ***" && cat $fCollection
					
					dbg "**1" " fClients=$fClients ***" && cat "$fClients"

					if cCmv join && [ -r $fMacIDs ] ; then  # prerequisites to join the data to a list of named clients...
						{ sort -k 1 "$fClients" | join -1 1 -2 1 -a 1 - $fMacIDs | sort | uniq -w 17 > "$fClients"_with_names ;} &&
								mv "$fClients"_with_names "$fClients"
						dbg "**2" " fClients=$fClients ****" && cat "$fClients"
					fi

					_n=$(wc -l <$fClients)
					hLine publicwifi/clientscount $_n
					# cp -p $fClients $dCache/xx
					_data="$( tr " " "," < "$fClients" |
						awk -F, -v lccount="$_n" -v hname=$hTarget 'BEGIN { printf "{*count*:%s,*localclients*:[", lccount } { printf lim "{*addr*:*%s*,*name*:*%s*,*detail*:*%s*}", $1, ($2=="") ? $1 : $2, gensub(/ *$/, "", 1, $3 " " $4 " " $5) ; lim="," } END { printf "],*host*:*%s*}",hname }' |
						  shorten_ethernet_addr_in_json ${bDoAll:+skip} )"
					while read -r _addr _what _who ; do
						dbg IP "*$_addr* *$_what* *$_who*"
						_addr="$(e "$_addr" | cTrd ":" )"
						_details="$_what${_who:+ $_who}" && [ "$_details" ] || _details="$_addr"
						cMS "$sSite/$sArea/$_addr" "{*lasthost*:*$hTarget*,*mac*:*$_addr*,*details*:*$_details*,*vendor*:*$(cGetMacVendor "$_addr")*}"
					done <"$fClients" 
					cEcho "$(cStarredToJSON "$_data" | json_pp)"
					cMS /publicwifi/localclients "$_data"
					[ "$bWorkAllClients" ] && nAllClients="$(( nAllClients + _n ))"
					collectedclients="$collectedclients $(xargs <$fClients)"
					collectedclients="${collectedclients% }" # trim any leading spaces
				fi
				;;
			nodeinfo|neighbours|statistics)
				# [ ! -d "$dGluon" ] && dbg "Not on Gluon: Skipping cmd $cmd on host $hTarget" && continue
				ssh_rc=0
				ffnodeip="$(cCRead $hTarget.nodeip 30)"
				[ -z "$ffnodeip" ] && ffnodeip="::1" # localhost, better than next line
				# [ -z "$ffnodeip" ] && cSsh "if [ -d $dGluon ] ; then ip -f inet6 -o addr show dev $ifipv6 ; else echo NONGLUON ; fi" && ffnodeip="$(cOut|awk -e '{gsub("/.*","",$4) ; print $4?$4:$1 ; exit 0}' )"
				if [ $ssh_rc = 1 -o "$ffnodeip" = NONGLUON ] ; then
					cErr "Command $cmd aborted, output: $ffnodeip:"
				  	cMR ERROR "Remote node IP undeterminable ($ffnodeip):"
					[ $ssh_rc = 1 ] && cCWrite .nodeip NONGLUON
					continue
				elif [ $ssh_rc != 0 ] ; then
					cErr "Remote node IP :$ffnodeip: empty. Cmd $cmd aborted...:"
				  	cMR ERROR "IP of remote node undeterminable ($ffnodeip):"
					continue
				fi
				cCWrite .nodeip "$ffnodeip" # cache the value
				_cGNI="gluon-neighbour-info -i br-client -p 1001 -r $cmd -d " # ipaddr will be appended ...
				[ "$one_additional_option" ] && hFull="$one_additional_option" # use other host to query the remote one ...
				cSsh "$_cGNI $ffnodeip"
				_val="$ssh_data"
				dbg $cmd "Had called $_cGNI $ffnodeip (rc=$ssh_rc,size=${#ssh_data})"
				if [ ${#ssh_data} -le 1 ]  ;  then
					cErr "Connection or gluon-neighbour-info failed: Command $cmd on node ip $ffnodeip failed:"
					cMR ERROR "result empty (ssh_data=$ssh_data):"
				else
					printf %s "$ssh_data" >$fTmpMqtt
					cCWrite .$cmd "$ssh_data" # cache the whole data to support change detection in the future
					cEcho
					cMqtt "/$cmd" "$ssh_data"
					if [ $cmd = statistics ] ; then
						# node_id=$( jq -r .node_id $fTmpMqtt )
						# cMqtt /nodeid "$node_id" "-r"
						### cMqtt "$sSite/$node_id/$cmd"  "$(cat $fTmpMqtt)"  "-r"
						# cMqtt /ipv6 "$ffnodeip" "-r"
						### cMqtt "$sSite/$node_id/ipv6"      "$ffnodeip" "-r"
						_data="$(jsonfilter_func .clients.wifi < $fTmpMqtt)"
						# echo $ssh_data
						#		cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi RX bytes"   "value_json.traffic.rx" "counter"
						# 		cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi TX bytes"   "value_json.traffic.tx" "counter"
						cMS /clients "$_data"
						[ "$bWorkAllClients" ] && nAllClients="$(( nAllClients + _data ))"
						# cMqtt "$sSite/$node_id/clients" "$_data"
					fi
					# [ -f $tmpfilejson      ] && mv -f $tmpfilejson $tmpfilejson.prev
					# json_pp < "$fTmpMqtt" > $tmpfilejson
					# chmod g+w $tmpfilejson
				fi
				;;
			showsite|addresses)
				cProbeGET
				_scmd=gluon-show-site ; 	[ $cmd = addresses ] && _scmd="ip -6 -j addr show"
				if cSsh $_scmd ; then
					cMqtt "/$cmd" "$ssh_data"
					[ "$bQuiet" ] || printf %s "$ssh_data" | json_pp
				else
					cMR ERROR "$cmd failed:"
					cErr :
				fi
				;;
			memory)
				cProbeGET
				if cSsh 'free -t | tr -d -c "0-9 a-zA-Z:\n"' ; then
					cEcho
					# cStarredToJSON "$(cOut|cTableToJSON 1)" | json_pp
					cMS /$cmd "$(cOut|cTableToJSON 1)"
				else
					cMR ERROR "$cmd failed:"
					cErr :
				fi
				;;
			mountsizes|mountsizes_prev)
				cProbeGET
				[ $cmd != "mountsizes_prev" ] && cSsh "df -PhT" # little workaround to have before/after datas when using "install"
				cmd="mountsizes"
				if [ $ssh_rc -ne 0 ] ; then
					cMR ERROR "$cmd failed:"
					cErr :
				else
#				elif cCmv jq ; then		
					cEcho
					_data="$(e "$ssh_data" | sed -e 's/\([0-9]\)\.0K/\1K/g' | grep -E '^/|overlay' | awk 'BEGIN{print"["} END{print"]"} { print lim "{*mountpoint*:*" $7 "*,*type*:*"$2"*,*filesystem*:*"$1"*,*spaceavail*:*"$5"*,*spaceused*:*"$4"*,*percentused*:*"$6 "*,*spacetotal*:*" $3 "*}" ; lim="," }' )"
#					_data="$(e "$_data" | jq -R -s '
#						[ split("\n") | .[]  |
#						if test("^/") or test("overlay") then
#							gsub(" +"; " ") | split(" ") | {mountpoint:.[6], filesystem:.[0], type:.[1], spaceavail:.[4], spaceused:.[3], percentused:.[5], spacetotal:.[2]}
#						else empty end ]' )"
					cMqtt "${sSite:-UNSET}/$hTarget/$cmd" "$(cStarredToJSON "$_data")"
#				else	
#					_l="jq missing"
#					cMR ERROR "$_l"
#					cErr "$_l for $cmd"
				fi
				;;
			jsonify)
				cProbeNOMQTT
				cMS /$cmd "$(cTableToJSON)" # transforms stdin to JSON table consuming header line and column leads (see "momory" above)
				;;
			reboot)
				cProbeSET
				cMR ONGOING "Will $cmd($cmdopts)."
				_key="gluon-setup-mode.@setup_mode[0].enabled"
				[ "$cmdopts" = config ] && _more="uci set $_key=1 && uci commit &&" || _more="" # reboot to config mode on next boot
				if cSsh "uci show $_key && $_more $cmd"  ; then
					dbg $cmd "$(cOut)"
					cMR OK # might not even get here if run locally ...
				else
					cErr :
					cMR ERROR "$cmd: failed:"
				fi
				;;
			debug_msub) # FIXME: remove this after explore mosquitto_sub stalling bug
				# for i in $(seq 20) ; do  $MP -t ffmuc/jupiter/echo/get -m $i ; echo $i ; sleep 0 ; done
				if [ "$cmdopts" = s ] ; then
					# cMqttSub -t $sSite/\# -v -R | { set +x ; while true ; do read -r x ; echo "// $x" ; sleep 1 ; done } # create a stalling pipe
					cMqttSub -t $sSite/\# -v -R | awk -v f="$fPipe" '{ print "//" $0 ; system("sleep 1") }' 
					exit 0
				else
					for i in $(seq "${cmdopts:-5}") ; do 
						# cMqtt /wifistatus/get $i
						# cMqtt /status/get $i 
						cMqtt /date/get $i 
						cEcho $i
					done
				fi
				exit 0
				;;
			checkprocs) # explore number of process started in pipe
				cProbeNOMQTT
				_n=20
				_d=$(cPid)
				for i in $(seq $_n) ; do
					# echo %s $i | awk '{print}'
					# echo %s $i | awk '{print}'
					# history | awk '{print}' > $fNul
					# cat $fNul | cat | awk '{print}'
					# date | awk '{print}'
					printf y
				done
				dbg $cmd "$(awk "BEGIN {print ( $(cPid) - $_d - 4) / $_n }" )" # number of processes started for one command in the for loop above
				;;
			wifiscan)
				cProbeNOMQTT
				# relies on the following entry in root's crontab, since only root is allowed to do a full wifi scan
				# SHELL=/bin/bash
				# * * * * * { /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ;} | fgrep SSID  | cut -d: -f 2 | xargs -n 1 | sort -u > /tmp/wifis.txt
				# { for i in 2 2 2 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | fgrep SSID  | cut -d: -f 2 | xargs -n 1 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt
				# * * * * * { for i in 1 2 1 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | egrep -w '^BSS|SSID'| sed -e 's/BSS *//' -e 's/(.*//' -e 's/\t*SSID: //' -e 's/^$/./' | xargs -L2 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt

				cGetPubIF # sets sPubIf* and sSsidBase

				cSsh "[ \"$(id -u)\" = 0 ] || echo ERROR && iw dev $sPubIf0 scan ${sPubIf1:+&& iw dev $sPubIf1 scan}"
				_data="$ssh_data"
				if [ $ssh_rc = 0 ] ; then
					# _data="$(e "$_data" | awk '$1 ~ /^SSID/ { sub("\t*SSID: *", "") ; if (length($0)) print } {next}' | sort -u | cWordsToJsonArry)"
					_data="$(e "$_data" | awk '
							/^BSS / 	{ MAC 	= gensub("(.*", "", 1, $2) }
							/signal:/  	{ signal[MAC] 	= gensub(".00", "", 1, $2) }
							/SSID:/  	{ ssid[MAC] 	= $2 }
							/primary channel:/ { channel[MAC] = $NF }
							END {
								printf "%s\t%s\t%s\t%s\n", "MAC", "signal", "channel", "SSID"
								for (mac in ssid) { printf "%s\t%s\t%s\t%s\n", mac, signal[mac], channel[mac], ssid[mac] }
							} ' )"
					cEcho "$_data"
					cMS /$cmd "$_data"
					# cMR OK "$_data"
				else
					cEcho "ssh command $cmd failed (rc=$ssh_rc)"
					cMR ERROR "rc=$ssh_rc // $_data"
				fi
				continue

				# FIXME:
				dbg "$sMe: command scandirty grepping for **$sGrepSsid**"
				grep -wi "$sGrepSsid" "$dCache/wifis.txt"
				rm -f "$dCache/wifis.txt.hint"
				# exit 0
				;;
			*)
				_msg="Illegal command=$cmd"
				cEcho "$_msg"
				cProbeSET || cErrAndExit "$_msg"
				cErr "$_msg"
			esac
			[ "$sSite" = UNDET -a "$ssh_rc" = 0 ] && cGetSitecode 0 # retry getting site code if UNDETermined
		done
	fi
	
	if [ $# -gt 0 ]
	then
		# ... everything that's left in "$@" is taken as shell commands, too....
		cSsh "$@"
		cOut
	fi
done

if [ "$nAllClients" -o "$bWorkAllClients" ] ; then
	[ "$bVerbose" -o "$nGiveHost" ] && ECHO "\n######  ALL CLIENTS " "$@" "######" 1>& ${nGiveHost:-1}
	[ "$nAllClients" ] && cMqtt "$sArea/publicwifi/allclientscount" $nAllClients

	if [ "$fCollection" ] ; then
		cSortAndTailFile "$fCollection" 18 1
		dbg fCollection "$fCollection:" && cat "$fCollection"
		if cCmv join && [ -r $fMacIDs ]; then
			_ccwn_fn="${fCollection}_with_names"
			{ sort -k 2 "$fCollection" | join -1 2 -2 1 -a 1 - $fMacIDs | sort -r -k 1 |
			uniq -w 17 | sort -k 2 > "$_ccwn_fn" ;} && dbg "$_ccwn_fn" "\n$(cat "$_ccwn_fn")"
			# echo HELLO
			[ "$bWorkAllClients" ] && cMS "$sSite/$sArea/alllocalclients/debug" "$( { echo addr date node name p ; sort "$_ccwn_fn" ;} | cTableToJSON )"
			mv "$_ccwn_fn" "$fCollection"
		fi
		_data="$( awk -F" " -v id="$sArea" -v lccount=$nCollectedClients 'BEGIN { printf "{*count*:*%s*,*id*:*%s*,*localclients*:[", lccount, id } END {printf "]}"} { printf lim "{*addr*:*%s*,*name*:*%s*}", $1 , ($4=="")? $1 : $4 $5 $6 $7 ; lim="," }' < "$fCollection" |
			shorten_ethernet_addr_in_json ${bDoAll:+skip} )"
		cEcho "$(cStarredToJSON "$_data" | json_pp)"
		cMS "$sSite/$sArea/alllocalclients" "$_data"
	fi
fi

# clean up older stuff...
cd "$dCache" || exit 2
# [ "$bVerbose" ] && ls -alt "$dCache" | head -15
find $dTmp -mindepth 1 -exec mv ${bTrace:+-v} '{}' . \;
rmdir $dTmp
find . -maxdepth 1 -path "./[0-9]*" -type d -mtime +6 -exec rm -r '{}' \; # remove old debug files

# End of main.

# { echo TRUE  ; true  ;} || { echo TRUE  ; true ;} && echo YES ; echo =====
# { echo FALSE ; false ;} || { echo TRUE  ; true ;} && echo YES ; echo =====
# { echo TRUE  ; true ;} || { echo FALSE ; false ;} && echo YES ; echo =====
# { echo FALSE ; false ;} || { echo FALSE ; false ;} && echo YES ; echo =========
# { echo TRUE  ; true  ;} || { echo TRUE  ; true ;} || echo YES ; echo =====
# { echo FALSE ; false ;} || { echo TRUE  ; true ;} || echo YES ; echo =====
# { echo TRUE  ; true ;} || { echo FALSE ; false ;} || echo YES ; echo =====
# { echo FALSE ; false ;} || { echo FALSE ; false ;} || echo YES ; echo =====
# exit