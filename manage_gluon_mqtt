#!/usr/bin/env ash
# shellcheck shell=ash

#
# manage_gluon_mqtt
#
# Monitor and control Freifunk nodes (Gluon) by MQTT
#
# Repo: https://github.com/sheilbronn/Manage-Gluon-MQTT
#

### Some fixed parameters and prelimenary (fixed) settings ....

wifiupsleep="7" # seconds to sleep after "wifi up"
uci_opt_ssid1="wireless.wan_radio0"
ff_if_pub1="client0"
ff_if_priv1="wlan0-1"
ff_if_pub2="wlan0-1"
ff_if_priv2="wlan0-2"
macidsfile="/srv/openhab2-conf/phones" # file is not necessary for the beginning

set -o noglob  # "noglob"" will limit security and escaping problems:
scriptname="${0##*/}"
userconfigdir="$HOME/.${scriptname%.sh}"
areaid="$( { cat /proc/sys/kernel/hostname 2>/dev/null || hostname || echo "unknown" ; } )"
[ "$areaid" = "openHABianPi" -o "$areaid" = "unknown" ] && areaid="${areaid}-$( awk -F ":" -e '{ print $5$6 }' < /sys/class/net/eth0/address )"
areaid="$( echo "$areaid" | awk -- '{ print tolower($0) }' )" # lowercase only

# ssid_len=9
ifipv6="bat0"
ffssid=".*"
uci_opt_ssid="$uci_opt_ssid1"
ff_if_pub="$ff_if_pub1" # DEFECT: needs to be made specific for each host...
ff_if_priv="$ff_if_priv1"

umask -S u=rwx,g=rx,o= # no rights for others
alias noxxing="local - ; set +x"

# Notes for future enhancements:
# ping Alt-Solln and up/down own public if accordingly
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8ba && echo yes ) || echo no    
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8be && ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )  ) || ( iw dev client0 del ; echo if downed )
# scan repeatedly for Alt-Solln's public Wifi and up/down own public if accordingly:
# ( { for i in 1 1 1 1 2 ; do iw dev mesh0 scan ; sleep $i ; done } | fgrep -w '6e:a3:09:ea:31:e1' && ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )  ) || ( iw dev client0 del ; echo if downed )
# ( { for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | egrep -A 9 -w '6e:a3:09:ea:31:e0' | grep SSID:.muenchen.freifunk.net/muc_sued && ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )  ) || ( iwinfo | fgrep client0 && iw dev client0 del ; echo if downed )

show_help() {
	cat 1>&2 << EOF
   Usage: $scriptname ... -c command ...
   Execute arbitrary as well as predefined commands on Freifunk routers using uci and other commands. Return values on stdout or MQTT.
   Either, automatic (e.g. key-based) access to the Freifunk node using SSH or local execution is possible.
EOF
}

sort_and_tail_file() {
	noxxing
	local __tmpfile="$tmpdir/tailfile"
	local __fn="$1"
	local __tailcnt=${2:-20}
	local __colno=${3:-1}

	[ -r "$__fn" ] && [ -w "$__fn" ] && sort -k "$(( $__colno + 1 ))" "$__fn" | uniq -f "$__colno" | tail -"$__tailcnt" | sort  -k "$(( $__colno + 1 ))" > $__tmpfile \
		&& cat "$__tmpfile" > "$__fn" && rm -f "$__tmpfile"
	[ "$bVerbose" ] && echo_if_verbose "sort_and_tail_file($1,$2,$3): lines: $( wc -l < "$1" )"
	}

tail_file() {
	local -
	local __tmpfile="$tmpdir/tailfile"
	local __fn="$1"
	local __tailcnt=${2:-20}

	[ -r "$__fn" ] && [ -w "$__fn" ] && tail -"$__tailcnt" "$__fn" > $__tmpfile && cat "$__tmpfile" > "$__fn" && rm -f "$__tmpfile"	
	}

exec_locally() { # tried to avoid cost of running "sh -c", no success so far
		sh -c "$1"
	}
extract_uci_values() {
	local __fresult="$( echo "$@" | xargs -r -n 1 | sed 's/.*=//g' )"
	# echo "extract_uci_values returns: <$__fresult>" 1>&2
	echo "$__fresult"
	}

query_uci_on_host() { # query (show) possibly many UCI values from a host and return them all
	local __lines="$( $ssh_cmd "uci show $1" )"s
	# echo "lines: $__lines" 1>&2
	echo "$__lines"
	}

get_uci_on_host() {
	local __lines="$( $ssh_cmd "uci get $1 2>&1 ; ${2:+uci get $2} 2>&1 ; ${3:+uci get $3} 2>&1" )"
	echo "$__lines"
	}

query_and_extract_uci_on_host() { # query the FIRST of possibly many UCI values from a host and return its value
	local __fresult="$($ssh_cmd "uci show $1" | xargs -r -n 1 | sed 's/.*=//g' )"
	# echo "extract_uci_values returns: <$__fresult>" 1>&2
	echo "$__fresult"
	}

get_os_data_semi_starred_cached() {
	local __fresult="$( storage_cache_read "$1.os_data" 1 )"
	local __os_data_fn="/usr/lib/os-release" # standard on Unix by now
	local __os_data=""
	local __os_pretty_name
	local __os_id

	if [ -z "$__fresult" ] ; then
		__os_data="$( $ssh_cmd "cat $__os_data_fn" )" || {	__ret=$? ; return $__ret ; } # cancel func
		if [ -n "$__os_data" ] ; then
			storage_cache_write "$1.os_data_lined" "$__os_data" # keep it for now, dont need it yet
			__fresult="$( echo "$__os_data" | awk -F= 'BEGIN { printf  "{*os*:{" 
				} { printf comma "*" tolower($1) "*:" $2 $3 $4 $5 $6 ; comma="," } END { printf "}}" }' )" # generate new value
			 storage_cache_write "$1.os_data" "$__fresult"  # cache if new values successfulhy obtained
			__os_pretty_name="$( echo "$__os_data" |  awk -F=  '/^PRETTY_NAME=/ { print gensub("\"", "", "g", $2) }' )"
			 storage_cache_write "$1.os_pretty_name" "$__os_pretty_name" 
			__os_name="$( echo "$__os_data" |  awk -F=  '/^NAME=/ { print gensub("\"", "", "g", $2) }' )"
			 storage_cache_write "$1.os_name" "$__os_name" 
			__os_id="$( echo "$__os_data" |  awk -F=  '/^ID=/ { print gensub("\"", "", "g", $2) }' )"
			 storage_cache_write "$1.os_id" "$__os_id" 
		fi
	fi	
	printf "%s" "$__fresult"
	}
storage_write() { # write a key/value pair to a dir 
	noxxing
	if [ -z "$1" ] ; then
		echo "##INVALIDPARAM##"
		error_and_exit "storage_write($1.$4, \"$2\", $3) with ##INVALIDPARAM##"
	else
		mkdir -p "$3" && echo "$2" > "$3/$1.$4"
		echo_if_verbose "storage_write($1.$4, \"$2\", $3) returned $?"
	fi
	}
storage_user_write() {  # write a key/value pair permanently across script invocations 
	storage_write "$1" "$2" "$userconfigdir" "persisted"
	}
storage_cache_write() { # write a key/value pair to be cached across script invocations from the same user
	storage_write "$1" "$2" "$cachedir"      "cached"
	}
storage_read() { # read a key/value pair from cache or user storage
	# noxxing
	local __file="$3/$1.$4"
	local __maxcachedays="${2:-2}"
	local __fresult=""
	local __value=""
	local __deloutput=""

	if [ -z "$1" ] ; then
		__fresult="##INVALIDPARAM##"
		error_and_exit "storage_read($1,...) with $__fresult"
	elif [ ! -r "$__file" ] ; then
		__fresult="##NOTFOUND##"
	else
		[ "$4" = "cached" ] && __deloutput="$( find "$__file" -mtime +"$__maxcachedays" | head -1 | xargs -r -t rm 2>&1 )" # cache invalidated after n days and remove file
		if [ -n "$__deloutput" ] ; then
			__fresult="##NOTFOUND##" # cache is invalid
		else
			__value="$( cat "$__file" )" && __fresult="##FOUND##"  # read value from cache file
			[ "$__value" ] || __fresult="##EMPTY##"
		fi
	fi
	echo_if_verbose "storage_read($1,$2,$3,$4)=\"$__value\" ($__fresult)" 1>&2
	echo "${__value}" # __fresult values are ignored for now
	[ -z "$__value" ] && return 1
	}

storage_cache_read() { # read a key/value pair to be cached across script invocations from the same user; empty cache after n day(s)
	storage_read "$1" "$2" "$cachedir" "cached"
	return $?
	}

storage_user_read() { # read a key/value pair across script invocations
	storage_read "$1" "$2" "$userconfigdir" "persisted"
	return $?
	}

error_and_exit() {
	noxxing
	echo "$scriptname: ERROR: $* ... Exiting." 1>&2
	exit 1
	}

echo_if_not_quiet() {
	noxxing
	[ "$bQuiet" ] || echo "$*"
	}

echo_if_verbose() {
	noxxing
	[ "$bVerbose" ] && echo "$*"
 }

jsonfilter_func() {
	noxxing
 
	if [ "$jsonfilter" = "jsonfilter" ] ; then
		jsonfilter -e "@$1" $2       # $2 is unquoted to avoid complaint when missing
	elif [ "$jsonfilter" = "jq" ] ; then
		jq         -r  "$1" $2 
	else
		error_and_exit "jsonfilter unset"
	fi
}
shorten_ethernet_addr_in_json() { # remove some bytes für anonymization
	[ "$1" = "skip" ] && cat && return 0
	sed -e 's/\([*"][a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]:\)[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]\(:[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9][*"]\)/\1...\2/g' "$@"	
	}

deny_if_mqtt() {
	noxxing
	[ "$commandsToDo" = "mqtt" ] && echo_if_not_quiet "Mqtt $command ignored." && return 0
	return 1
}

publish_to_mqtt() {
	noxxing
	echo_if_verbose "publish_to_mqtt: TOPIC=$1  MSG=$2 ${3:+ OPTIONS=$3}  ($cmd_mospub)"
	if [ "$cmd_mospub" != "true" ] ; then
		 $cmd_mospub $mqtthost -t "$1" -m "$2" $3  || echo_if_verbose "$cmd_mospub failed..." #  $3  passed without quotes on purpose
	fi
	}

publish_to_mqtt_maybe() {
	[ -n "$mqtthost" -o "$homie" ] && publish_to_mqtt "ffmuc/$1" "$2" "$3"
	}

reply_to_mqtt(){
	[ -n "$mqtthost" -o "$homie" ] && publish_to_mqtt_maybe "$command" "$1"
}

reply_to_mqtt_status(){
	[ "$1" ] && [ -n "$mqtthost" -o "$homie" ] && publish_to_mqtt_starred "ffmuc/$sTargetHost/$command/STATUS" "{ *status*:*$1* ${2:+,*details*=*$2* } }"
}

publish_to_mqtt_starred() {
	[ -n "$mqtthost" -o "$homie" ] && publish_to_mqtt       "$1" "$( echo "$2" | tr "*" \" )" "$3"
	}

homie_state_is_ready() {
	tmpfile="$tmpdir/homie_state"
	mosquitto_sub $mqtthost -t "homie/$1/\$state" -C 1 > $tmpfile &
	pid=$! 
	sleep 2
	kill $pid 2>/dev/null
	ret="$( cat $tmpfile )"
	rm $tmpfile
	expr "$ret" "=" "ready"
	}

homie_line() {
		[ "$homie" ] || return
		publish_to_mqtt "homie/$1" "$2"
	}

homie_meta() {
		msg="$3"
		[ "$4" = "-d" ] && msg=""
		publish_to_mqtt "homie/$1/\$$2" "$msg" -r
	}

homie_init() {
	# $sTargetHost must be set!

	# echo homie_init: eins: $1, zwei: $2
	local -
	# set -x
	local homie_init_day="$( storage_cache_read "$sTargetHost.homie_init_day" 9999 )"

	if [ -z "$2" ] ; then
		[ "$sSshUser"="NOUSER" ] && { homie_line "$1/\$stats/uptime" "$( cut -f 1 -d . < /proc/uptime )" ; }
		if [ -n "$homie_init_day" ] && [ $(date "+%j") -eq "$homie_init_day" ] && homie_state_is_ready $1 >/dev/null ; then
			echo_if_verbose "homie_init(): skipping, state is ready..." # announce only if restart or new day or necessary 
			return 0
		fi
		os_data="$( get_os_data_semi_starred_cached "$sTargetHost" 1 )" # refresh data from host if old or no data available
		ad_devname="$( echo "$1" | awk -- '{ print toupper(substr($i,1,1)) substr($i,2) }' )"
		ad_fwname="$( storage_cache_read "$sTargetHost.os_name" 9999 )"
		ad_fwversion="$( storage_cache_read "$sTargetHost.os_pretty_name" 9999 )"
		ad_impl="$( storage_cache_read "$sTargetHost.os_id" 9999 )"
		echo_if_verbose "homie_init($1,$2): announcing with $ad_devname,$ad_fwname,$ad_fwversion,$ad_impl"
	else
		echo_if_verbose "homie_init($1,$2): deleting advertisements"
	fi

		msg="{*device_class*:*illuminance*, *name*: *$ad_devname*, *device*: { *name*:*${ad_devname}*, *model*:*Gluon Freifunk Node*, 
	     *manufacturer*:*Freifunk*, *identifiers*: [ *gluon_ffmuc_${ad_devname}* ] }, 
		 *state_topic*: *ffmuc/$1/publicwifi/localclients*, *value_template*: *{{ value_json.count }}*, *icon*:*mdi:mdi-numeric*, 
		 *friendly_name*:*Friendly $ad_devname*, *~*:*ffmuc/$1/publicwifi/localclients*  }"
	[ "$2" = "-d" ] && msg=""
	# publish_to_mqtt_starred "homeassistant/sensor/${1}clients/config" "$msg"
	#### set -x
# alias homie_meta
	homie_meta "homeassistant/sensor/${1}clients/config" something "$msg"

	publish_to_mqtt "eumel/eumel" "huhu" 
	# exit
	# return 0

	homie_meta $1 "homie" "3.0.1"      $2
	homie_meta $1 "name" "$ad_devname" $2

	[ "$ad_fwversion" -o "$2" ] && homie_meta $1 "fw/version"     "$ad_fwversion" $2
	[ "$ad_fwname"    -o "$2" ] && homie_meta $1 "fw/name"        "$ad_fwname"    $2
	[ "$ad_impl"      -o "$2" ] && homie_meta $1 "implementation" "$ad_impl"      $2

	# homie_meta $1 "stats/interval" 600  $2

	homie_meta $1             nodes      "publicwifi,gluondata" $2
	homie_meta $1/publicwifi  name       "Public Wifi" $2
	homie_meta $1/publicwifi  type       "Public Wifi Network" $2
	homie_meta $1/publicwifi  properties "clientscount,status,ssidshort,lastdate" $2

	homie_meta $1/publicwifi/clientscount name "Client count" $2
	# homie_meta $1/publicwifi/clientscount settable false $2
	homie_meta $1/publicwifi/clientscount retained false $2
	homie_meta $1/publicwifi/clientscount datatype integer $2
	homie_meta $1/publicwifi/clientscount unit "#" $2
	homie_meta $1/publicwifi/clientscount format "-1:9999" $2

	homie_meta $1/publicwifi/status name "Wifi state" $2
	homie_meta $1/publicwifi/status settable true $2
	# homie_meta $1/publicwifi/status retained false $2
	homie_meta $1/publicwifi/status datatype boolean $2

	homie_meta $1/publicwifi/ssidshort name "WiFi SSID" $2
	# homie_meta $1/publicwifi/ssidshort settable false $2
	homie_meta $1/publicwifi/ssidshort retained false $2
	homie_meta $1/publicwifi/ssidshort datatype string $2

	homie_meta $1/publicwifi/lastdate name "Last date sent" $2
	# homie_meta $1/publicwifi/lastdate settable false $2
	homie_meta $1/publicwifi/lastdate retained false $2
	homie_meta $1/publicwifi/lastdate datatype string $2
	# homie_meta $1/publicwifi/lastdate unit "#" $2
	# homie_meta $1/publicwifi/lastdate format "0:9999" $2

	homie_meta $1/gluondata  name       "Node Data" $2
	homie_meta $1/gluondata  type       "Gluon Data" $2
	homie_meta $1/gluondata  properties "autoupdater-branch,autoupdater-enabled,gluon-version,release,model,core-domain" $2

	homie_meta $1/gluondata/autoupdater-branch  name "Autoupdater Branch" $2
	# homie_meta $1/gluondata/autoupdater-branch settable false $2
	homie_meta $1/gluondata/autoupdater-branch  retained false $2
	homie_meta $1/gluondata/autoupdater-branch  datatype string $2

	homie_meta $1/gluondata/autoupdater-enabled name "Autoupdater Enabled" $2
	# homie_meta $1/gluondata/autoupdater-enabled settable false $2
	homie_meta $1/gluondata/autoupdater-enabled retained false $2
	homie_meta $1/gluondata/autoupdater-enabled datatype boolean $2

	homie_meta $1/gluondata/gluon-version name "Gluon Version" $2
	homie_meta $1/gluondata/gluon-version retained false $2
	homie_meta $1/gluondata/gluon-version datatype string $2

	homie_meta $1/gluondata/release       name "Release" $2
	homie_meta $1/gluondata/release       retained false $2
	homie_meta $1/gluondata/release       datatype string $2

	homie_meta $1/gluondata/model         name "Hardware Model" $2
	homie_meta $1/gluondata/model         retained false $2
	homie_meta $1/gluondata/model         datatype string $2

	homie_meta $1/gluondata/core-domain name "Core Domain" $2
	homie_meta $1/gluondata/core-domain retained false $2
	homie_meta $1/gluondata/core-domain datatype string $2

	homie_meta $1 state ready $2

	# ffmuc/alt-solln/publicwifi/localclients {"count":"3","localclients":[ {"addr":"3c:cd:...:7f:8a","name":"3c:cd:...:7f:8a"}, {"addr":"6c:c7:...:7e:de","name":"6c:c7:...:7e:de"}, {"addr":"b4:9c:...:25:5e","name":"b4:9c:...:25:5e"}],"host":"alt-solln"}
	# skipping:   *device* ... *sw_version*:*Gluon YYYY.N*, before model
	# set -x
	msg="{*device_class*:*illuminance*, *name*: *$ad_devname*, 
	  	 *device*: { *name*:*${ad_devname}*, *model*:*Gluon Freifunk Node*, 
	     *manufacturer*:*Freifunk*, *identifiers*: [ *gluon_ffmuc_${ad_devname}* ] },
		 *state_topic*: *ffmuc/$1/publicwifi/localclients*, *value_template*: *{{ value_json.count }}*, 
		 *icon*:*mdi:mdi-numeric*, *friendly_name*:*Friendly $ad_devname*, *~*:*ffmuc/$1/publicwifi/localclients*  }"
	[ "$2" = "-d" ] && msg=""
	# publish_to_mqtt_starred "homeassistant/sensor/${1}clients/config" "$msg"
	homie_meta "homeassistant/sensor/${1}clients/config" something "$msg"

	publish_to_mqtt "eumel/eumel" "huhu" 

	storage_cache_write "$sTargetHost.homie_init_day" "$( date "+%j" )"
	}

hass_init() {
	# homeassistant/switch/0x7cb03eaa0a096d9c/switch/config 
	# {"payload_off":"OFF","payload_on":"ON","value_template":"{{ value_json.state }}","command_topic":"zigbee2mqtt/Osram-Smart-Plus/set","state_topic":"zigbee2mqtt/Osram-Smart-Plus","json_attributes_topic":"zigbee2mqtt/Osram-Smart-Plus","name":"Osram-Smart-Plus_switch","unique_id":"0x7cb03eaa0a096d9c_switch_zigbee2mqtt","device":{"identifiers":["zigbee2mqtt_0x7cb03eaa0a096d9c"],"name":"Osram-Smart-Plus","sw_version":"Zigbee2mqtt 1.13.0","model":"Smart+ plug (AB3257001NJ)","manufacturer":"OSRAM"},"availability_topic":"zigbee2mqtt/bridge/state"}

	# homeassistant/sensor/0x00158d0003a401e2/linkquality/config 
	# {"icon":"mdi:signal","unit_of_measurement":"lqi","value_template":"{{ value_json.linkquality }}","state_topic":"zigbee2mqtt/Aqara-Sensor","json_attributes_topic":"zigbee2mqtt/Aqara-Sensor","name":"Aqara-Sensor_linkquality","unique_id":"0x00158d0003a401e2_linkquality_zigbee2mqtt","device":{"identifiers":["zigbee2mqtt_0x00158d0003a401e2"],"name":"Aqara-Sensor","sw_version":"Zigbee2mqtt 1.13.0","model":"MiJia temperature & humidity sensor (WSDCGQ01LM)","manufacturer":"Xiaomi"},"availability_topic":"zigbee2mqtt/bridge/state"}
string='{
   "availability_topic" : "zigbee2mqtt/bridge/state",
   "value_template" : "{{ value_json.linkquality }}",
   "unit_of_measurement" : "lqi",
   "unique_id" : "0x00158d0003a401e2_linkquality_zigbee2mqtt",
   "json_attributes_topic" : "zigbee2mqtt/Aqara-Sensor",
   "icon" : "mdi:signal",
   "device" : {
      "name" : "Aqara-Sensor",
      "identifiers" : [
         "zigbee2mqtt_0x00158d0003a401e2"
      ],
      "sw_version" : "Zigbee2mqtt 1.13.0",
      "model" : "MiJia temperature & humidity sensor (WSDCGQ01LM)",
      "manufacturer" : "Xiaomi"
   },
   "state_topic" : "zigbee2mqtt/Aqara-Sensor",
   "name" : "Aqara-Sensor_linkquality"
 }'

	node_id=0x00158d0003a401e2
	typ=linkquality
	dev=Aqara-Sensor
	true publish_to_mqtt_starred "homeassistant/sensor/$node_id/$typ/config" "{
   *availability_topic* : *zigbee2mqtt/bridge/state*,
   *value_template* : *{{ value_json.$typ }}*,
   *unit_of_measurement* : *lqi*,
   *unique_id* : *${node_id}_${typ}_zigbee2mqtt*,
   *json_attributes_topic* : *zigbee2mqtt/$dev*,
   *icon* : *mdi:signal*,
   *device* : {
      *name* : *$dev*,
      *identifiers* : [
         *zigbee2mqtt_$node_id*
      ],
      *sw_version* : *Gluon blabla*,
      *model* : *Freifunk Device Typ yxz*,
      *manufacturer* : *Freifunk-MUC*
   },
   *state_topic* : *zigbee2mqtt/$dev*,
   *name* : *${dev}_$typ*
 }"
	
	# homeassistant/sensor/sensorBedroomT/config
    #  {"device_class": "temperature", "name": "Temperature", "state_topic": "homeassistant/sensor/sensorBedroom/state", "unit_of_measurement": "°C", "value_template": "{{ value_json.temperature}}" } 

	# ffmuc/alt-solln/publicwifi/localclients {"count":"3","localclients":[ {"addr":"3c:cd:...:7f:8a","name":"3c:cd:...:7f:8a"}, {"addr":"6c:c7:...:7e:de","name":"6c:c7:...:7e:de"}, {"addr":"b4:9c:...:25:5e","name":"b4:9c:...:25:5e"}],"host":"alt-solln"}
	publish_to_mqtt_starred "homeassistant/sensor/altsollnclients/config" "{*device_class*: *illuminance*, 
	 *name*: *LokaleKlienten*, *state_topic*: *ffmuc/alt-solln/publicwifi/localclients*, 
	 *value_template*: *{{ value_json.count}}* }"

	}

# Initialize our own variables:
OPTIND=1         # Reset in case getopts has been used previously in the shell.
bQuiet=""
bVerbose=""

bDoAllOfIt=""
password_key_skip=""
commands="" # commands="mesh-id"
option_to_query=""
write_uci_val=""

cmd_mospub="true"
command -v "mosquitto_pub" >/dev/null && cmd_mospub="mosquitto_pub"

if [ -r /lib/gluon/gluon-version ]
then # I'm running on Gluon (based on OpenWrt)
	gluon="y"
	# mqtthost="-h test.mosquitto.org"
	json_pp="cat"
	ffhosts="localhost"
	macidsfile="/tmp/phones"
elif [ -x /usr/sbin/print_map.sh ]
then # I'm probably running on some other freifunk on OpenWrt   (need to made more granular for OpenWrt..)
	gluon=""
	mqtthost="-h test.mosquitto.org"
	json_pp="cat"
	ffhosts="localhost"
	macidsfile="/tmp/phones"
else                                      # on rest-of-world (e.g. Raspi or some fullblown OpenWrt)
	gluon=""
	mqtthost="-h localhost"
	json_pp="json_pp"
	macidsfile="/srv/openhab2-conf/phones"
fi

jsonfilter=$( command -v jq 2>/dev/null ) || jsonfilter=$( command -v jsonfilter 2>/dev/null ) || error_and_exit "jsonfilter or jq must be available."
jsonfilter=$( basename $jsonfilter )
# echo "\$jsonfilter=$jsonfilter"

tmpdir="/tmp/${scriptname%.sh}.$( id -nu )/$$" && mkdir -p "$tmpdir"
cachedir="$( dirname "$tmpdir" )" # one up in the hierarchy
debugfile="$tmpdir/debugfile"
clientcollection="$tmpdir/clientcollection"
echo "$0  "  "$@" > "$debugfile"

[ $# -eq 0 ] && { show_help ; exit 1 ; } # at least one parameter on the command line is required

while getopts "?h:gvxqas:pi:f:m:n:c:o:w:" opt   # https://wiki.bash-hackers.org/howto/getopts_tutorial
do
    case "$opt" in
    \?) show_help
        exit 1
        ;;
    h|s)  ffhosts="$OPTARG" # one or more Freifunk node(s)
		if expr index ."$ffhosts" "+*" > /dev/null # substitute a literal + or * for a set of predefined hosts
		then
			# the values used for + should be stored externally in the file $userconfigdir/myhosts.persisted:
			# "host1,host2,host3" (without double quotes)

			myhostcollection=""
			[ "$myhostcollection" ] || myhostcollection="$( storage_user_read myhosts )"
			[ "$myhostcollection" ] || error_and_exit "config for collection of hosts is missing ($userconfigdir/myhosts.persisted)"
			ffhosts="$( echo "$ffhosts" | sed -e "s/[+*]/$myhostcollection/g" |	tr -d -c "a-zA-Z.,-" )" # replace and sanitize
			workonallclients="yes"
		fi
	    ffssid="$ffssid1"
        ;;
    g)  bGiveHost="yes"
		;;
    v)  bVerbose="yes"
		;;
	x)  bVerbose="yes"
		set -o xtrace
        ;;
	q)	bQuiet="yes"
		;;
    a)  bDoAllOfIt=yes
		;;
	m)  [ "$cmd_mospub" = "true" ] && error_and_exit "ERROR: mosquitto_pub is missing!"
		if [ "$OPTARG" = "test" -o "$OPTARG" = "mosq" ] ; then
            mqtthosttarget="test.mosquitto.org"
        else
            mqtthosttarget="$( echo $OPTARG | tr -d ':()"^%$ \r\000-\011\013-\037')" # clean up for sec purposes
        fi
		mqtthost="-h $mqtthosttarget"
		;;
	p)  homie="yes" # implies MQTT
		[ "$cmd_mospub" = "true" ] && error_and_exit "the MQTT client mosquitto_pub is not installed, but -$opt is requested..."
		;;
	i)	areaid="$OPTARG"
		;;
	f)  additional_option="$OPTARG"
		filetocopy="$OPTARG" 
		commands="filecopy"
		;;
	n)  additional_option="$OPTARG"
		ffssid="$OPTARG"
		;;
    c)  commands="$OPTARG" # one or more, comma-seperated command to be executed
        ;;
    o)  option_to_query="$OPTARG" ; commands="uciquery"
		# echo option_to_query="$option_to_query"
        ;;
    w)  write_uci_val="$OPTARG" ; commands="uciwrite"
		# echo write_uci_val="$write_uci_val"
        ;;
    esac
done

shift "$((OPTIND-1))"   # Discard the options parsed so far and leave the rest of the cmd line...

if [ -n "$homie" -o -n "$mqtthost" ] ; then # enable MQTT
	echo_if_verbose "Left the MQTT commands"
else
	echo_if_verbose "Eliminated MQTT commands "
	alias publish_to_mqtt_maybe="true skipped publish_to_mqtt_maybe"
	alias publish_to_mqtt_starred="true skipped publish_to_mqtt_starred"
	alias homie_line="true skipped homie_line"
	alias homie_meta="true skipped homie_meta"
fi

# find a name for the collection of all clients here:
for ffhost in $( echo "${ffhosts:-localhost}" | tr -s "," " " ) # for each given host, maybe just one... (tr needed on ash)
do
	if [ "$ffhost" = "localhost" ] ; then
		sSshUser="NOUSER"
		ssh_cmd="exec_locally" # ssh_cmd="sh -c"
		sTargetHost="$areaid"
	else
		sSshUser="root@$ffhost"
		ssh_cmd="ssh -T $sSshUser" 
		sTargetHost=$( echo "$ffhost" | tr "A-Z" "a-z" | sed -e 's/\..*//' -e 's/-e$//' ) # remove any trailing "-e" and domain name
	fi
	tmpfilemqtt="$tmpdir/mqtt.$ffhost"
	new_ssid=""

	[ "$bVerbose" -a "$bGiveHost" ] && echo "######"
	[ "$bVerbose" -o "$bGiveHost" ] && echo "######  $sSshUser / $sTargetHost / $commands / " "$@" "######"

	if [ "$option_to_query" ]
	then
		uci_val="$( query_uci_on_host "$option_to_query" )"

		if [ "$bDoAllOfIt" ] ; then
			echo "$uci_val"
			continue
		fi
		
		uci_val="$(extract_uci_values "$uci_val")"

		if [ -z "$write_uci_val" ]  ; 		then
			echo "$uci_val" # it was a query only = no writes
		elif [ "$( echo "$uci_val" | wc -l )" -gt 1 ] ; then
			error_and_exit "key :$option_to_query: had returned more than one line!"
		else
			$ssh_cmd "uci set $option_to_query=$write_uci_val ; uci commit $option_to_query" 
			# echo $option_to_query was changed: "$(query_uci_on_host $option_to_query)". 1>&2
		fi
	else
		commandsToDo="$commands"

		if [ "$commandsToDo" = "mqtt" ] 
		then
			# spawn a subprocess that will wait for a MQTT message....
			sSysMqqtDummyTopic='$SYS/broker/uptime'
			readonly fPipe="$tmpdir/f" 
			mkfifo "$fPipe" || error_and_exit "Could not create $fPipe (retcode=$?)." 
			# set -x
			mosquitto_sub -v -R $mqtthost -t "ffmuc/$sTargetHost/+/GET" -t "$sSysMqqtDummyTopic/maximum" | awk -e '{ print strftime("MQTT ") $0 ; fflush() } ' > $fPipe  &  #  pipe non-stale commands from MQTT broker 
			# set +x
			readonly nMosquittoPid=$!
			while sleep 60 ; do echo PERIODIC noop ; done  > $fPipe  &  #  pipe periodic stuff into the pipe to make it wakeup
			readonly nPeriodicPid=$!
			trap "kill $nMosquittoPid $nPeriodicPid ; rm -f $fPipe" INT QUIT EXIT  # variables are set now for cleaning up
		fi

		# OpenHab Homie autodiscovery doesn't like uppercase characters at the beginning...
		[ "$homie" ] && os_data="$( get_os_data_semi_starred_cached "$sTargetHost" 1 )" && homie="$( echo "$sTargetHost" | awk -- '{ print tolower(substr($i,1,1)) substr($i,2) }' )" &&
			 [ "$commandsToDo" != "homie-delete" ] && homie_init "$homie"

		while [ "$commandsToDo" ]
		do
			if [ "$commandsToDo" = "mqtt" ] 
			then
				# set -x
				read -r sPipeType command commandoptions < "$fPipe" ; nReadCode=$? 
				[ "$nReadCode" -ne 0 ] &&  error_and_exit "Read error from pipe $fPipe (retcode=$nReadCode)." 

				if [ "$sPipeType" = "MQTT" ] ;then 
					command="$( echo "$command" | awk -v FS=/ 'NF && NF-1 { print ( $(NF-1) ) }' )" # extract last part of topic, must have at least one /
				fi
			else
				     command="$( echo "$commandsToDo" | cut -d "," -f 1  )"
				commandsToDo="$( echo "$commandsToDo" | cut -s -d "," -f 2- )"
			fi			

			case "$command" in
			mqtt|noop)
				echo_if_verbose "Noop: $command  $commandoptions"
				;;
			echo)
				publish_to_mqtt_maybe "$sTargetHost/$command" "$commandoptions"
				reply_to_mqtt_status "OK"
				;;
			loop)
				for i in $( seq 1 20 ) ; do
					echo_if_not_quiet "$i " "$( $ssh_cmd "/bin/date" > /dev/null )"
				done
				reply_to_mqtt_status "OK"
				;;
			install)
				deny_if_mqtt && continue
				targetuser="$( $ssh_cmd "id -nu" )"
				if [ -z "$targetuser" ] ; then
					echo_if_not_quiet "targetuser on targethost could not be determined remotely: Pls debug your SSH setup..."
					continue # abort case
				fi

				if [ "$ssh_cmd" != "exec_locally" ] || [ "$targetuser" = "root" ] ; then
					echo_if_not_quiet "Remote targetuser is $targetuser: Shall copy this script to /sbin later..."
					commandsToDo="filecopy${commandsToDo:+,$commandsToDo}"
					filetocopy="$0"
				fi

				os_data="$( get_os_data_semi_starred_cached "$sTargetHost" 1 )"
				echo_if_verbose "$os_data"

				# ... try to install mosquitto if not there yet
				if [ "$( $ssh_cmd "command -v mosquitto_pub" 2>/dev/null )" ] ; then
					echo_if_not_quiet "mosquitto_pub is already installed on $ffhost..."
				else
					echo_if_not_quiet "mosquitto_pub was not found on $ffhost... trying to install..."
					installcmd=$( $ssh_cmd "command -v opkg || command -v apt || echo nothing" 2>/dev/null ) 					
					case "$( basename "$installcmd" )" in
					opkg)
						$ssh_cmd "opkg update && echo opkg install mosquitto-client-nossl"
						;;
					apt)
						$ssh_cmd "apt update && echo apt install mosquitto-clients"
						;;
					nothing)
						error_and_exit "ERROR: opkg / apt not found on $ffhost. Stopping..."
						;;
					esac
				fi
				# from here on, it gets Freifunk-specific
				autoupdater_branch="$( get_uci_on_host "autoupdater.settings.branch" )"
				echo_if_verbose "autoupdater_branch=$autoupdater_branch"
				if [ -z "$autoupdater_branch" ] ; then
					# Probably Non-Freifunk 
					echo_if_not_quiet "Stopping for target $sTargetHost (no autoupdater_branch uci setting)..." 
					continue
				else
					storage_cache_write "$sTargetHost.autoupdater_branch" "$autoupdater_branch"
					echo_if_not_quiet "autoupdater config found... assuming freifunk router... adding firewall rules for MQTT..."
					# works for Ulmer Software w/o Gluon, too...
					$ssh_cmd "xargs ${bVerbose:+-t} -n 1 uci set ; uci commit" << EOF
						firewall.local_client_mqtt=rule
						firewall.local_client_mqtt.dest_port='1883'
						firewall.local_client_mqtt.src='local_client'
						firewall.local_client_mqtt.name='local_client_mqtt'
						firewall.local_client_mqtt.target='ACCEPT'
						firewall.local_client_mqtt.proto='tcp'
EOF
					$ssh_cmd "gluon-reconfigure" || echo "Running gluon-reconfigure failed..." 1>&2
				fi

				if $ssh_cmd "crontab -l" | grep "$scriptname" ; then
					echo_if_verbose "crontab entry containing $scriptname had been found..."
				else
					echo_if_not_quiet "crontab entry with $scriptname not found... adding a simple one... modify later!"
					cronentry="*/30 * * * * sleep 15 ; $scriptname -c machine-data -m test.mosquitto.org"
					$ssh_cmd "{ crontab -l ; echo \"$cronentry\" ; } | crontab - ; ${bVerbose:+echo crontab is now: ; crontab -l}"
				fi
				# still missing: make it run as an MQTT daemon!
				;;
			filecopy)
				deny_if_mqtt && continue
				[ "$filetocopy" ] && scp -p "$filetocopy" "$sSshUser":/sbin && echo_if_verbose "$filetocopy copied to $sSshUser:/sbin"
				;;
			sh)
				# [ "$commandsToDo" = "mqtt" ] && echo_if_not_quiet "Mqtt $command ignored." && continue
				deny_if_mqtt && continue
				ssh "$sSshUser" # start a shell
				;;
			homie-update)
				commandsToDo="localclients,ffstatus,gluon-data,machine-data,$commandsToDo"
				
				uptimecmd="cat /proc/uptime" && [ "$ffhost" != localhost ] && uptimecmd="$0 -h $ffhost $uptimecmd" 
				homieuptime=$( $uptimecmd ) && homie_line "$homie/\$stats/uptime" "$( echo "$homieuptime" | cut -f 1 -d . )"
				;;
			homie-delete)
				deny_if_mqtt && continue
				homie="$( echo "$sTargetHost" | awk -- '{ print tolower(substr($i,1,1)) substr($i,2) }' )" # duplicate code...
				homie_init "$homie" "-d"
				;;
			ffdown)
				# deny_if_mqtt && continue
				new_ssid=$( $ssh_cmd "iw dev $ff_if_pub del" 2>&1 ) # stop Freifunk public interface
				echo "$new_ssid" | grep -q 'No such.* device' && reply_to_mqtt_status "ERROR" "$new_ssid" && new_ssid=""
				echo_if_not_quiet "$sTargetHost: Ran wifi down on $ff_if_pub (new_ssid=$new_ssid)"
				homie_line "$homie/publicwifi/clientscount" "-1"
				[ "$new_ssid" ] && reply_to_mqtt_status "OK"
				commandsToDo="ffstatus${commandsToDo:+,$commandsToDo}"
				;;
			ffup|ffstatus)
				echo_if_verbose "Now doing $command on host..."
				retcode=0
				# $ssh_cmd "ip link set $ff_if_pub up" # start Freifunk public interface
				if [ "$command" = "ffup" ] ; then
					tempstr=$( $ssh_cmd "wifi up && sleep $wifiupsleep && iwinfo $ff_if_pub info" ) && new_ssid=$( echo "$tempstr" | sed -e '/ESSID/s/[^:]*: //'  -e '1q' )
				elif [ "$new_ssid" ] ; then
					echo_if_not_quiet "Recycling new_ssid=$new_ssid..."
				else
					tempstr=$( $ssh_cmd "iwinfo $ff_if_pub info" 2>&1 ) && new_ssid=$( echo "$tempstr" | sed -e '/ESSID/s/[^:]*: //'  -e '1q' )
				fi
				retcode=$?			
				echo_if_not_quiet "Executed $command (retcode=$retcode) - ssid=*$new_ssid*" 
					homie_line "$homie/publicwifi/lastdate" "$( date )"
				if [ "$retcode" != 0 -o -z "$new_ssid" ] || echo "$new_ssid" | grep -w -q -E "open failed|connect failed|No such" ; then
					new_ssid_short=""
					homie_line "$homie/publicwifi/status" "false" 
				else
					new_ssid_short="$( printf "$new_ssid" | sed -e 's/\"//g' -e 's,.*/,,')"
					homie_line "$homie/publicwifi/status" "true"
				fi
				homie_line "$homie/publicwifi/ssidshort" "$new_ssid_short"
				publish_to_mqtt_maybe "$sTargetHost/publicwifi/ssidshort" "$new_ssid_short"
				;;
			ffcond)
				result=$( $ssh_cmd '{ for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | tee /tmp/wifis ; echo ++++++++++++ ; iwinfo | fgrep client0 '  )
				ifresult=$( echo "$result" | grep -A 3 '++++++++++' | grep -m 2 "client0 *ESSID:" )
				if echo "$result" | grep -A 9 -w '6e:a3:09:ea:31:e00' | grep -w "SSID:.muenchen.freifunk.net"
				then
					# client0   ESSID: "muenchen.freifunk.net/welt"
					echo_if_not_quiet "To be upped..."
					if [ -z "$ifresult" ] ; then commandsToDo="ffup${commandsToDo:+,$commandsToDo}" ; fi
				else	
					echo_if_not_quiet "To be downed..."
					if [ -n "$ifresult" ] ; then commandsToDo="ffdown${commandsToDo:+,$commandsToDo}" ; fi
				fi
				echo_if_verbose commandsToDo=$commandsToDo
				# ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )  ) || ( iwinfo | fgrep client0 && iw dev client0 del ; echo if downed )
				;;
			ffotherssid|ffotherssid1|ffotherssid2|ffotherssid_*)
				# ["freising", "gauting", "muc_cty", "muc_nord", "muc_ost", "muc_sued", "muc_west", "uml_nord", "uml_ost", "uml_sued", "uml_west", "welt"]
				# $ssh_cmd "ip link set $ff_if_pub up" # start Freifunk public interface
				# $ssh_cmd "true" || { echo_if_not_quiet "target not reachable, aborting this command...." ; continue ; }
				otherssid="muenchen.freifunk.net/welt"
				case "$command" in
					ffotherssid1)  otherssid="muenchen.freifunk.net/uml_nord" 	;;
					ffotherssid2)  otherssid="muenchen.freifunk.net/uml_west"	;;
					ffotherssid_*) otherssid="muenchen.freifunk.net/${command#ffotherssid_}"	;;
				esac
				result=$( $ssh_cmd "iwinfo $ff_if_pub info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' ; uci set wireless.client_radio0.ssid=$otherssid ; wifi up ; sleep $wifiupsleep ; iwinfo $ff_if_pub info | sed -e 's/: /:/' -e '1q' " 2>&1 )
				retcode=$?
				#### uci set wireless.client_radio0.ssid=$otherkey ; uci set wireless.client_radio0.encryption=psk2 ; 
				#### while true ; do sleep 1 ; date ; iwinfo client0 info | grep SSID ; done
				### result=$( ssh -i ~/.ssh/id_rsa4096_ff -o ProxyCommand="ssh -v -W [2001:608:a01:103:ee08:6bff:fe33:6940]:%p alt-solln" root@[2001:608:a01:103:ee08:6bff:fe33:6940] uname -a )
				echo "$result" >> $debugfile
				if [ "$retcode" = 255 ] ; then
					_logmsg="target not reachable (ssh return code 255), aborting ffotherssid command...." 
					echo_if_not_quiet "$_logmsg" 
					reply_to_mqtt_status "ERROR" "$_logmsg"
					continue
				elif [ -z "$result" ] ; then
					_logmsg="ffotherssid commands on remote host returned empty string..." 
					echo_if_not_quiet "$_logmsg" 
					reply_to_mqtt_status "ERROR" "$_logmsg"
					continue
				else
					prev_ssid=$( printf "$result" | grep SSIDPREV: | cut -d : -f 2 )
					new_ssid=$(  printf "$result" | grep ESSID:    | cut -d : -f 2 )
					echo_if_not_quiet "%s: Set ssid=%s, then wifi up. Now $new_ssid. // id=$(id -nu)/$(id -u)\n" "$sTargetHost" "$otherssid"
					# reply_to_mqtt_status "ERROR" "$_logmsg"
					commandsToDo="ffstatus${commandsToDo:+,$commandsToDo}" # ... implicitly followed by a ffstatus
				fi
				;;
			ffgluonreconfigure)
				deny_if_mqtt && continue
				# $ssh_cmd "ip link set $ff_if_pub up" # start Freifunk public interface
				# 6 seconds needed for interface!
				result=$( $ssh_cmd "iwinfo $ff_if_pub info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' ; gluon-reconfigure | tail -3 ; wifi up  ; sleep $wifiupsleep ; iwinfo $ff_if_pub info | sed -e 's/: /:/' -e '1q' " )
				prev_ssid=$( printf "$result" | grep SSIDPREV | cut -d : -f 2 )
				new_ssid=$( printf "$result" | grep ESSID | cut -d : -f 2 )
				echo_if_not_quiet "$sTargetHost: Ran gluon-reconfigure, previously $prev_ssid, then wifi up, then $new_ssid. id=$(id -nu)/$(id -u)\n" 
				if [ "$prev_ssid" != "$new_ssid" ] ; then
					commandsToDo="localclients${commandsToDo:+,$commandsToDo}"
				fi
				commandsToDo="ffstatus${commandsToDo:+,$commandsToDo}" # ... implicitly followed by a ffstatus
				;;
			gluon-data)
			  os_data="$( get_os_data_semi_starred_cached "$sTargetHost" 1 )"
			  if [ -z "$os_data" ] ; then
			  	reply_to_mqtt_status "ERROR"
			  else
				output="$( $ssh_cmd "uci get autoupdater.settings.branch 2>&1 ; uci get autoupdater.settings.enabled 2>&1 ; uci get gluon.core.domain 2>&1 ; lua -e 'print(require(\"platform_info\").get_model())' 2>&1 ; cat /lib/gluon/gluon-version 2>&1 ; cat /lib/gluon/release 2>&1 ; ls /lib/gluon/domains 2>&1" )"
				autoupdaterbranch="$( echo "$output" | sed -n -e "1p" )"
				autoupdaterenabled="$( echo "$output" | sed -n -e 2s/0/false/  -e 2s/1/true/ -e "2p" )"
				gluoncoredomain="$( echo "$output" | sed -n -e "3p" )"
				routermodel="$(     echo "$output" | sed -n -e "4p" )"
				gluonversion="$(    echo "$output" | sed -n -e "5p" )"
				gluonrelease="$(    echo "$output" | sed -n -e "6p" )"
				gluondomains="$(    echo "$output" | sed -n -e '7,$s/[^_]*_//' -e 's/.json//' -e '7,$p' | awk 'BEGIN { printf "[" } { printf comma "*" $0 "*" ; comma="," } END { printf "]" }' )"

				echo_if_not_quiet "$os_data"
				publish_to_mqtt_starred "ffmuc/$sTargetHost/gluondata/os-data" "$os_data"
				homie_line                          "$homie/gluondata/os-data" "$os_data"

				echo_if_not_quiet "$autoupdaterbranch"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/autoupdater-branch" "$autoupdaterbranch"
				homie_line                  "$homie/gluondata/autoupdater-branch" "$autoupdaterbranch"

				echo_if_not_quiet "$autoupdaterenabled"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/autoupdater-enabled" "$autoupdaterenabled"
				homie_line                  "$homie/gluondata/autoupdater-enabled" "$autoupdaterenabled"

				echo_if_not_quiet "$gluoncoredomain"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/core-domain" "$gluoncoredomain"
				homie_line                  "$homie/gluondata/core-domain" "$gluoncoredomain"

				echo_if_not_quiet "$routermodel"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/model" "$routermodel"
				homie_line                  "$homie/gluondata/model" "$routermodel"

				newval="TBD"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/site" "$newval"
				homie_line                  "$homie/gluondata/site" "$newval"

				echo_if_not_quiet "$gluonversion"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/gluon-version" "${gluonversion##v}"
				homie_line                  "$homie/gluondata/gluon-version" "${gluonversion##v}"
				
				echo_if_not_quiet "$gluonrelease"
				publish_to_mqtt_maybe "$sTargetHost/gluondata/release" "${gluonrelease##v}"
				homie_line                  "$homie/gluondata/release" "${gluonrelease##v}"

				echo_if_not_quiet "$gluondomains"
				publish_to_mqtt_starred "ffmuc/$sTargetHost/gluondata/gluon-domains" "$gluondomains"
				homie_line                          "$homie/gluondata/gluon-domains" "$gluondomains"
			  	reply_to_mqtt_status "OK"
			  fi
			  ;;
			machine-data)
				os_data="$( get_os_data_semi_starred_cached "$sTargetHost" 1 )"
				echo_if_verbose "os_data=$os_data" #  ; exit 1
				newval=$( $ssh_cmd "cat /proc/version /proc/cpuinfo" |  awk -v os_data="$os_data" '
					NR==1 { linuxversion=$3 ; FS=": " }
					/^machine|^Hardware/ { FS=": " ; printf "{*linuxversion*:*%s*,*machine*:*%s*,%s}", linuxversion ,$2, os_data ; exit 0 }
					' ) 
				echo_if_not_quiet "$newval"
				publish_to_mqtt_starred "ffmuc/$sTargetHost/$command" "$newval"
				;;
			status)
				newval=$( $ssh_cmd "cat /proc/uptime /proc/loadavg" | awk '
					NR==1 { uptime=sprintf("%d", $1) }
					NR==2 { printf "{*uptime*:*%s*,*load*:*%.2f*}", uptime ,$1 }
					'  ) # uptime in seconds
				echo_if_not_quiet "$newval"
				publish_to_mqtt_starred "ffmuc/$sTargetHost/$command" "$newval"
				# set +x
				;;
			printmap)  
				$ssh_cmd "print_map.sh" | $json_pp # node info as JSON for non-Gluon systems!
				;;
			localclients)  
				touch "$clientcollection" && chmod g+w "$clientcollection"
				localclientsfile="$clientcollection.$sTargetHost"
				[ -r $macidsfile ] || touch $macidsfile
				
				$ssh_cmd "batctl translocal" > $localclientsfile.debug
				if [ $? = 0 ]
				then
					awk '$3 == "[....W.]" { printf "%s\n", $1 }' $localclientsfile.debug | sort > $localclientsfile # | join -a 1 - "$macidsfile" 
				
					( date ; cat $localclientsfile ) >> $debugfile
					# cat $localclientsfile
					# xargs -r -L1 bash -c 'date "+%Y-%m-%d_%T.%3N $0 '$sTargetHost'"' < $localclientsfile >> $clientcollection
					awk -- "{ print strftime(\"%Y-%m-%d_%H:%M:%S \") \$0 \" $sTargetHost\" ; fflush() ; next }" $localclientsfile >> $clientcollection
					
					if command -v join >/dev/null && [ -r $macidsfile ] ; then  # if we are able to join the date to a list of clients...
						{ sort -k 1 $localclientsfile | join -1 1 -2 1 -a 1 - $macidsfile | sort | uniq -w 17 > "$localclientsfile"_with_names ; } &&
						mv "$localclientsfile"_with_names "$localclientsfile"
					fi

					[ "$bVerbose" ] && echo $localclientsfile: && cat "$localclientsfile"
					_lcount=$( wc -l < $localclientsfile )
					homie_line "$homie/publicwifi/clientscount" "$_lcount"
					
					localclients=$( cat "$localclientsfile" | tr " " ","  |  
						awk -F, -v lcount="$_lcount" -v hname="$sTargetHost" 'BEGIN { printf "{*count*:*%s*,*localclients*:[", lcount } { printf comma " {*addr*:*%s*,*name*:*%s*}", $1, ($2=="")? $1 : $2 $3 $4 $5 ; comma="," } END { printf "],*host*:*%s*}",hname }' | 
						  shorten_ethernet_addr_in_json ${bDoAllOfIt:+skip} )
					echo_if_not_quiet "$localclients"
					publish_to_mqtt_starred "ffmuc/$sTargetHost/publicwifi/localclients" "$localclients"
					[ "$workonallclients" ] && collectedsumofclients=$( expr ${collectedsumofclients:-0} + ${_lcount} )
					collectedclients="$collectedclients $( xargs < $localclientsfile )" 
					collectedclients="${collectedclients% }" # trim leading spaces
				else
					echo "$scriptname: Connection to $sSshUser failed. Stopping for this node..." 1>&2
				  	reply_to_mqtt_status "ERROR"
				fi
				;;
			nodeinfo|neighbours|statistics)  
				tmpfilejson="$tmpdir/$sTargetHost.$command.tmp"
				cachedrouterip="$( storage_cache_read "$sTargetHost.routerip" 10 )"
				# if [ "$cachedrouterip" = "##NOTFOUND##" -o "$cachedrouterip" = "##EMPTY##" ]
				__gni_cmd="gluon-neighbour-info -i br-client -p 1001 -r $command -d  " # ipaddr will be appended below
				if [ -z "$cachedrouterip" ]
				then
					ffrouterip=$( $ssh_cmd "ip -f inet6 -o addr show dev $ifipv6" | awk -e '{ print gensub("/.*", "", "1", $4) ; exit 0 }'  ) && \
						$ssh_cmd "$__gni_cmd $ffrouterip" | tee "$tmpfilemqtt"
				else
					ffrouterip="$cachedrouterip" && \
						$ssh_cmd "$__gni_cmd $ffrouterip" | tee "$tmpfilemqtt"
				fi
				echo_if_verbose "Had called $__gni_cmd $ffrouterip"
				returnsize=$( wc -l < "$tmpfilemqtt" )
				# find "$tmpdir" -name "$( basename "$tmpfile_routerip" )" -size -26c -exec rm '{}' \; # delete file if it is too small...

				if [ -z "$ffrouterip" ]
				then
					echo "$scriptname: router IP :$ffrouterip: empty. Command $command failed..." 1>&2
				  	reply_to_mqtt_status "ERROR" "router IP undetermined"
					# rm -f "$tmpfile_routerip"
				elif [ $returnsize -eq 0 ] 
				then
					echo "$scriptname: Connection to $sSshUser or gluon-neighbour-info failed. Command $command on node ip $ffrouterip failed..." 1>&2
				  	reply_to_mqtt_status "ERROR" "remote result empty"
					# rm -f $tmpfile_routerip
				else
					[ "$ffrouterip" != "$cachedrouterip" ] && storage_cache_write "$sTargetHost.routerip" "$ffrouterip"
					storage_cache_write "$sTargetHost.$command" "$( cat $tmpfilemqtt )" # write all types to support change detection some time
					publish_to_mqtt_maybe "$sTargetHost/$command" "$( cat $tmpfilemqtt )"
					if [ "$command" = "statistics" ] ; then
						# node_id=$( jq -r .node_id $tmpfilemqtt )
						# publish_to_mqtt_maybe "ffmuc/$sTargetHost/nodeid" "$node_id" "-r"
						### publish_to_mqtt_maybe "ffmuc/$node_id/$command"  "$( cat $tmpfilemqtt )"  "-r"
						# publish_to_mqtt_maybe "ffmuc/$sTargetHost/ipv6" "$ffrouterip" "-r"
						### publish_to_mqtt_maybe "ffmuc/$node_id/ipv6"      "$ffrouterip" "-r"

						clients=$( jsonfilter_func ".clients.wifi" < $tmpfilemqtt )
						# cat $tmpfilemqtt
						publish_to_mqtt_maybe "$sTargetHost/clients" "$clients"
						[ "$workonallclients" ] && collectedsumofclients=$( expr ${collectedsumofclients:-0} + $clients )
						# publish_to_mqtt_maybe "ffmuc/$node_id/clients" "$clients"
					fi

					[ -f $tmpfilejson.prev ] && mv -f $tmpfilejson.prev $tmpfilejson.old
					[ -f $tmpfilejson      ] && mv -f $tmpfilejson $tmpfilejson.prev
					$json_pp < $tmpfilemqtt > $tmpfilejson
					chmod g+w $tmpfilejson
				fi

				# 33 * * * * /srv/openhab2-conf/manage-gluon-mqtt/manage_gluon_mqtt.sh -c statistics
				# 43 * * * * /srv/openhab2-conf/manage-gluon-mqtt/manage_gluon_mqtt.sh -c neighbours
				# 53 * * * * /srv/openhab2-conf/manage-gluon-mqtt/manage_gluon_mqtt.sh -c nodeinfo
				;;
			showsite)  
				tmpfilejson="$tmpdir/$sTargetHost.$command.old"
					
				if [ -n "$( $ssh_cmd gluon-show-site | tee $tmpfilemqtt )" ]
				then
					node_id="$( jq -r .node_id $tmpfilemqtt )"
					publish_to_mqtt_maybe "$sTargetHost/$command" "$( tr -d '\n' < $tmpfilemqtt )"
					publish_to_mqtt_maybe "$node_id/$command"     "$( tr -d '\n' < $tmpfilemqtt )"
					json_pp < $tmpfilemqtt | tee $tmpfilejson
				else
					error_and_exit "$scriptname: ssh to $sSshUser failed. Stopping..."
				fi
				# 33 * * * * /srv/openhab2-conf/manage-gluon-mqtt/manage_gluon_mqtt -c statistics
				# 43 * * * * /srv/openhab2-conf/manage-gluon-mqtt/manage_gluon_mqtt -c neighbours
				# 53 * * * * /srv/openhab2-conf/manage-gluon-mqtt/manage_gluon_mqtt -c nodeinfo
				;;
			reboot)  
				deny_if_mqtt && continue
				$ssh_cmd "/sbin/reboot"
				;;
			scandirty)  
				deny_if_mqtt && continue
				# relies on the following entry in root's crontab, since only root is allowed to do a full wifi scan
				# SHELL=/bin/bash
				# * * * * * { /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ; } | fgrep SSID  | cut -d ":" -f 2 | xargs -n 1 | sort -u > /tmp/wifis.txt
				# { for i in 2 2 2 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | fgrep SSID  | cut -d ":" -f 2 | xargs -n 1 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt
				# * * * * * { for i in 1 2 1 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | egrep -w '^BSS|SSID'| sed -e 's/BSS *//' -e 's/(.*//' -e 's/\t*SSID: //' -e 's/^$/./' | xargs -L2 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt

				echo "$scriptname: command scandirty grepping for **$ffssid**" > "$debugfile"
				grep -wi "${ffssid}"  /tmp/wifis.txt | tee "$debugfile"
				rm -f /tmp/wifis.txt.hint
				exit 0
				;;
			*)
				error_and_exit "Unknown command: $command"
			esac
			sort_and_tail_file "$debugfile" 300
		done
	fi 
	find "$( dirname "$debugfile")" -maxdepth 1 -prune -path "$debugfile.[0-9]*" -mtime +0 -exec rm '{}' \; # remove old debug files
	
	if [ $# -gt 0 ]
	then
		# ... everything that's left in "$@" is taken as shell commands, too....
		$ssh_cmd "$@"
	fi
done

if [ -n "$collectedsumofclients" ] ; then
	[ "$bVerbose" -a "$bGiveHost" ] && echo "######"
	[ "$bVerbose" -o "$bGiveHost" ] && echo "######  ALL CLIENTS " "$@" "######"
	publish_to_mqtt_maybe "$areaid/publicwifi/allclientscount" "$collectedsumofclients"

	# # kaputt:
	#[ -n "$collectedclients" ] && {
	#	set -x
	#	string="$( echo "$collectedclients" | xargs -n 1 | sort | awk -F, -v id="$areaid" -v lcount="$collectedsumofclients" 'BEGIN { printf "{*count*:*%s*,*id*:*%s*,*localclients*:[", lcount, id } { printf "{*addr*:*%s*}%s", $1 , ( NR<=(lcount-1) ) ? "," : "" } END { printf "]}" }' )"
	#	echo_if_verbose string: "$string"
	#	echo_if_not_quiet "$( echo "$string" | tr \* \" | json_pp )"
	#	publish_to_mqtt_starred "ffmuc/$areaid/alllocalclients" "$string"
	#}

	if [ "$clientcollection" ] ; then
		sort_and_tail_file "$clientcollection" 18 1
		[ "$bVerbose" ] && echo $clientcollection: && cat "$clientcollection"
		if command -v join >/dev/null && [ -r $macidsfile ]; then
			_ccwn_fn="${clientcollection}_with_names"
			 { sort -k 2 "$clientcollection" | join -1 2 -2 1 -a 1 - $macidsfile | sort -r -k 1 | 
			uniq -w 17 | sort -k 2 > "$_ccwn_fn" ; } && [ "$bVerbose" ] && echo "$_ccwn_fn":  && cat "$_ccwn_fn"
			mv "$_ccwn_fn" "$clientcollection"
		fi
		#        awk -F, -v lcount="$_lcount" -v hname="$sTargetHost" 'BEGIN { printf "{*count*:*%s*,*localclients*:[", lcount } { printf comma " {*addr*:*%s*,*name*:*%s*}", $1, ($2=="")?$1:$2 ; comma="," } END { printf "],*host*:*%s*}",hname }' | 
		#	shorten_ethernet_addr_in_json ${bDoAllOfIt:+skip} )
		string2="$( awk -F" " -v id="$areaid" -v lcount="$collectedsumofclients" 'BEGIN { printf "{*count*:*%s*,*id*:*%s*,*localclients*:[", lcount, id } { printf comma "{*addr*:*%s*,*name*:*%s*}", $1 , ($4=="")? $1 : $4 $5 $6 $7 ; comma="," } END { printf "]}" }' < "$clientcollection" |
			shorten_ethernet_addr_in_json ${bDoAllOfIt:+skip} )"
		echo_if_not_quiet "$( echo "$string2 " | tr \* \" | json_pp )"
		publish_to_mqtt_starred "ffmuc/$areaid/alllocalclients" "$string2"		
	fi
fi

set +o noglob # globbing needed for * to work
mv "$tmpdir"/* "$cachedir" ; rmdir "$tmpdir"
find "$cachedir" -maxdepth 1 -path "$cachedir/[0-9]*" -type d -mtime +0 -exec rm -r '{}' \; # remove old debug files

# End of main.

# Old stuff:
# password=$(cat password_file)
# uci set wireless.@wifi-iface[0].encryption=psk
# uci set wireless.@wifi-iface[0].key="$password"
# uci commit wireless
# wifi