#!/usr/bin/env ash
# shellcheck shell=ash disable=SC2086,SC2015,SC2166,SC2155,SC2046

#
# manage_gluon_mqtt
#
# Monitor and control Freifunk nodes (Gluon) or OpenWrt nodes - by command line and MQTT
#
# Repository: https://github.com/sheilbronn/Manage-Gluon-MQTT

# Some fixed constants and preliminary (fixed) settings ...
# semi-hungarian notation for vars: i(n)teger, (s)tring, (d)irectory, (c)ommand, (b)oolean usage, (f)ile, (h)ost, (_) local meaning only

# manage_gluon_mqtt -m localhost -v -c noop,ignore,echo,date,loop,filecopy,wifidown,wifiup,wifistate,limit,ffcond,gluonreconfigure,site,gluondata,speedtest,state,printmap,localclients,nodeinfo,neighbours,statistics,showsite,memory

nWifiSleep=9 # seconds to sleep after "wifi up" 
dGluon=/lib/gluon
fOpenWrt=/etc/openwrt_release
sSite= #  will be set to something like "ffmuc".... but could also be frozen here
fMacIDs=/srv/openhab-conf/phones # file is only for presence detection in mapping known phones to known people at....
fNul=/dev/null
MP=mosquitt\o_pub
LH=localhost
C=comman"d"

cCmv() { command -v "$@" >$fNul ;} # true if a command exists
cLower() { awk -v s="$*" 'BEGIN {print tolower(s)}' ;} # simplified for args only
# set -x ; cLower "AA Bb" ; cExit99
cPid() { sh -c 'echo $$' ;}
# echo TEST: ; cPid ; cPid ; cExit99

if cCmv busybox ; then # prefer busybox for performance, memory usage and compatibility
	alias awk="busybox awk"
	alias sed="busybox sed"
	alias tr="busybox tr"
	alias grep="busybox grep"
	alias xargs="busybox xargs -r"
	alias diff="busybox diff"
fi
	alias T=t\est
	# This avoids the impact of spawning of /bin/echo, in case -e not understood:
	T "$(ec\ho -e)" = "-e" && alias ECHO=ec\ho || alias ECHO="echo -e" # some echo's know -e, some not. 
	alias e=ec\ho # special quoting needed when compressing script for reduced storage
	alias l=loc\al
	alias cntnue=continue # word "continue" to be compressed (outside of awk!)
	alias c=cont\inue
	alias r=ret\urn
	alias p='pri\ntf %s\\n'

alias cX="local - && set +x" # to stop any verbosity locally in a function
alias cS=sleep
alias cIsCmd='T "$cmd" ='
alias cIsOpt='T "$cmdopts" ='
cTrd() { cX ; _r="$(p "${3:-$2}" | tr -d ${3:+$1} "${3:+$2}$(T "$3" || p "$1")" )" ; p "$_r" ; T "$_r" = "${3:-$2}" ;} # delete some chars or their complement (-c) from a string
cR() { T -r "$1" ;} # test if a file is readable
# cR /dev/null && echo yes ; exit 99

# cR() { cX ; "$2" && c=echo || c=: ; -r "$1" && $c "$1(OK)" || $c "$1(MISS)" ;} # test if a file is readable, output to stdout if $2 is set, e.g. -v
# cDebug ; cTrd _- "Aa_Bb" && echo yes; echo ; cTrd -c _- "Aa_Bb" && echo yes; cTrd -c "[a-zA-Z]" "AaBb" && echo yeah; echo ; cExit99
alias cClean='tr -cd A-Za-z0-9_.%,\ -' # remove special, leave spaces and ,._-
cSaniStr() { cTrd -c "/A-Za-z0-9_.%,\ -" "${1:-$OPTARG}" ;}
cSaniNum() { cX ; n="$(cTrd -c 0-9 "${1:-$OPTARG}")" || { echo "$0: ${1:+-$opt }${1:-$OPTARG} must be numerical!" 1>&2 ; return 1 ;} && echo $n ;}
alias cData='T "$ssh_data"'
alias cOut='printf "%s\n" "$ssh_data"'
cCmv ubus && alias cUbus=ubus|| alias cUbus=": ubus"
cRan() { echo $(($(date +%s)-nStartTime)) ;} # seconds passed since start of script
cLine() { cOut | sed -n "$1"p ;} # print line n of ssh_data
cCount() { cX ; _n=0 ; while read x; do _n=$((_n+1)) ; done ; echo $_n ;} # replace wc -l
s() { cX ; T -z "$1" -o "$1" = null -o "$1" = UNKNOWN && echo null || echo "*$1*" ;} # echo only a non-empty string with stars, null otherwise

# Initialize our own variables:
bQuiet=
bLogger=y
bVerbose=${INIT_TRACE:+y} # set it to y to start debugging right from the start
set -o noglob  # set noglob will limit security and escaping problems
sMe=$(cTrd -c A-Za-z0-9_.- "${0##*/}") # script fails on purpose if its name contains white space
sBase=$(p $sMe | sed 's/\..*//')
sMe2="$(cTrd _ $sBase)"
sMID="$sMe2-$$"
sID=$(cTrd -c a-zA-Z0-9 "$sMID") # sanitize the ID
sMeAge=$(date +%Y%m%d%H -r "$(readlink -f "$0")")
sManufacturer=Linux
export ssh_rc=0
export ssh_data=

dUser=$HOME/.$sBase # user-specific data
fHost=/proc/sys/kernel/hostname
sArea="$(cat $fHost 2>$fNul || hostname)"
T "$sArea" || sArea="${sArea}-$( awk -F: '{print$5$6}' </sys/class/net/eth0/address )"
sServer=$sArea
sArea=$(cLower "$sArea") # lowercase only
sSsidBase=UNKNOWN # would be an an error
sPubIfs= # will be determined on first call to every node, then cached
nStartTime=$(date +%s)
nMqttSleep=1199
sHassPrefix=homeassistant
hPubMqtt=test.mosquitto.org
basetopic=xyz  # default MQTT topic prefix
sGrepSsid='.*'

umask -S u=rwx,g=rx,o= # no rights for any others

if T -t 1 -a ! "$NO_COLOR" ; then # only color code on terminals and not when NO_COLOR is set tbd: -a ! "$TERMUX_VERSION" 
	F='\033[' # https://gist.github.com/bcap/5682077#file-terminal-control-sh
	Yellow="${F}33m" ; Cyan="${F}36m" ; Red="${F}41m" ; Green="${F}32m" ; Rst="${F}0m"
	# Reg="${F}22;24m" ; RegF="${F}39m" ; RegB="${F}49m"  # Reset all coloring and style
fi

#BEGIN_DELETE
# set some values and redefine functions for testing (this is assumed when called with 0 or 1 cmd line options)
cDebug() { false debugging ;} # no debugging
T $# -le 0 -o "x$1" = "x-x" && cMS() { cEcho cMS: "$@" ;} && cmd=testing && bVerbose=y && sSite=ffmuc && cMPub=mosquitto_pub && export hMqtt=$LH && ad_devname=testi &&
	cmdopts=99 && ECHO "$Yellow==========$Rst" && alias cDebug='bVerbose=y && bVeryVerbose=y && bQuiet= && bLogger= && bTrace= && : set -x' 
cEcho() { echo "$@" ;} # early temporary definition
cSEP() { cX ; cEcho "==== $1" ;}
cExit99() { cX ; cSEP "TERMINATE Debugging${data:+: data=$data}" ; exit 99 ;}
#END_DELETE

# Notes for future enhancements:
# ping ff node and up/down own public if accordingly
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8ba && echo yes ) || echo no
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8be && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iw dev client0 del ; echo if downed )
# scan repeatedly for public Wifi and up/down own public if accordingly:
# ( { for i in 1 1 1 1 2 ; do iw dev mesh0 scan ; cS $i ; done } | fgrep -w '6e:a3:09:ea:31:e1' && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iw dev $sPubIf0 del ; echo if downed )
# ( { for i in 1 2 2 ; do iw dev mesh0 scan ; cS $i ; done } | egrep -A 9 -w '6e:a3:09:ea:31:e0' | grep SSID:.muenchen.freifunk.net/muc_sued && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iwinfo | grep $sPubIf0 && iw dev $sPubIf0 del ; echo if downed )
# func() { echo yyy ; false ;} ; x="$(func)" && echo yes || echo no ; cExit99

cHelp() {
  echo "Usage: $sMe ... -v -m mqttserver -p -s node -c command ...
   Execute commands on Gluon/Freifunk/OpenWrt nodes using uci and other commands. Returns output on stdout and/or MQTT.
   Either automatic (e.g. key-based) access to the Freifunk node using SSH or remote execution is required.
   Implemented commands:" 1>&2
   _cel='\)(\s*#.*|)$' # = comment extends til eol
  grep -E "^\s*[a-z_|-]+$_cel" "$0" | sed -E -e "s,$_cel,," -e 's,\|, ,g'  | xargs echo # extract commands from this shell script
  }

cSortAndTailFile() { # $1=file $2=col(1) $3=sep $4=lines(40)
	cX
	local fTmp=$dTmp/tf
	local nCol="${2:-1}"

	cR "$1" && T -w "$1" && sort -t "${3:-;}" -k $nCol "$1" | awk -F"${3:-;}" "!seen[\$$nCol]++" | tail -"${4:-99}" | sort -k $nCol > $fTmp &&
			cat $fTmp > "$1" && rm -f $fTmp
	T $bVeryVerbose && dbg "cSortAndTailFile($1,$2,$3,$4): lines: $(cCount <"$1")"
	}

cExpand() { # expand some shortcuts: %w: site, %s: host name of target, %g: intended MQTT group
	T "$*" && awk -v a="$*" "BEGIN {gsub(\"%w\",\"$sSite\",a);gsub(\"%s\",\"$hTarget\",a);gsub(\"%g\",\"$mqttGroup\",a);print a}"
  }
# echo $(cExpand w=%w s=%s g=%g) ; cExit99

_helper() {
		cOut|awk -F= "/^$1=/"' {gsub("\"","");print$2}'
	}
cGetOSData() {
	cX
	if ! _val="$(cCRead .os_data 1)" ; then
		cSsh "cat /usr/lib/os-release" || ssh_data="PRETTY_NAME=unknown
NAME=$(uname -o)
ID=$(uname -s)" 
		# || return $? # cancel func
		if cData ; then
			_val="$(cOut|awk -F= '
				BEGIN { lim="{*os*:{" } END {printf "}}"}
				{ gsub("\"", "*", $2) ; printf lim "*" tolower($1) "*:" $2 ; lim="," }' )" # generate new value
			cCWrite .os_data	"$_val"  # cache new obtained value
			cCWrite .os_pretty_name	"$(_helper PRETTY_NAME)"
			cCWrite .os_name	"$(_helper NAME)"
			cCWrite .os_id	"$(_helper ID)"
		fi
	fi
	p "$_val"
	T "$_val" # return 0 if non-empty
  }

cGetSitecode() { # $1=cachetimeout
	cX
	local data="$(cCRead .site 9)" # site code is quite stable...
	if T -z "$data" -o "$1" ; then
		T "$1" || data="$(cCRead .sitenotfound 1)" # dont do it every time, read a default for the rest of the day
		if T -z "$data" -o "$1" ; then
			if cSsh "[ -d $dGluon ] && jsonfilter -e @.site_code <$dGluon/site.json || echo UNDET" ; then
				data="$ssh_data"
				T "$data" = UNDET && data="$(cCRead .os_id 9)" # || data="$ssh_data" # use a OS ID as site fallback if not on Gluon		
				T "$data" || {
					cGetOSData
					data="$(cCRead .os_id)"
				}
				"$1" || cCWrite .site "$data"
				cCWrite .site "$data"
			else
				data="$(cMostFrequentSite)" #  hack: use the most frequent local standard...
			fi
			"$1" || cCWrite .sitenotfound "$data"
		fi
	fi
	sSite="$data"
	dbg SITE "$sSite ${1:+($1)}"
	}

cMostFrequentSite() {
		cX
		_tmp="$(find $dCache -name \*.site | xargs cat | sort | uniq -c | awk '{print$2;exit}' )"
		e "${_tmp:-UNKNOWN}"
	}

cGetHostname() { # $2=cachetimeout
	cX
	if ! ssh_data="$(cCRead .hostname "${1:-9}")" ; then
		cSsh "tr A-Z a-z <$fHost" || ssh_data="$hTarget"
		dbg cGetHostname "ssh_data=$ssh_data"
		cCWrite .hostname
	fi
	cEcho
	}

cCut() { cut -d"$1" -f${2:-1} $3 ;} # $1=seperator, $2=field(s) or 1, $3=file(s) or other options

cSsidBase() {
		sSsidBase="$(cOut| awk -F\; '{print$2;exit}' | tr -d \" | awk -F": " '{gsub("/.*","",$2); print $2}' )"
	}

cGetPubIF() { # $1=cachetimeout  ## TODO ## -1 for forced reloading
	cX
	sPubIfs=
	sPubIf0=
	sPubIf1=
	if ! ssh_data="$(cCRead .ifs "${2:-9}")" ; then
		cSsh "$C -v iwinfo >$fNul && iwinfo" || { cMqttReply -E ERROR "no iwinfo:" ; return $ssh_rc ;} # only iwinfo works for this
		ssh_data="$( { cOut ; echo "" ;} | awk '/^$/ {if (l~/Mode: Master;.*;Encryption: none/) print l;l="";next} {gsub("^ +",";") ; gsub(" {2,9}",";") ;l=l$0 ;next}' )"
		dbg REMOTE "Interfaces returned: $(cOut | head -10)"
		cSsidBase
		cData && "$sSsidBase" && cCWrite .ifs # ... cache the result only if at least one public Freifunk interface is up and running
	fi
	# set global variables $sPubIfs, $sPubIf0, $sPubIf1 and sSsidBase as side effects...
	sPubIfs="$(cOut | cCut \; | xargs | cClean )"
	if ! T "$sPubIfs" ; then
		sPubIfs=ERROR
		_msg="Public interfaces empty, sPubIfs="
		dbg PUBLIC "$_msg"
		cMqttReply ERROR "$_msg:"
		sSsidBase=
		return $ssh_rc
	fi
	set -- $sPubIfs
	sPubIf0="$1" # 1st interface
	sPubIf1="$2" # 2nd interface if any (e.g. 5 Ghz)
	cSsidBase
	dbg PUBLIC "Interfaces: if0=$sPubIf0,if1=$sPubIf1 (ifs=$sPubIfs), ssidbase=$sSsidBase"
	return 0
	}

# echo :"$IFS":
# h() { local - ; IFS='' ; set -- $@ ; echo $2 ;}
# h "eins zwei" drei
# echo :"$IFS":  ;   cExit99
# cDebug ; d=yy ; h() {  if local d=xx ; ! false ; then echo yes$d ; else echo no$d ; fi ; echo $d: ;} ; h ; echo $d ; cExit99

cTableToJSON() { # table is read from stdin. numerical values are made unquoted. $1: (optional) number of missing headers, e.g. 1 in free -t
	cX
	awk -F "${2:- }" -v missHead="$1" '
		BEGIN { OFS=""
			getline
			NH=NF+missHead # NF: number of fields, NH: number of headers
			for (i=1; i<=NF; i++) names[i+missHead] = $i   # consume all the headers
			printf "["
		} {
			printf lim "{*%s*:{", tolower($1)
			for (i=2;i<=NF||i<=NH;i++) {
				if (i<NH){
					o=$i # take field value as output (be it empty or not)
				} else { # more fields than headers
					if (o>""&&$i>"") o=o" "
					o=o $i # collect extraneous fields into the last field
					if (i<NF) continue
					# now all fields are consumed
				}
				dq=(o ~ /(^-?(0|([1-9][0-9]*))(\.[0-9]+)?$)|^\[.*\]$|^null$/) ? "" : "*"    # put no double quotes around numbers (nor arrays nor the word null)
				printf "*%s*:%s%s" , names[(i>NH)?NH:i] , o=="" ? "null" : dq o dq, (i<NF||i<NH) ? "," : "" # print it
				o=""
			}
			printf "}}"
			lim=",\n"
		}
		END {print "]"} '
  }
  # cDebug ; { echo spalte1 spalte2 ; echo a1 11 12 13 14 15 null; echo b1 2x ; echo c1 null 32; echo d1 ;} | cTableToJSON 1 ; cExit99
  # cDebug ; { echo "spalte1;spalte2" ; echo "a1;11;12;13;14;15;16" ; echo "b1;2x" ; echo d1 ;} | cTableToJSON 1 \; ; cExit99
  # cDebug ; { echo "Head" ; echo "11" ; echo "22" ;} | cTableToJSON 0 ; cExit99

cDelSimpleJsonAttr() { # $1: attr, $2: JSON-string  # but only covers very simple cases, i.e. with quotes or not  :(
    # jq -c "del($1)" <<< "$2"
	# attr="$1"
	#                     a) not the last in the set (,)            b) only one or last in the set
	echo "$2" | sed -E -e "s;\"$1\":(\"[^\"]*\"|[^,}]*)[ ]*,;;" -e "s;[ ]*,[ ]*\"$1\":(\"[^\"]*\"|[^,}]*)[ ]*};;"
	}

cFirstJsonAttr() { # take string and extract the value of the first attribute if JSON, whole string otherwise. eliminate any non-alpha chars
	cX
	local m="$*"
	T "${m#{}" = "$m" && e "$m" && return # non-JSON
	e "$m" | sed -e 's/[,}].*//g' -e 's/[^:]*://' -e 's/[^a-zA-Z0-9]*//g' # ... else JSON
	}
	# cDebug ; x='{ eins:"first" , zwei:second }' ; cFirstJsonAttr "$x" ; cFirstJsonAttr "blabla,bla:blub" ; cExit99 # TEST
	# cDebug ; x=' {"custom_event":{"key":"value","number":123}  }' ; cFirstJsonAttr "$x" ; cExit99 # TEST

cWordsToJsonArray() {
	# cX
	awk 'BEGIN{printf "["} {printf lim "*" $0 "*" ; lim="," } END{printf "]"}'
  }
  # cDebug ; { echo 1 2 ; echo 3 4 ;} | cWordsToJsonArray ; cSEP ; echo -n "" | cWordsToJsonArray ; cExit99
  # cDebug ; { echo 1 2 ; echo 3 4 ;} | xargs -n 1 | cWordsToJsonArray "," ; cExit99

cGetGluonDomainsStarred() {
	cX
	if ! ssh_data="$(cCRead .gluondomains 1)" ; then
		cSsh "ls -1 $dGluon/domains 2>&1" || return $?  # cancel function
		cData && {
			ssh_data="$(cOut | sed -e 's/[^_]*_//' -e 's/.json//')"
			cCWrite .gluondomains
		}
	fi
	cOut | cWordsToJsonArray
  }

cLogger() {
		T $bLogger && { logger -p daemon.$1 -t "$sMe($$,$hTarget)" -- "$2" || bLogger="" ;} # for systems without logger command	
	}
	# cDebug ; cLogger infoxx "blabla" ; cLogger info "blub" ; cExit99

cErr() {
	cX
	_tmp="$1"
	T "$1" = : && _tmp="Failed${cmd:+ for command $cmd}${sSshUser:+ with ssh to $sSshUser}" # default msg is ....
	T "$1" != "${1%:}" && _tmp="${_tmp%:} (rc=$ssh_rc${ssh_msg:+,$ssh_msg})" # if $1 ends in :, then add rc and msg
	shift
	ECHO "${Red}ERROR$Rst:" "$_tmp" "$@" 1>&2
	cLogger error "$_tmp" "$@"
	}
	# cDebug ; cErr "blabla" ; cErr : ; cExit99

cErrAndExit() {
	cX
	cMqttReply OFF "$*."
	cErr "$* ... Exiting."
	exit 1
	}

jFilter=$($C -v jq) || jFilter=$($C -v jsonfilter) || cErrAndExit "jsonfilter or jq needed"
jFilter=${jFilter##*/}

cEcho() { # log and output stuff (in color), unless to be quiet
	cX
	local _o="${*:-$ssh_data}"
	T "$bQuiet" -o -z "$_o" && return
	# FIXME:  [ "$1" = "${1#\{\*}" -a "$1" = "${1#\[\*}" ] && _o="$(cStarredToJSON "$*" | json_pp)"  # expand (only) "starred" pseudo-JSON
	ECHO "$Cyan$_o$Rst"
	cLogger ${bVerbose:+info} ${bVerbose:-debug} "$_o"
	}
	# cDebug ; cEcho -e -e zwei ; cSEP ; cEcho "" ; cExit99

dbg() { # output its args to stderr if verbosity set
	cX
	T $bVerbose && {
		{ T "$#" = 2 && ECHO "$Yellow$1:$Rst" "$2" || ECHO "${Yellow}debug$Rst" "$*" ;
			T $bVeryVerbose && cLogger info "$*" ;} 1>&2
		: # return true if verbose	
	}
	}

cShorten() { # shorten string $1 to at most $2 chars plus some ellipses
	cX
	printf "%.${2:-45}s%s" "$1"
	T ${#1} -gt "${2:-45}" && printf "..."
	}
	# cDebug; cShorten "1234567890" 7 ; cSEP ; cShorten "1234567890" ; cExit99

cPidValid() {  # check $1=pid is a valid PID
	cX
	T -d /proc/$1
	}

cPidPName() { # print name of parent process. If $2 is set, parent name must also match $2
	cX
	_p=$(awk '$1=="PPid:" {print$2}' /proc/${1:-$$}/status)
	_n="$(awk '$1=="Name:" {print$2}' /proc/$_p/status )" # parent name
	echo "$_n"
	T "$2" && T "$2" = "$_n"
	}
	# cDebug ; cPidPName $$ ; cSEP ; cPidPName 1 ; cSEP ; cPidPName 9651 ; cExit99

#  DELETE_BEGIN#
cKillChilds() { # $1=pid, $2=optional parent name, $3=child name using data from /proc ; similar to pkill
	cX
	T "$1" -a -d /proc/$1 || return 1
	T "$2" && { T $2 = "$(awk '$1=="Name:" {print$2}' /proc/$1/status )" || return 1 ;}		
	set +o noglob
	cpids="$(awk -v pid=$1 -e '$2==pid && $1=="PPid:" {split(FILENAME,f,"/") ; printf "%d ", f[3] ; system("kill "f[3]" 1>&2")}' /proc/*/status)"
	set -o noglob
	dbg KILLCHILDS "pid=$1,cpids=$cpids."
	# T "$cpids" && kill $cpids # a race condition in between should be hardly achievable
	_rc=$?
	return $_rc
	}
	# cDebug ; bVerbose=y ; cKillChilds $1 ; cSEP ; cKillChilds $1 xxxx ; cSEP ; cKillChilds $1 ${2:-autossh} ; cExit99
	: || cKillChilds 9999
#  DELETE_END#

for d in /var/log $TEMP $TMPDIR /tmp /data/data/com.termux/cache ; do # find a suitable writable dir. Prefer /var/log over /tmp on openhabian (because of zram).
	d=$(readlink -f $d 2>$fNul) && T -d $d || cntnue # && T -w $d || cntnue # not quoted on purpose!
	dCache=$(cTrd -c A-Za-z0-9_.-/ "$d/$sBase.$(id -nu)" ) # ensure a good dir name
	dTmp=$dCache/$$ # ... and make it unique by adding the PID
	dbg dTmp $dTmp
	T -d $dCache || { mkdir -p $dCache 2>$fNul && chmod o-rwx $dCache ;} && mkdir $dTmp && break || id # ... && chmod o-rwx $dTmp
done
cd $dTmp || cErrAndExit "Problematic temp dir $dTmp in $dCache"

trap_EXIT() {
	set +x
	dbg TRAP_EXIT "cleaning up $dTmp (rc=$?)" && ls -lA "$dTmp" | tail -n +2
	cd "$dCache" || exit 2
	# T $bVerbose ] && ls -alt "$dCache" | head -15
	T -d $dTmp && { # could have been deleted already
		find $dTmp -mindepth 1 -exec mv ${bTrace:+-v} '{}' . \; # move all leftover files from below dTmp to dCache
		rmdir $dTmp
	}
	find . -maxdepth 1 -path "./[0-9]*" -type d -mtime +3 -exec rm -r '{}' \; # remove old debug dirs
	# _ran=$(cRan) 
	# T $nSeconds && {
	# 	_bd=$(cCRead bridgedelta) ; _bd=${_bd:-0}  # read the time passed since the last bridge
	# 	_over=$((_ran-nSeconds+1)) # one second more to be sure
	#  	T $_over -ge 0 && {
	# 		# T $_over -lt $_bd && _over=0 # do not count the time passed during the bridge
	# 		cCWrite bridgedelta $_over
	# 	}
	# }
	[ $bQuiet ] || [ $(cRan) -gt 3 ] && cMqttReply OFF "END(ran=$(cRan),pid=$$${nSeconds:+,nSeconds=$nSeconds})"
}
trap trap_EXIT EXIT

cStoreWrite() { # write a key/value pair to a dir: key,value,dir,filesuffix # if key starts with "." prefix the hTarget
	cX
	_dir="$3"
	_f="$_dir/$(T "${1#.}" = "$1" || e $hTarget)$1"
	_t=WRITE
	T "$1" || {
		e "$_t: #INVALIDPARAM#"
		cErrAndExit "$_t($1, \"$2\", $_dir) = #INVALIDPARAM#"
	}
	mkdir -p $_dir && echo "$2" > "$_f"
	_rc=${?#0}
	dbg $_t "($1,\"$2\"$(T "$3" != "$dCache" && e ",$3"))${_rc:+ = $_rc}" # more debug data, only if unusual or unsuccessful
	T "$_rc" && # FIXME komischer Code
	return ${_rc:-0}
  }
cUserWrite() {  # write a key/value pair permanently across script invocations
		cStoreWrite "$1" "$2" $dUser
	}
cCWrite() { # write a key/value pair to be cached across script invocations from the same user
		cStoreWrite "$1" "${2:-$ssh_data}" $dCache
	}
	# cDebug ; cCWrite test1 shouldnotfail ; ls -al $_f ; cCWrite "" shouldfail ; cExit99

cStoreRead() { # read key/value pair from cache or user storage  (1:key, 2:cachetime, 2: filesuffix, 3:dir)
	cX
	local _fn="$3/$([ "${1#.}" = "$1" ] || e $hTarget)$1"
	local _nMin=$([ "$2" = 0.1 ] && e 58 || e $((${2:-2}*60*24-5)) ) # default 2 days,  0.1=1 hour=59 minutes
	local _res="#NOTFOUND#" # cache is invalid or non-existent
	local _val=""
	local _deloutput

	if cR $_fn ; then
		T "$4" = cache && _deloutput="$(find $_fn -mmin +"$_nMin" | head -1 | xargs -r -t rm 2>&1)" # cache invalidated after n days and remove file
		if T -z "$_deloutput" ; then
			_val="$(cat $_fn)" && _res="#OK#"  # read cache file successfully
			T "$_val" || _res="#EMPTY#"
		fi
	fi
	dbg READ "(${_fn#"$dCache/"},$2)=\"$(cShorten "$_val")\"$(T "$_res" != "#OK#" && e "($_res)")"
	p "$_val"
	T "$_val" # return 1 if empty, 0 otherwise
  }

cUserRead() { # read a user-specific key/value pair across script invocations
	cX
	cStoreRead "$1" "$2" $dUser
  }
  # cDebug ; cUserRead myhosts ; cUserRead myhosts ; cExit99

cCRead() { # read a key/value pair to be cached across script invocations from the same user; empty cache after $2=n day(s)
	cX
	cStoreRead "$1" "$2" $dCache
  }
  # cDebug ; dCache=/var/log/manage_gluon_mqtt.openhabian ; cCRead herkules.site && echo true ; cSEP ; cCRead herkules.neighbours ; cS 1 ; cExit99
  # cDebug ; dCache=/var/log/manage_gluon_mqtt.openhabian ; cCRead noneexistingfile.none && echo true ; cExit99
  # cDebug ; dCache=/var/logxxxx/manage_gluon_mqtt.openhabian ; cCRead xyz.none 0.1 ; cExit99

cFilter() {  #  cFilter(filterexpr,moreparam), filterexpr is a jq or jsonfilter expression
	# cX
	case "$jFilter" in
	jsonfilter)
		data="$(jsonfilter -e "@$1" "${2:---}" )" # -- if $2 empty
		;;
	jq)
		data="$(p "$2" |jq -r "$1")"
		;;
	*)
		cErrAndExit "\$jFilter is undefined"
	esac
	# p "$_data"
  }
  # cDebug ; cFilter .addr '{ "addr": "addr_999\\n" }' ; cExit99

cGetMacVendor() { # $1=mac address
	cX
	local _mac="$(cLower "$1" | tr - : )" #  allow for ":" or "-" in mac adresses
	local _short="${_mac%:*:*:*}" # only first 3 bytes (=OUI) of the mac address = delete last three bytes
	local _vd="$(cCRead "mac-$_short.vendor" 9)" # try to find result in cache
	if T -z "$_vd" ; then
		_vd="$(wget -q -O - "https://api.macvendors.com/$_mac")"
		_vd="$(cTrd -c "A-Za-z0-9_.%, -()" "${_vd:-null}" | cCut " " 1-7)" # only first n words of the vendor name
		cCWrite "mac-$_short.vendor" "$_vd"
	fi
	echo "$_vd"
	}
	# cDebug ; cGetMacVendor 38:B4:d3 ; cGetMacVendor  Aa:87:0b:24:61:b3 ; cGetMacVendor  A4:2A:95:45:20:B6 ; cExit99
	# cDebug ; cGetMacVendor 6e:95:18:16:87:58 ; cGetMacVendor  Aa:87:0b:24:61:b3 ; cGetMacVendor F0-8A:76:A9:57:80 ; cExit99
	# cDebug ; for m in $(arp -a| cut -d " " -f 4 | grep : ) ; do cGetMacVendor "$m" ; cGetMacVendor "$(p $m | sed 's/..:..:..$/00:00:00/' )" ; cSEP ; done ; cExit99
	# cDebug ; for m in $(arp -a| cut -d " " -f 4 | grep : ) ; do echo $m ; wget -q -O - "https://api.macvendors.com/$(p $m | sed 's/..:..:..$/00:00:00/' )" ; echo " " ; cSEP ; done ; cExit99

shorten_ethernet_addr_in_json() { # remove some bytes für anonymization
	T "$1" && cat && return 0
	sed -E -e 's/([*"][a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]:)[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9](:[a-f0-9][a-f0-9][*"])/\1..\2/g' "$@"
	}

cProbe() { # returns 0 if command should be executed and 1 if not, and 255 if last ssh connection failed
	cX # any local command line command is always trusted for now:
	T "$cmdsToDo" != bridge && { T $ssh_rc = 255 && return 255 || return 0 ;} # if node wasn't reachable (255) don't try again
	T "$hMqtt" != $LH && { cEcho "Untrusted MQTT $1 command .$cmd. ignored for .$hMqtt." ; return 1;} # for now: only trust commands from a MQTT broker on the same host.
	return 0 # FIXME: covered by catchall
	}
alias cProbeGET="cProbe GET || cntnue"
alias cProbeSET="cProbe SET || cntnue" # FIXME: logic not implemented consistently
alias cProbeNOMQTT="{ cProbe NOMQTT || cntnue ;}" # FIXME: covered by catchall

cStackCmd() { cX ; cmdsToDo="$1${cmdsToDo:+,$cmdsToDo}" ; dbg STACKCOMMAND "$1 ($cmdsToDo) from $cmd" ; : ;}
cIsNonGluon() { [ "$(cCRead .nodeip 9)" = NONGLUON ] ;} # return 0 if non-gluon, 1 if gluon or unknown # FIXME: not strong enough for detection

bMosqFile=$( cR $HOME/.config/$MP && echo yes)

cMqtt() { # cMqtt(topic,msg, options) # expanding a leading / in topic to $sSite/$hTarget/
	cX
	T "${cMPub:-:}" = : && return
	local _o=
	local _comp="" && T "$3" = "-M" && _comp=y || _o="$3"
	local _topic="$1"
	T "$1" != "${1#/}" && _topic="$sSite/$hTarget$1" # ... expand shortcut starting with "/"
	dbg MQTT "$Green$_topic$Rst $2  ${3:+OPT=$3}${bVeryVerbose:+ (hMqtt=$hMqtt;hTarget=$hTarget)}"
	T "$_comp" -a "$bModified" && _f="mqtt.$(p $_topic|cClean)" && _pv="$(cCRead $_f 0.1)" && T "$_pv" = "$2" && return 0 # ... skip if value is unchanged
	for h in $hMqtt ; do
		#  passing $3 without quotes on purpose:
		$cMPub ${h:+-h $h} ${sMID:+-i $sMID} -t "$_topic" -m "$2" -i "${sSite}_$hTarget" $_o  || dbg "$cMPub(host=$h): rc=$?"
	done && T "$_comp" -a "$bModified" && cCWrite ".$_f" "$2" # ... cache the message
	true
  }
  # cDebug ; cMqtt ss/tt mm ; cMPub=mosquitto_pub ; export hMqtt=$LH ; cMqtt sss/ttt mm ; cExit99
  # cDebug ; cMPub=mosquitto_pub ; export hMqtt=$LH ; echo ==1== ; cMqtt hhh mmm -M ; echo ==2== ; cMqtt hhh mmm -M ; echo ==3== ; cMqtt hhh mm2 -M ; cExit99

cStarredToJSON() { # ...  replace double quotes by single quotes and stars by double quotes
	awk -v a="${*:-$data}" 'BEGIN {gsub("\"","'\''",a) ; gsub("*","\"",a) ; print a }' # " => ' , then * => "
	}
	# cDebug ; cStarredToJSON "{*a*:0}"  ; cExit99

cMqttStarred() {   # cMS(expandableTopic,message,moreMosquittoOptions)
		cX
		T "$hMqtt" -o "$homie" -o "$bMosqFile" && T "$cMPub" != : &&
			cMqtt "$1" "$(cStarredToJSON "${2:-$data}")" "$3" 
	}
	alias cMS=cMqttStarred

cMqttReply() { # $1=status $2_reply $3=moreopts|-M. 
		# If $2 is empty, use "$_cmd($cmdopts) failed:". 
		# If $2 ends in a colon, append ssh_rc and ssh_msg.
		cX
		T "$1" = "-e" && shift && cErr :
		T "$1" = "-E" && shift && cErr "$2"
		T "$hMqtt" || return 0
		local _cmd="${cmd%%[0-9]*}" # clean any trailing digits from the MQTT command
		local _ms="${2%:}" # remove trailing colon
		_ms="${_ms:-$_cmd($cmdopts)}" # if $2 empty, only use "$_cmd($cmdopts)"
		T "$1" = ERROR && _ms="$_ms failed:" # if $1=ERROR  and  $2,$3 empty
		if T "$_ms" != "${_ms%:}" ; then
			T "$1" = ONGOING && _ms="${_ms:+$_ms. }Doing $_cmd($cmdopts)."   ||
				_ms="${_ms%:} (rc=$ssh_rc${ssh_msg:+,$ssh_msg})"
		fi
		cMS ${_cmd:+/$_cmd}/log "{*status*:*$1*${_ms:+,*details*:*$_ms*}${3:+,$3}${fPipe:+,*pid*:$$}}" $3
		T "$1" != OK -a "$1" != ONGOING && cLogger info "$1: $_ms $3"
		dbg REPLIED "$1: $_ms : $3"
	}
	alias cMR=cMqttReply
	# cDebug ; for t in "" ":" ; do cMR ONGOING "Rushing$t" ; cSEP $t ; cMR OK "Okidoki$t" ; cSEP $t ; cMR ERROR "$t" ; cSEP ===$t ; done ; set +x ; cExit99
	# cDebug ; cMR ERROR ; set +x ; cExit99
	# cDebug ; cMR ONGOING : ; cSEP ; cExit99
	# cDebug ; cMR -e ERROR "blabla:" ; cExit99

cMqttBeacon() {
	_pubcmd="$cMPub -h $hPubMqtt" # caution: Freifunk/Gluon seems to need IPV6 connectivity, not all brokers have it!
	# _pubcmd="$cMPub -h broker.hivemq.com"
	_topic="\"$sSite/\`tr A-Z a-z < $fHost\`/installation\"" # tr shall run on the remote node with apostrophes!
	dbg BEACON "$_pubcmd $_topic"
	cSsh "$_pubcmd -t $_topic -r -m TEST_$cmd"
	_rc=$ssh_rc
	if T $_rc != 0 ; then
		cErr "$_pubcmd -t $_topic -r -m TEST_$cmd failed with $ssh_rc ($ssh_msg) on remote node (check why!)"
	else
		dbg BEACON "$_pubcmd $_topic succeeded, now removing this (retained) msg again..."
		cSsh "mosquitto_sub -h $hPubMqtt -t $_topic -v -C 1 -W 5 --remove-retained"
	fi
	return $_rc
}

# Parameters for cHassAnnounce:
# $1: MQTT "base topic" for states of all the device(s), e.g. "rtl/433" or "ffmuc"
# $2: Generic device model, e.g. a certain temperature sensor model
# $3: MQTT "subtopic" for the specific device instance,  e.g. $model/$id. ("..../set" indicates writeability)
# $4: Text for specific device instance and sensor type info, e.g. "($id) Temp"
# $5: JSON attribute carrying the state
# $6: device "class" (of sensor, e.g. none, temperature, humidity, battery),
#     used in the announcement topic, in the unique id, in the (channel) name,
#     and FOR the icon and the device class
# Side effects using global variables:
# $sID:    , $sManufacturer: ... used in device description
# Examples:
# cHassAnnounce "$basetopic" "Rtl433 Bridge" "bridge/state"  "(0) SensorCount"   "value_json.sensorcount"   "none"
# cHassAnnounce "$basetopic" "Rtl433 Bridge" "bridge/state"  "(0) MqttLineCount" "value_json.mqttlinecount" "none"
# cHassAnnounce "$basetopic" "$model" "$model/$id" "($id) Battery" "value_json.battery_ok" "battery"
# cHassAnnounce "$basetopic" "$model" "$model/$id" "($id) Temp"  "value_json.temperature_C" "temperature"
# cHassAnnounce "$basetopic" "$model" "$model/$id" "($id) Humid"  "value_json.humidity"       "humidity"

# cHassAnnounce "ffmuc"  "$ad_devname" "$node/publi../localcl.."     "Readable Name"  ""   "$icontype"
# cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set"      "Radio channel 2.4GHz" "" "counter"
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort/set" "Public SSID Short"  "" "wifi"  # 5: value_json.count
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"          "Public SSID"        "" "wifi"  # 5: value_json.count
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "" "counter"
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" "switch"

cHassAnnounce() {
	cX
	dbg cHassAnnounce "$*"
    local _topicpart="${3%/set}" # if $3 ends in /set it is settable, but remove /set from state topic
    # local _name="$(p "${2:+$2-}$4" | tr " " "-" | tr -d "[)()]/" )"
    local _dev_class="${6:-none}"
	local _state_class
	local _jsonpath
	local _jsonpath_red
	local _value_template_str
    if T "$5" ; then
		_jsonpath="${5#value_json.}" #  "${_jsonpath//[ \/-]/}"
		_jsonpath_red="$(cTrd "][. /-_" "$_jsonpath")"    # cleaned and reduced, needed in unique id's
		_value_template_str=",*value_template*:*{{ $5 }}*"
		local _devid="${_topicpart##*/}" # take the last part of the topic as device id
		local _configtopicpart="$(cTrd "][ /-" "$_topicpart")"
		local _dev_unique_id="$sMe2$2" #   ="${sID}$2"
	    local _dev_name="$2 ${_devid}" # "$2 ${_devid^}"
	else
		local _devid="$2"
		local _configtopicpart="$(cLower "$_topicpart" | tr -d "][ /-" )"
		local _dev_unique_id="${sMe2}$2" # remove the trailing process-id
	    local _dev_name="$2"
    fi
	_topic="${sHassPrefix}/sensor" 
    local _sensortopic="${1:+$1}${2:+/$2}$_topicpart"
	# local *friendly_name*:*${2:+$2 }$4*,

    local _unit_str=""
    # local _channelname="$_dev_name ${_dev_class}" # ${_dev_class^}"
   	local _channelname="$_dev_name $4" # take something meaningfull
    case "$_dev_class" in
        temperature*|dewpoint)	_unit_str=",*unit_of_measurement*:*°C*"	; _state_class=measurement 
						_dev_class=temperature ;;
        humidity)		_unit_str=",*unit_of_measurement*:*%*"	; _state_class=measurement ;;
        counter)		_unit_str=",*unit_of_measurement*:*#*"	; _state_class=total ;; # UOM must have a content to trigger recognition as a number on OpenHab
		clock)			_icon_str="*icon*:*mdi:clock-outline*" ;;
		wifi)			_icon_str="*icon*:*mdi:wifi*" 
						_dev_class="" ;;
        switch|binary_sensor)	_icon_str="*icon*:*mdi:toggle-switch*"
						_topic="${sHassPrefix}/$_dev_class"  ; _dev_class=""
						;;
		string|none)			_icon_str="" ; _dev_class="" ;;
        # battery*)     _unit_str=",*unit_of_measurement*:*B*" ;;  # 1 for "OK" and 0 for "LOW".
    esac
	_topic="$_topic/$1${_configtopicpart}$_jsonpath_red/config" # _dev_class removed
	_icon_str="${_icon_str:-*icon*:*mdi:mdi-$_dev_class*}"  # mdi icons: https://cdn.materialdesignicons.com/5.4.55/
	_command_topic_str="$( T "$3" != "$_topicpart" && echo ",*cmd_t*:*$_sensortopic/set*" )"  # determined by suffix ".../set"

	local _dev_model="$2$( T "$2" != "$_devid" && echo " on channel $_devid" )"
    local _device_string="*device*:{*identifiers*:[*$_dev_unique_id*],*manufacturer*:*$sManufacturer*,*model*:*$_dev_model*,*name*:*$_dev_name*,*sw_version*:*$sMe*}"
    local _msg="*name*:*$_channelname*,*state_topic*:*$_sensortopic*,$_device_string${_dev_class:+,*device_class*:*$_dev_class*}"
	_msg="$_msg,*unique_id*:*${sMe2}${_configtopicpart}$_jsonpath_red*${_unit_str}${_value_template_str}${_command_topic_str},$_icon_str${_state_class:+,*state_class*:*$_state_class*}"

   	cMS "$_topic" "{$_msg}" "-r" # publish retained announcement
  }

cMqttSub() {
		mosquitto_sub ${hMqtt:+-h $hMqtt} ${sMID:+-i $sMID} "$@" || # would fail when used with multiple hosts...
			dbg ERROR "mosquitto_sub to $hMqtt terminated/failed." 
	}

cHomieReady() {
		cX
		_ret="$(cMqttSub -W 2 -C 1 -t "homie/$1/\$state" 2>$fNul)"
		T "$_ret" = ready # return 0 if matching ready
	}

hLine() {
		T "$homie" -a ! "$bHassOnly" -o "$1" = \$state && cMqtt "homie/$homie/$1" "$2" "$3" || true
	}

hMeta() {
		cX
		dbg hMeta "($1,$2,$3)"
		local _msg="$2" ; T $bDeleteAnnouncement && _msg="" # bDeleteAnnouncement used in an intended side effect from this global var
		local _topic="$(p "$1" | sed -E -e 's,([^/]*)$,$\1,' )" # ... insert a $ before last part of topic

		hLine "$_topic" "$_msg" -r
	}

hMulti() { # 1: topic, 2: name, 3: retained, 4: settable, 5: datatype, 6: unit, 7: format
		# cX
		# hMulti publicwifi/clientscount "Public WiFi client count" false "" integer "#" "-1:9999"
		# dbg2 "hMulti($1,$2,$3,$4,$5,$6)"
		o="$1"
		if T $bDeleteAnnouncement ; then
			cHassAnnounce "" "$ad_devname" "homie/$hTarget/$o" "$2"  ""  sensor
		else
			_sensor=sensor
						hMeta $o/name "$2"
			T "$3" && hMeta $o/retained "${3:-true}"  # default: true
			T "$4" && hMeta $o/settable "${4:-false}" # default: false
			T "$5" && {
				hMeta $o/datatype "$5" 
				T "$5" = boolean && _sensor=binary_sensor
				T "$5" = integer && _sensor=counter
			}
			T "$6" && hMeta $o/unit	"$6"
			T "$7" && hMeta $o/format	"$7"

			cHassAnnounce "" "$ad_devname" "homie/$homie/$o$( T "$4" = true && echo "/set" )" "$2" "" $_sensor
			# cHassAnnounce "" "$ad_devname" "$sSite/$hTarget/statistics"         "Public Wifi RX bytes"   "value_json.traffic.rx" "counter"
			# cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi TX bytes"   "value_json.traffic.tx" "counter"
		fi
	}
	# BEGIN_DELETE
	false cDebug && { 
		# mosquitto_sub   -v  -t homie/# -t homeassistant/# -v -v -v  -W 3 --retained-only --remove-retained
		cSEP HMULTI
		homie=testi
		hMulti radio/channel24 "Radio channel 2.4" false "" integer ""  "1:13" 
		cSEP HASSANNOUNCEs
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" switch
		cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set" "Radio channel 2.4GHz" "" counter
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort" "Public SSID Short"  "" string # MUST: String statt wifi, kein /set
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"      "Public SSID"        "" wifi
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "value_json.count" counter # 5: value_json.count
		cExit99
	}
	# END_DELETE

cBothMqtt() {
		cMS		"/$1" "$2" "$3"
		hLine	"$1" "$2" "$3"
	}

cEchoPub() {
		cEcho	"$2"
		cBothMqtt "$cmd/$1" "${3:-$2}"
	}

cDisco() { # $1: <homie-host>,  $2: "-d" if retained advertisements are to be deleted.
	# NB: $hTarget and optionally $bDeleteAnnouncement must have been set!

	local -
	local _nDay="$(cCRead .AnnounceDay 999)"

	if T "$2" = "-d" -o "$bDeleteAnnouncement" ; then
		cMqtt "debug/$1" "DELETE ANOUNCEMENTS BEGIN: $1,bDeleteAnnouncement=$bDeleteAnnouncement"
		bDeleteAnnouncement=yes # used in side effect in hMeta, will be resetted further down

	    _tops="-t homie/$homie/# -t $sHassPrefix/sensor/# -t $sHassPrefix/switch/#" 
		dbg "Removing announcements with '$_tops' (timeout ok)"
		cMqttSub -W 1 $_tops --remove-retained --retained-only >$fNul
		_rc=$?
		T "$_rc" -ne 0 -a "$_rc" -ne 27 && dbg "Removal of retained topics '$_tops' returned $_rc"
		
		cMS "$sSite/$1/state" "{*event*:*cleaned*,*note*:*removed announcements related to $sHassPrefix/... and homie/... *}"
	else
		# cMqtt "debug/$1" "MQTT ANOUNCEMENTS BEGIN (arg2=$2)"
		T "$sSshUser" = LOCAL && { hLine \$stats/uptime "$(cCut . </proc/uptime)" ;}
		# cHomieReady "$1" ; echo DEBUG: $?
		if T "$_nDay" && T "$(date +%j)" -eq "$_nDay" && cHomieReady "$1" ; then
			dbg cDisco ": skip announcements, homie state is ready... " # (re-)announce ONLY IF restart or new day or necessary
			return 0
		fi
		os_data="$(cGetOSData)" ||
			{ dbg cDisco "Warning: No OS Data obtainable" ; return 1 ;} # abort

		dbg cDisco ": WILL ANNOUNCE ... (arg1=$1,arg2=$2"
		ad_devname="$1" # "$(p "$1" | awk '{print toupper(substr($i,1,1)) substr($i,2) }')"
		ad_fwid="$(cCRead .os_id 9)"
		ad_fwname="$(cCRead .os_name 9)"
		ad_fwversion="$(cCRead .os_pretty_name 9)"
		ad_impl="$(cCRead .os_id 9)"
		dbg cDisco "($1,$2): announcing ad_devname=$ad_devname,ad_fwname=$ad_fwname,ad_fwversion=$ad_fwversion,ad_impl=$ad_impl"

		# https://www.home-assistant.io/docs/mqtt/discovery/
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" switch
		cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set" "Radio channel 2.4GHz" "" counter
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort/set" "Public SSID Short"  "" wifi
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"      "Public SSID"        "" wifi
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "value_json.count" counter # 5: value_json.count
		# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort2/set"    "Public SSID StateTesti2"   "" wifi
		# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/lastdate"    "Last date wifi check" "" clock
	fi
	hMeta homie 3.0.1
	hMeta state init
	hMeta name  "$ad_devname"

	T "$ad_fwname"    -o "$2" && hMeta fw/name        "$ad_fwname"
	T "$ad_fwversion" -o "$2" && hMeta fw/version     "$ad_fwversion"
	T "$ad_impl"      -o "$2" && hMeta implementation "$ad_impl"
	
	sManufacturer="$ad_fwversion"

	# hMeta $1 "stats/interval" 600
	# hMulti() { # 1: name, 2: retained, 3: settable, 4: datatype, 5: unit, 6: format }
	# Defaults are ... settable=false   retained=true
	hMeta nodes		"radio,publicwifi,gluondata"

	hMeta radio/name       "Wifi Radio"
	hMeta radio/type       "Wifi Radio Hardware"
	hMeta radio/properties "channel24"
	hMulti radio/channel24         "Radio channel 2.4"        false "" integer ""  "1:13"

	hMeta publicwifi/name       "Public Wifi"
	hMeta publicwifi/type       "Public Wifi Network"
	hMeta publicwifi/properties "clientscount,state,ssidshort,ssid"
	hMulti publicwifi/clientscount "Public WiFi client count" false "" integer "#" "-1:9999"
	# hMulti publicwifi/lastdate "Last date sent" false "" DateTime "" ""
	hMulti publicwifi/state        "Public WiFi state"        "" true boolean "" ""

	if _gluondomains=$(cCRead .gluondomains 9) ; then
		_wifi_domains="$(cTrd "][*" "$_gluondomains" | awk -F= '{ printf lim $1 ; lim="," }' )" # rough hack...
		dbg wifi_domains "$_wifi_domains"
			# 1: root, 2: name, 3: retained, 4: settable, 5: datatype, 6: unit, 7: format
		hMulti publicwifi/ssidshort "Public WiFi short SSID" false true enum "" "$_wifi_domains" # rough hack...
	else
		hMulti publicwifi/ssidshort "Public WiFi short SSID" false "" string "" ""
	fi
		hMulti publicwifi/ssid      "Public WiFi SSID"       false true string "" ""

	hMeta gluondata/name       "Node Data"
	hMeta gluondata/type       "Gluon Data"
	hMeta gluondata/properties "autoupdater-branch,autoupdater-enabled,gluon-version,release,model,core-domain,gluon-domains"
	hMulti gluondata/autoupdater-branch "Autoupdater Branch" false "" string "" ""
	hMulti gluondata/autoupdater-enabled "Autoupdater Enabled" false "" boolean "" ""
	hMulti gluondata/gluon-version "Gluon Version" false "" string "" ""
	hMulti gluondata/release "Local Release" false "" string "" ""
	hMulti gluondata/model "Hardware Model" false "" string "" ""
	hMulti gluondata/core-domain "Core Domain" false "" string "" ""
	hMulti gluondata/gluon-domains "Gluon Domains" false "" string "" ""
	hMeta state ready

	cMqtt "debug/$1" "HOMIE/HASS ANOUNCEMENTS END (bDeleteAnnouncement=$bDeleteAnnouncement)"

	bDeleteAnnouncement= # end of side effect
	cCWrite .AnnounceDay "$(date +%j)" # support reducing re-announcements to only once per day
  }
  # cDebug ; homie=testiio ; cDisco "$homie" ; cExit99

cAddSuccHost() {
	T $ssh_rc = 0 && nHosts=$((nHosts+1)) && sHosts="$sHosts $hTarget" # ... since we were successful
  }

# cDebug ; cSsh() { ssh_data="$(eval "$*")" ;} ; cGetOSData ; cExit99

# OPTIND=1   # reset to 1 in case getopts had been processed previously in this shell.
# Initialize more variables
bDoAll=
commands= # commands="mesh-id"
sUciQuery=
sUciVal=
cMPub=mosquitto_pub

cCmv $cMPub || { cMPub=":" ; dbg "Variable/command cMPub=*$cMPub* (: is dummy)." ;}
cCmv stdbuf && SB="stdbuf -oL" || dbg WARNING "stdbuf not installed. Delays possible!!" # SB="" # to avoid buffering of stdout
SB=""
cCmv json_pp || alias json_pp=cat
# alias cBeautify="jq -Sm" ; cCmv jq || alias cBeautify=cat

T $# = 0 && { cHelp 1>&2 ; exit 1 ;} # at least one parameter on the command line is required

while getopts "?h:GE:vxql:as:pPR:f:Mm:g:n:c:C:S:o:w:" opt   # https://wiki.bash-hackers.org/howto/getopts_tutorial
do
    case $opt in
    \?) cHelp 1>&2
		T "$cMPub" = : && cErrAndExit "$MP is not installed (run \"-c install\"!)"
        exit 1
        ;;
    h|s) hAll="$OPTARG" # one or more nodes: "host1,host2,host3" (without double quotes)
		T $opt = h && dbg WARNING "Option -h will be deprecated, use -s instead."
		if T "$OPTARG" != "${OPTARG%+*}" ; then # substitute '+' for a set of predefined hosts in $dUser/myhosts.persist
			_tmp="$(cUserRead myhosts)" || cErrAndExit "config for host collection is missing: $dUser/myhosts.persist"
			hAll="$(p "$hAll" | sed "s/+/$_tmp/g" )" # replace +
			bWorkAllClients=yes
		fi
		hAll="$(cLower "$hAll" | tr -s , " " | tr -cd '\ A-Za-z0-9_.%,@-' )"
		dbg HOSTS "$hAll"
		if T "$hAll" != "${hAll% -*}" ; then # some host with "-" prefix given, not at the front
			# generously remove any host prefixed with "-" from hAll:
			hAll="$(echo $hAll | awk '{
				for (i	=1;i<=NF;i++) { if ($i ~ "^-+") { gsub("^-","",$i) ; x[$i]=1 } }
				for (i=1;i<=NF;i++) { if (!x[gensub("-.*","","",$i)] && !x[$i]) {printf $i" "} 				} 
			  }')"
			dbg FFHOSTSREDUCED "$hAll"
		fi
        ;;
    G) T $nGiveHost && nGiveHost=2 || nGiveHost=1 # file descriptor to send output to: -G = stdout, -G -G = stderr
		;;
	E) nMaxGoneDays="$(cSaniNum)" || exit 1
		;;
    v) T $bVerbose && bVeryVerbose=yes && nMqttSleep=60 # not to small to allow for gathering state in between !
		T $nMqttSleep -gt 295 && nMqttSleep=295 # reduce to max 5 minutes when verbose
		bVerbose=yes
		dbg START "USER=$dUser TMP=$dTmp ($(date +%T))"
		;;
	x) bVerbose=yes && bTrace=yes
		set -o xtrace
        ;;
	l)  ;;
	q) bQuiet=yes
		;;
	a) T $bDoAll && bDoExperiment=yes # set after -a -a ...
		bDoAll=yes
		;;
	M) bModified=yes
		;;
	m)	T $cMPub = : && cErr "$MP is missing!"
		case "$OPTARG" in     # see http://www.steves-internet-guide.com/mqtt-hosting-brokers-and-servers/
		-)	_m=$LH ;;
		test)	_m=$hPubMqtt ;;
		eclipse) _m="mqtt.eclipseprojects.io"   ;;
        hivemq)	_m="broker.hivemq.com"   ;;
        emqx)	_m="broker.emqx.io"   ;;
		dash)  _m="broker.mqttdashboard.com"    ;; # https://moxd.io/2015/10/17/public-mqtt-brokers/
		*)	_m="$(cSaniStr | tr , " ")" ;; # clean up for sec purposes, allow comma to seperate multiple hosts
		esac
		hMqtt="${hMqtt:+$hMqtt }$_m"
		;;
	g) mqttGroup="$(cSaniStr)"
		;;
	p|P) homie=yes ; T $opt = p && bHassOnly=yes
		T $cMPub = : && cErrAndExit "$MP is not installed, but -$opt was requested"
		;;
	R) sArea="$(cSaniStr)"
		;;
	f) fFile="$(cSaniStr)"
		dbg FILE "$fFile"
		;;
	n) sExtraOption="$(cSaniStr)"
		sGrepSsid="$OPTARG"
		;;
    c) commands="$OPTARG" # one or more, comma-separated command to be executed
		T $cMPub = : && expr match "$OPTARG" bridge >$fNul && cErrAndExit "$MP not installed"
        ;;
	C) nExitAfter="$(cSaniNum)" || exit 1 # exit after receiving nn MQTT commands
		;;
	S) nSeconds=$(cSaniNum) || exit 1
		;;
    o) sUciQuery="$OPTARG"
		commands=uciquery+"$sUciQuery"
		;;
    w) sUciVal="$OPTARG" ; commands=uciwrite
		# echo sUciVal="$sUciVal"
        ;;
	*) cErrAndExit "Option -$opt not implemented"
		;;
    esac
done

shift "$((OPTIND-1))"   # Discard the options parsed so far and leave the rest of the cmd line...

# T $bQuiet	|| alias cEcho=": cEcho"
T $bVerbose || alias dbg="false dbg"
T $bVeryVerbose && alias dbg2=dbg || alias dbg2="false dbg2"

if T "$homie" -o "$hMqtt" -o "$bMosqFile" ; then # enable MQTT
	: dbg "MQTT commands real."
else
	dbg2 "MQTT commands aliased."
	alias hLine=": hLine"
	alias hMeta=": hMeta"
	alias cMS="dbg cMS"
	# alias cMR="dbg cMR" # always enable to support -e option and have cErr called
	# alias cMqttReply=": cMqttReply"
fi

T -z "$commands" -a -z "$*" && cErr "$sMe: No commands!"

if cR $fOpenWrt ; then   # I'm running on OpenWrt (base of Gluon)
	T "$hMqtt" -o "$bMosqFile" || hMqtt=$hPubMqtt
	fMacIDs=/tmp/phones
else                                      # on rest-of-world (e.g. Raspi or (FIXME) some fullblown OpenWrt)
	T "$hMqtt" -o "$bMosqFile" || hMqtt=$LH
	fMacIDs=/srv/openhab-conf/phones
fi

fCollection=
sHosts= nHosts=0

hAll="${hAll:-$LH}" # if none given, take localhost
for hFull in $hAll ; do # do it for each given target node (or maybe just one)...
	ssh_rc=0 # reset cache of the last connection return code
	if T "$hFull" = $LH ; then
		sSshUser=LOCAL
		cSsh() {
			T "$1" = -v && shift
			ssh_msg=""
			ssh_data=""
			{ T "$1" = -t && shift ;} && eval "$*" || ssh_data="$(eval "$*")"
			ssh_data="$(eval "$*")" # FIXME: see https://www.shellcheck.net/wiki/SC2294
			ssh_rc=$?
			ssh_cmd="$*"
			T $ssh_rc -ne 0 && cLogger error "$* = $ssh_rc"
			T $ssh_rc = 127 && { set -- "$@" ; ssh_msg="CMD NOT FOUND: $1" ;}
			return $ssh_rc
		  }
		hTarget="$sArea"
	else
		# if hFull does not contain a user name, add "root@" to sshuser
		
		T "$hFull" = "${hFull#*@}" && sSshUser="root@$hFull" || sSshUser="$hFull"
		cSsh() {
			cX			
			ssh_msg=""
			_r=""
			T $bVeryVerbose || { T "$1" = -v && shift ;} && dbg SSHRUN "$* ($sSshUser)"
			{ T "$1" = -t && shift ;} && ssh -t $sSshUser "$@" || _r="$(ssh -q $sSshUser "$@")"
			ssh_rc=$?
			ssh_cmd="$*"
			ssh_data="$(cTrd '`' "$_r")"
			if T $ssh_rc = 255 ; then
				ssh_msg=UNREACHABLE
			else
				_n="$(cCRead .sshcnt)"
				cCWrite .sshcnt $((_n+1))
			fi
			if T $ssh_rc -ne 0 ; then
				T $ssh_rc = 127 && { set -- "$@" ; ssh_msg="CMD NOT FOUND: $1" ;}
				dbg SSH "RETURN CODE=$ssh_rc ($ssh_msg)" 1>&2
				cLogger error "$* = $ssh_rc"
			fi
			return $ssh_rc
  		  }	
		# remove any trailing "-<letter>", also the domain name (FIXME: why necessary?)
		hTarget=$(p "$hFull" | awk '{ $0=tolower($0) ; gsub("\\.[^0-9.]+$","") ; gsub("-[a-z]$","") ; print }' )
		T $nMaxGoneDays && T -z "$(cCRead .sshcnt $nMaxGoneDays)" && continue # dont try this node if not seen for N days
	fi
	_msg="" && T $sSshUser = "${sSshUser%${hTarget}-e}" -a $sSshUser = "${sSshUser%${hTarget}}" && _msg="($hTarget) "
	T "$bVerbose" -o "$nGiveHost" && ECHO "$Green######$Rst $Yellow${sSshUser#root@} $_msg//${commands:+ $commands //} $*" "$Rst$Green######$Rst" >&${nGiveHost:-1} 2>&1
	cGetSitecode # reuse value for all other nodes, too
	fTmpMqtt=$dTmp/mqtt.$hFull
	sNewSSID=""
	
	if T "$sUciQuery" ; then
		cSsh "uci show $sUciQuery" || cErr "$hFull: $ssh_cmd:" && T $ssh_rc = 127 && cntnue
		T $bDoAll && cEcho && cntnue # for debugging
		data="$(cOut|sed -n -e "{s/.*=//;s/'//g;p}")"
		if ! T "$sUciVal" ; then # query only = nothing to be written
			cEcho "$data"
		elif expr "$data" : ".*\n" >$fNul ; then
			cErrAndExit "$ssh_cmd: more than one line"
		else
			cSsh "q=$sUciQuery ; uci set \$q=$sUciVal && uci commit \$q && uci show \$q" || cErr "$hFull: $ssh_cmd"
			cEcho
		fi
	else
		cmdsToDo="$commands"
		if e "$cmdsToDo" | grep -qw bridge ; then # treat MQTT bridge as a special case
			_p="$(cd $dCache && find . -mindepth 2 -mtime -1 -name p |head -1|tr -cd 0-9)"
			if T $_p ; then
				# _p=${_p#./} ; _p=${_p%/p}
				if cPidValid $_p ; then
					cUbus send $sMe "{\"debug\":\"$$:skipbridgestart:other=$_p\"}"
					cmd=bridge cErrAndExit "$$: Another bridge ($_p) probably still running"
				else
					dbg BRIDGE "Removing stale bridge dir: $_p"
					rm -r $dCache/${_p:?}
				fi				
			fi
			_lst="$(cCRead .lastbridgeok)"
			nGap=$((nStartTime-${_lst:-9999999999})) # FIXME: remove debug in next line
			fPipe=$dTmp/p			
			# prepare subscribing to MQTT messages...
			mqttGroup="$(cExpand $mqttGroup|tr "," " ")"
			nSeconds=${nSeconds:-99999999}

			{ mkfifo $fPipe && chmod go-rwx $fPipe ;} || cErrAndExit "Failed on $fPipe (rc=$?)"
			_subscriptions=""
			for t in $hTarget $mqttGroup ; do
				T ${t%/*} = $t && _p="-t $sSite/$t" || _p="-t $t" # prefix site if no "/" inside
				_subscriptions="$_subscriptions $_p/+/get $_p/+/+/get $_p/+/set $_p/+/+/set"
				cLogger debug "MQTT: Subscribing to $_p/.../get and .../set"
			done
			T "$homie" && _subscriptions="$_subscriptions -t homie/$hTarget/+/+/set"
			trap_CHLD() {
				for t in # nPidMosq=$nPidMosq nPidSleep=$nPidSleep nPidUbus=$nPidUbus nPidLogread=$nPidLogread
				do
					n=${t%%=*} ; p=${t#*=}
					T $p && ! cPidValid $p && { # check whether an important child has disappeared
							# dbg PROCMISS "$n=$p"
							cErr "TRAP_CHLD: $n=$p HAS VANISHED"
						}
				done

			}		
			trap trap_CHLD CHLD # FIXME: needed at all?

			# echo PERIODIC NONE begin > $fPipe & # something has to be in the pipe immediately otherwise it fails due to race condition
			# cS 1 # FIXME: make it shorter?

			nBridgeDelta=$(cCRead bridgedelta) && T "$nBridgeDelta" -gt 0 || nBridgeDelta=2
				# on Gluon/OpenWrt crond notices the process end only after up to 12 (or better 13?) seconds before the full minute (11 is sometimes not enough, too):
			cR $fOpenWrt && cPidPName "" crond >$fNul && nSeconds=$((nSeconds-14)) && cLogger info "Crond on OpenWrt reduction: nSeconds=$nSeconds"
			T $nSeconds -lt 3 && nSeconds=3
			T $nGap -gt 50 -o $(date +%H) -le 3 && echo "$(date +%F_%T): gap=$nGap, nSeconds=$nSeconds" >> /tmp/$sMe.$USER.gap  && dbg BRIDGE "nGap is >50: $nGap"
			cLogger info "ONGOING: bridge startup (for $nSeconds(-$nBridgeDelta) sec,$(cR $fOpenWrt && echo "OpenWrt"),gap=$nGap)"
			dbg SUBSCRIPTION "\"$hMqtt $_subscriptions\", homie=$homie, fPipe=$fPipe"

			_last_will_options="--will-qos 1 --will-topic $sSite/$hTarget/bridge/log --will-payload {\"state\":\"OFF\",\"alive\":0} --will-retain"

			cMqttSub -F "MQTT %t %p" ${nSeconds:+-W $((nSeconds+72))} -R $_subscriptions $_last_will_options 2>&1 |
					awk -v f=$fPipe 'NR==1&&!/^MQTT/{print "PERIODIC TERMINATE MQTT:"$0>f ; exit 1} $1=="MQTT"{print>f;fflush(f)}' & #  prevent multi-line commands thus avoiding injections
			nPidMosq=$!
			dbg SUBSCRIPTION "nPidMosq=$nPidMosq,bridgedelta=$(cCRead bridgedelta),nSeconds=$nSeconds"
			ln -fs $fPipe $dCache/p # for the convenience of injecting debug commands
			cmd=bridge
			cMR ONGOING "GAP=${nGap}s,SUBSCRIBED $(awk -v a="$_subscriptions" 'BEGIN {gsub("-t ","",a) ; print a}' )"
			
			T $nMqttSleep -gt "$((nSeconds - nBridgeDelta))" && nMqttSleep="$((nSeconds - nBridgeDelta))"
			
			while dbg PERIODIC "will sleep $nMqttSleep secs" ; 
					T $nMqttSleep -lt 2 && nMqttSleep=2 ;
					cS $nMqttSleep ; do # start background subprocess for periodic tasks/wakeups
				_ran=$(cRan)
				_s="${nMqttSleep}_${_ran}_$nSeconds secs"
				dbg PERIODIC "Periodic wake-up: $_s"
				T $_ran -ge $nSeconds && { echo PERIODIC TERMINATE "$_s" ; cS 1 ; break ;}
				_o=NOOP
				T $((_ran+nMqttSleep+1)) -ge $nSeconds && nMqttSleep=$((nSeconds-_ran)) && _o=FINAL &&
					dbg PERIODIC "Final sleep $nMqttSleep ($_s)"
				echo PERIODIC $_o "$_s" # FIXME: Replace NOOP with TELE again
			done > $fPipe &
			nPidSleep=$!
			
			# _tf=$fNul ; T $bVerbose && _tf=/tmp/$sMe.log
			if cCmv ubus ; then # enable a background listener for the ubus bus on OpenWrt
				# make ubus listen a real subprocess and pipe its (modified) output to fPipe:
				# to test: for i in $(seq 1 199) ; do ubus send ==== ; for n in $(seq 1 4) ; do ping -qc $n 192.168.178.1 > /dev/null ; echo $i.$n ; ubus send chime$i.$n ; ubus send anotherfast ; done ; cS 1 ; done
				# WARNING: On Gluon (OpenWrt?) it seems that "ubus listen" stalls sometimes, if it is not read fast enough (makes it unreliable for logging)...
				# we'll make it restart in a loop if it ends.
				_secs=$((nSeconds-nBridgeDelta)) # make sure it ends shortly after the bridge

				awk -v f=$fPipe -v t=$_secs -v pid=$$ 'BEGIN { cmd="while [ -d /proc/"pid" ];do ubus -t " int(t/4+99) " listen ;rc=$? ;echo \"{ RESTARTING($rc," int(t/2+1) ") }\" ;done"
						while (cmd|getline line) {
							if (line~/^\{/) { print "UBUS LISTEN "line>>f
								# ; print "UBUS LISTEN "line>>"/tmp/u"
							}
						}
					}' &
				nPidUbus=$!
				cS 1
				dbg UBUS "nPidUbus=$nPidUbus: others\n$(pgrep -lfa "ubus listen")" # pgrep -s 0 -n -lfa "ubus listen"
				_n=$$ ; { cS 1 ; ubus send $sMe "{\"debug\":\"$_n:bridge startup(mosq=$nPidMosq,ubus=$nPidUbus):${nBridgeDelta}+${nMqttSleep}s,gap=${nGap}s\"}" ;} &
				# ubus call system info
				# ubus call hostapd.client1 get_status
				# ubus call hostapd.client0 get_clients			
				# while cS 1 ; do ubus send "$(date +%T)" ; date ; done	
			fi

			# to debug: manage_gluon_mqtt -c bridge -m - -v -a -a

			if T "$bDoExperiment" -a "" ; then  #  debug lua and flushing
				# DONT KNOW why piping through awk makes so many buffering problems, so had to workaround further down:
				$SB lua -e 'local socket = require("socket"); while true do
					socket.sleep(3); print(os.date("PERIODIC PULSE %H:%M:%S"))
					end' > $fPipe & echo $! > $dTmp/experimentPid
				cS 1
				nPidExp="$(cat $dTmp/experimentPid)"
				dbg EXPERIMENT "Background lua PID is: others\n$(pgrep -lfa "lua -e")"
				{ cS 1 ; cUbus send $sMe '{"debug":"Experiment started"}' ;} &
			fi
			
			if T $bDoAll && cCmv logread ; then  #  background listener for logread
				_p="daemon.info manage_gluon_mqtt"
				# DONT KNOW why piping through awk makes so many buffering problems, so had to workaround further down:
				# ( logread -f & echo $! > $dTmp/logreadPid ) | awk -v f=$fPipe -v p="$_p" '$0 !~ p {print "LOGREAD LOG " $0 > f ; fflush(f) }' & # NOTE: continous piping didnt work on OpenWrt
				$SB logread -f > $fPipe &
				echo $! > $dTmp/logreadPid
				cS 1
				nPidLogread="$(cat $dTmp/logreadPid)"
				dbg LOGREAD "Background logread PID is: others\n$(pgrep -lfa "logread -f")"
				{ cS 2 ; cLogger info "Started." ;} &
			fi

			dbg PROCIDS "nPidMosq=$nPidMosq,nPidSleep=$nPidSleep,nPidUbus=$nPidUbus,nPidLogread=$nPidLogread,fPipe=$fPipe"
			
			trap_SIGNAL() {
					pids="$nPidMosq $nPidSleep $nPidUbus $nPidLogread"
					_msg="Delete p=$fPipe, kill ${pids%% }."
					dbg TRAP_SIGNAL "$_msg (cmd=$cmd)"
					rm -f $fPipe # rm pipe as early as possible to allow for next bridge!
					T $nSeconds && {
						cMR ONGOING "$_msg"
						_ran=$(cRan) # Update _ran
						_bd=$(cCRead bridgedelta) ; _bd=${_bd:-0}  # read the time passed since the last bridge
						_over=$((_ran-nSeconds+1)) # one second more to be sure
						T $_over -ge 0 && {
							# T $_over -lt $_bd && _over=0 # do not count the time passed during the bridge
							cCWrite bridgedelta $_over
						}
					}
					# T $nPidMosq && cKillChilds "$nPidMosq" || :
					# T $nPidSleep && cKillChilds "$nPidSleep" || :
					# T $nPidLogread && cKillChilds "$nPidLogread" || :
					# T $nPidUbus && cKillChilds "$nPidUbus" || :
					kill $pids 2>$fNul || :
 					dbg TRAP_SIGNAL "$sMe: killed $pids, sent MQTT, now stopping at $(date)"
					trap_EXIT # FIXME: exit() instead?
				}		
			trap trap_SIGNAL INT QUIT TERM SEGV EXIT

			T $bDoAll && cS 1
		fi
		# NB: OpenHab Homie autodiscovery didn't like uppercase characters at the beginning...
		T "$homie" && os_data="$(cGetOSData)" && homie="$(cLower $hTarget)" &&  # change "yes" to $hTarget
			 T "$cmdsToDo" != "homie-delete" && cDisco "$homie" # FIXME: check handling/interpretation of "homie-delete"

		dbg LOOP "START (cmdsToDo=$cmdsToDo)"
		while T "$cmdsToDo" ; do
			if T "$cmdsToDo" = bridge ; then # bridge must the last or the only command
				T -p $fPipe || cErrAndExit "Pipe $fPipe was gone"
				cmd= cmdopts=""
				dbg READ "Reading $fPipe ..." # && jobs
				_x=$?
				read -r sType cmd cmdopts <$fPipe
				rc=$?
				dbg RAW "Read sType=$sType,cmd=$cmd,cmdopts=$cmdopts,rc=$rc($_x)" && T $rc -ne 0 # && jobs
				for t in nPidMosq=$nPidMosq nPidSleep=$nPidSleep nPidUbus=$nPidUbus nPidLogread=$nPidLogread ; do
					n=${t%%=*} ; p=${t#*=}
					T $p && ! cPidValid $p && { # check whether an important child has died prematurely or has vanished ok
							dbg2 PROCMISS "$n=$p"
							_msg=VANISHED
							T $nSeconds && T $(date +%s) -ge $((nStartTime+nSeconds)) && 
									_msg="GONE OK" && cCWrite .lastbridgeok "$(date +%s)" # save for comparison on next startup
							_msg="EXITING ($n=$p $_msg)."
							cMR -E OFF "$_msg."
							break 9
						}
				done
				if T "$rc" -ne 0 ; then
					_msg="rc=$rc,server=$sServer,started=$(date +%T),pid=$$"
					if T -p $fPipe ; then # pipe exists
						nErrors=$((nErrors + 1)) # FIXME: Remove stuff for debugging
						_msg="Read error pipe $fPipe ($_msg,nErrors=$nErrors)"
						cMR -E ERROR "$_msg"
						cS 2 ${bQuiet:+5}
						T $nErrors -gt 100 && cErrAndExit "$_msg: $(ls -l $fPipe 2>&1)"
						cntnue
					else # pipe gone
						cMR OFF "Exiting (read_$_msg)."
						exit 0
					fi
				fi
				# hacky workarounds for the awk problems above
				T "$cmd" = "$(date +%b)" && cmdopts="$sType $cmd $cmdopts" && sType=LOGREAD && cmd=LOG # hacky
				T "$sType" = "{" && cmdopts="$sType $cmd $cmdopts" && sType=UBUS && cmd=LISTEN && dbg CORRECTED # FIXME: hacky
				cmd="$(cTrd -c A-Za-z0-9/ "$cmd")" || cntnue # sanitize for security reasons
				sType="$(cTrd -c A-Z "$sType")" || cntnue

				if T $sType = UBUS -o $sType = LOGREAD -o $sType = "{" ; then
					dbg READ "TYPE=$sType,$cmd,$cmdopts"
					# set -- $cmdopts # cmdopts=27 00:35:35 2024 daemon.info manage_gluon_mqtt herkules: READ Will read /var/log/manage_gluon_mqtt.root/4458/p ...,rc=0
					# T "$6" = daemon.info -a "$7" = $sMe && cntnue
					cEcho "$sType:$cmdopts"
					T "$(e "$cmdopts" | cCut " " 6,7)" = "daemon.info $sMe" && cntnue
					cMqtt "/$(p $sType | tr A-Z a-z)/log" "$cmdopts"
					cntnue
				elif T $sType = PERIODIC ; then
					dbg "\nREAD" "TYPE=$sType,$cmd,$cmdopts ($(date +%T))"
					# FIXME Reenable:
					T "$bVerbose" -a "$cmd" != FINAL -a "$cmd" != TERMINATE && 
						cMS /bridge/state "{*TelePeriod*:$nMqttSleep}" # FIXME: nMqttSleep might have been modified in subshell
					T "$cmd" = PULSE && cStackCmd echo+pulse
					T "$cmd" = TELE  && { cIsNonGluon && cStackCmd echo+BRIDGEALIVE_$cmdopts || cStackCmd wifistate,statistics ;}
					T "$cmd" = TERMINATE && cmd=bridge && { 
						: cMR OFF "Terminating $sMe ($cmdopts,${nSeconds}s)" # FIXME: remove cMR if really not needed
						T $nSeconds && T $(date +%s) -ge $((nStartTime+nSeconds)) && 
								cCWrite .lastbridgeok "$(date +%s)" # save for comparison on next startup, FIXME: duplicated code from above
						cS 1
						break 9 ;
					  } 
					cntnue
				elif T $sType = MQTT ; then
					nMqttCommands=$((nMqttCommands + 1))
					T $nExitAfter && T $nMqttCommands -gt $nExitAfter && trap_SIGNAL && cErrAndExit "More than $nExitAfter MQTT commands received"
					# for cmd in "" / a a/ a/b a/b/ a/b/c a/b/c/ a/b/c/d a/b/c/d/e ; do t="$cmd" ; _f="${cmd%%/*}" ; _t="${cmd#$_f/}" ; _prefix="$_f/${_t%%/*}" ; cmd="${cmd#$_prefix/}" ; echo  "$t     $cmd   $_f   $_prefix " ; done
					_f="${cmd%%/*}" # 1st word of topic
					_t="${cmd#"$_f/"}" # remove 1st word
					_prefix="$_f/${_t%%/*}" # 1st/2nd word of topic
					cmdopts="$(cFirstJsonAttr "$cmdopts")"
					cmdopts="$(cExpand "${cmdopts%(null)}")"
					dbg READ "command: $cmd  $cmdopts  (prefix=$_prefix, sSite=$sSite)" || cEcho "$cmd $cmdopts"
					case "$_prefix" in
					"homie/$hTarget"|"$sSite/$hTarget"|"$sSite/${mqttGroup:-$hTarget}")
						# cmd="$(p "$cmd" | cCut / 3- )"
						cmd="${cmd#"$_prefix/"}" # remove 1st/2nd word
						cmd="${cmd%/get}"
						# cmd="$(p "$cmd" | awk -v FS=/ 'NF && NF-1 { print $3 ( $4 && $4=="get" ? "" : "/" $4 ) ( $5 && $5=="get" ? "" : "/" $5 ) }' )"
						case "$cmd" in
						localclients*|publicwifi/localclients*)	cmd=localclients ;;
						publicwifi/ssidshort/set) cmd="wifissid" ;;
						radio/channel24/set)		cmd=channel24 ;;
						publicwifi/state/set) 	case "$cmdopts" in
												true|ON|1)	cmd=wifiup ;;
												false|OFF|0) cmd=wifidown ;;
												*) false ;;
												esac || cErr "Illegal cmdopts=$cmdopts"
											;;
						wifistat*|radio/channel24|publicwifi/state|publicwifi/ssidshort|publicwifi/ssid) cmd=wifistate ;;
						wifiup*|wifidown*|echo*|loop*|sSite*) cmd="${cmd%\*}"  ;;
						gluon-data*)	cmd=gluondata ;;
						machine-data*)	cmd=machine-data ;;
						wifissid*)	cmd="wifissid" ;;
						esac
						;;
					*) cmd="$(p "$cmd" | awk -v FS=/ 'NF && NF-1 {print ($(NF-1)) }' )"
						;; # extract second last part of topic, must have at least one /
					esac
					cmd=${cmd%/get} && cmd=${cmd%/GET}
					dbg READ "Remapped MQTT to command: $cmd"
				else
					cErr "Unknown sType=$sType from pipe $fPipe (rc=$rc)"
					# cErrAndExit "Unknown sType=$sType from pipe $fPipe (rc=$rc)"
				fi
			else
			    	#cmd="$(p "$cmdsToDo"	| cCut ,  		)"
			    	 cmd="${cmdsToDo%%,*}"
			#	cmdsToDo="$(p "$cmdsToDo"	| cCut , 2- -s	)"
				cmdsToDo="${cmdsToDo#$cmd}"
				cmdsToDo="${cmdsToDo#,}"
			    #cmdopts="$(p "$cmd"		| cCut + 2- -s	)" # split further...
					  _c="${cmd%%+*}" # extract part before any command option ...
				 cmdopts="${cmd#$_c}" # ... and remove part before the +
				 cmdopts="${cmdopts#+}"	
				    #cmd="$(p "$cmd"		| cCut +   		)"
				     cmd="$_c"
			fi		
			    cmd="$(p "$cmd" 	| cClean)" # for security reasons
			cmdopts="$(p "$cmdopts" | tr -cd "A-Za-z0-9_.%, /-" )"
			dbg2 COMMAND "$cmd ($cmdopts) (REMAIN: $cmdsToDo)"
			case "$cmd" in
			help) # really hacky implementation: grepping this script code for singular case branches that look like a implemented command ....
				cProbeGET
				_msg="$( awk '$1 ~ /^[a-z]{3,}[a-z|]+)/ { gsub(/)/,"",$1); gsub(/\|/," ",$1); if ($1=="help") doit=1 ; if (doit) printf $1 " " }' "$0")"
				cEcho "$_msg"
				cMR OK "Command $cmd($cmdopts): $_msg"				
				;;
			clearcache)
				cProbeSET
				ssh_data="$(cd $dCache && find . -maxdepth 1 -name "${hTarget:-XXX}.*" -type f -print -exec rm '{}' \; 2>&1)"
				ssh_rc="$(cOut|cCount)"
				cEcho
				cMR OK "Command $cmd($cmdopts): $ssh_rc"				
				;;
			bridge|noop|ignore|echo|date)
				cProbeGET
				dbg COMMAND "cmd=$cmd,$cmdopts,($(date +%T))"
				cIsCmd echo && { _msg="$(cExpand "${cmdopts:-%s}")" ; cEcho "$_msg" ; cMR OK "Command $cmd($_msg) by $(cat $fHost) at $(date +"%T") (V=$sMeAge,NPID=$(cPid))" ; cIsOpt TESTERROR && cErr "Test error" ;}
				cIsCmd date && { _msg="$(date +"%F %T")" ; cEcho "$_msg" ; cMR OK "Command $cmd($cmdopts): $_msg" ;}
				;;
			bridgestop) # inject a command into p to stop a running bridge
				cProbeNOMQTT
				if T -p $dCache/p ; then  # cErrAndExit "No pipe $(ls -l $dCache/p|xargs)"
					echo "PERIODIC TERMINATE bridgestop${cmdopts:++$cmdopts}" > $dCache/p
					cMR OK "Command $cmd($cmdopts) sent."
				else
					cMR OK "Command $cmd($cmdopts) found no pipe."
				fi
				cS 1
				dbg BRIDGESTOP "ubus procs:\n$(pgrep -lfa "ubus listen")"
				;;
			beacon)
				cProbeGET
				cMqttBeacon
				;;
			dns|dnslocal)
				cIsCmd dnslocal && _g="gluon-wan " && cProbeNOMQTT
				cProbeNOMQTT # cProbeGET
				cmdopts=${cmdopts:-openwrt.org}
				if cSsh "${_g}nslookup $cmdopts" ; then
					ssh_data="$(cOut|awk 'NR>2 && /Address[0-9 ]*:/{gsub("AddressT 0-9]*: ","");print}')" # extract the IP addresses
					cMR OK "Command $cmd($cmdopts)"
					cMS /$cmd "{*$cmdopts*:$(cOut|cWordsToJsonArray)}"
				else
					cMR -e ERROR "Command $cmd($cmdopts) returned: $ssh_data"
				fi
				cEcho
				;;
			autossh) # FIXME: running this should be limited to max one or two per minute....
				cProbeSET 
				_ml="$((${cmdopts:-12} * 3600 - 10))" # Default = for almost 12 hours

				# AUTOSSH_GATETIME    # how long must an ssh session be established before we decide it really was established
				#                       (in seconds). Default is 30 seconds; use of -f  flag sets this to 0.
				# AUTOSSH_LOGFILE     # file to log to (default is to use the syslog facility)
				# AUTOSSH_LOGLEVEL    # level of log verbosity, corresponding to the levels used by syslog; so 0-7 with 7 being the chattiest
				export AUTOSSH_MAXLIFETIME=$_ml # set the maximum time to live (seconds) # 604800s = 1 week
				export AUTOSSH_MAXSTART=-1    # max times to restart (default -1 means no limit)
				# AUTOSSH_MESSAGE     # message to append to echo string (max 64 bytes)
				# AUTOSSH_PATH        # path to ssh if not default
				export AUTOSSH_PIDFILE=$dCache/autossh.$hTarget.pid  # write pid to this file
				export AUTOSSH_POLL=60    # how often to check the connection (default 600 seconds)
				# AUTOSSH_FIRST_POLL  # time before first connection check (seconds)
				# AUTOSSH_PORT        # port to use for monitor connection
				# AUTOSSH_DEBUG       # turn logging to maximum verbosity and log to                           stderr
				dbg AUTOSSH "maxlife=${_ml}s" && env|awk '/AUTOSSH/{printf gensub("AUTOSSH_"," ","1")} END{print""}' 1>&2
				if T "var1" ; then
					_mpcmd="$cMPub -r -h $LH -t $sSite/$hTarget/autossh/heartbeat"
					cSsh "d=\$(date '+%F %T (produced on $hTarget)') && $_mpcmd -m \"\$d\" && $sMe -m - -c memory"
					_msg="$cmd${cmdopts:+($cmdopts)} "
					if T $ssh_rc = 0 ; then
						_msg="${_msg}already had MQTT listener."
						cMR OK "${_msg}"
						cAddSuccHost
					else
						_msg="${_msg}check"
						if T $ssh_rc = 127 ; then
							_msg="${_msg}: no $MP? - run -c install first!"
							cMR -E ERROR "$_msg:"
						elif T $ssh_rc = 255 ; then
							cMR -E ERROR "$_msg:"
						else
							dbg AUTOSSH "${_msg}will start autossh ($cmdopts) and run a check"
							_spec="[::]:1883:$LH:1883" # "[::]:1883:localhost:1883"
							# this line MUST be in /etc/config/dropbear on remote host:
							# option GatewayPorts 'on'
							autossh -f -N -T ${bVeryVerbose:+-v} -R "$_spec" $hFull "$sMe -m - -S $_ml -c echo+AUTOSSHBRIDGE,bridge ${mqttGroup:+-g $mqttGroup}" # || dbg AUTOSSH "rc=$?"
							cS 2
							_pid="$(cat $AUTOSSH_PIDFILE)"
							_msg="pid=$_pid"
							cSsh "date '+%F %T (autossh newly established)' | $_mpcmd -l"
							# cSsh "netstat -l | grep 1883"
							cMR OK "Command $cmd($cmdopts) executed."
							cAddSuccHost							
						fi
					fi
					T $ssh_rc = 0 && cEcho "$hTarget: $_msg"
#DELETE_BEGIN#
				else
					# nPidAutoSSH=$! # nPidAutoSSH="$(cat $AUTOSSH_PIDFILE)"
					# dbg AUTOSSH "pid=$nPidAutoSSH for: $hAll"
					cS 10
					trap_AUTOSSH() {
						cmd=autossh
						cMR ONGOING "Exiting."
						jobs
						wait $nPidAutoSSH
						kill $nPidAutoSSH 2>$fNul || :
						dbg AUTOSSH "Killed nPidAutoSSH=$nPidAutoSSH, now stopping at $(date)"
						trap_EXIT
					}		
					trap trap_AUTOSSH EXIT
#DELETE_END#
				fi
				;;
			loop|check)
				cProbeGET
				_opts=  #  empty _opts signals "check" command
				cIsCmd check && cmdopts="" || {
					_opts=$(cSaniNum "${cmdopts:-5}") && T $_opts -ge 1 -a $_opts -le 99  ||
							{ cMR ERROR "$cmd: Invalid parameter '$cmdopts'" ; cntnue ;} # "$cmd: Invalid parameter '$cmdopts'"
				}
				cMR ONGOING :
				_cmd='cSsh date -u +%s'
				if $_cmd ; then
					data="$ssh_data"
					cEcho
					i=${_opts:-0}
					while T $i -gt 0 ; do
						$_cmd
						dbg "$cmd($i)" "$ssh_data"
						i=$((i-1))
					done
					cEcho
					cMR OK "${_opts:+Command $cmd($_opts) cycles of /bin/date in $((ssh_data - data)) seconds: $data-$ssh_data}"
				else
					cMR ERROR
				fi
				;;
			install)
				cProbeNOMQTT
				cSsh -v "id -nu"
				_user="$(cOut|cClean)"
				T "$_user" || { cErr "user@$hFull could not be determined. Debug your SSH setup:" ; cntnue ;}
				nLvl=1 # determine "Linux level", 0=Basic/1=GNU_Linux-like/2=e.g. Debian-like/3=OpenWrt (implied UCI)/4=Gluon

				if T "$hFull" != $LH -o "$(dirname "$0")" != /sbin && T "$_user" = root ; then
					cEcho "Remote targetuser is $_user: Will try to copy this script to /sbin later..."
					cStackCmd filecopy
					fFile="$0"
				fi

				os_data="$(cGetOSData)"
				dbg "$os_data"

				# STEP: log memory size at the beginning
				cSsh -v "df -PhT"
				_sizedata="$ssh_data" # TODO: duplicated code from "mountsizes", save result for later

				# STEP: change the shell prompt PS1
				# PS1='\[\033[31;1m\]\h \[\033[32;1m\]$PWD\[\033[0m\] \[\033[31m\]\$\[\033[0m\] ' # nicer prompt on OpenWrt
				# 'X=${SHLVL#1}' \; 'X=${X:+($X)}' ...
				{ echo PS1=\''\[\033[31;1m\]\h \[\033[32;1m\]$PWD\[\033[0m\] '\#\ \' ;
					echo 'mp() { mosquitto_pub -t "${1:-ping}" -m "${2:-$HOSTNAME}" $3 $4 $5 ;}'
				} | cSsh 'd=/etc/profile.d ; mkdir -p $d && ! grep -wsq PS1= $d/my.sh && tee /tmp/my.sh >> $d/my.sh'
				_rc=$?
				dbg INSTALL "Prompt written (rc=$_rc)"

				# STEP: try to install mosquitto, if not there yet
				if cSsh "command -v $MP" ; then
					cEcho "$MP already installed on $hFull..."
				else
					cEcho "$hFull: $MP not found .. determining install cmd .."
					cSsh "command -v opkg || command -v apt || echo NONE" 2>$fNul
					_scmd="${ssh_data##*/}" && _c="$_scmd update && $_scmd install mosquitto"
					case "$_scmd" in
					opkg|X)
						# FIXME on newer Gluon - might needed for SSL downloads:
						# 1) temporarily change https to http for "openwrt_packages" in /etc/opkg/distfeeds.conf
						# 2) opkg install libustream-tls && opkg install ca-certificates  #   or opkg ... --no-check-certificate
						_c="sed -i -e 's/19.07-SNAPSHOT/19.07.9/' -e 's/23.05-SNAPSHOT/23.05.5/' /etc/opkg/distfeeds.conf ; $_c" # fixes old wrong path
						_c="$_c-client-nossl coreutils-stdbuf${bDoAll:+ psmisc}"
						nLvl=2
						;;
					apt|X)
						_c="$_c-clients coreutils"
						nLvl=2
						;;
					NONE|X)
						cErrAndExit "ERROR: opkg/apt not found on $hFull. Stopping" # never returns here afterwards
						;;
					esac
					cEcho "Executing: $_c (please wait)"
					cSsh "$_c" # || { cEcho "cSsh failed: $_c, aborting ..." ; cntnue ;}
					_msg="$ssh_data (rc=$ssh_rc)"
					dbg INSTALL "$_msg" || cEcho "Installer returned $_msg"
				fi
				T $ssh_rc -ne 0 && { cEcho "cSsh failed: $_c, aborting ... (rc=$ssh_rc)" ; cntnue ;}

				# STEP: get a autoupdater setting
				# then comes a Gluon-specific part - determine Gluon by checking for the UCI entry autoupdater_branch
				cSsh -v 'uci get autoupdater.settings.branch && { autoupdater -n ; echo rc=$? ;}' 
				_branch="$(cLine 1)" # use autoupdater_branch setting as indicator for seeing whether we are on Gluon
				T "$_branch" && nLvl=4 # indicates we are probably on Gluon
				_rc="$(cOut|awk -F= '/rc=/{print $2}')"
				# T "$_rc" -ne 0 && { cEcho "autoupdater -n failed:\nssh_data=$ssh_data\nAborting ..." ; cntnue ;}
				dbg AUTOUPDATER "branch=$_branch,LxLvl=$nLvl,rc=$_rc,autoupdater_rc=$_rc"
				! T $bDoAll && {
					# only minimal install requested: abort hereafter			
					cEcho "Done partly install for target $hTarget (autoupdater_branch=$_branch,bDoAll=$bDoAll)..."
					ssh_data="$_sizedata" # inject the previously saved size data into mountsizes_prev ...
					cmdsToDo="mountsizes_prev${cmdsToDo:+,$cmdsToDo},mountsizes"
					cntnue # quit installation here, unless on Gluon or $bDoAll = yes
				}
				cCWrite .autoupdater_branch

				# generate the command options (keys/values) need for uci set in the next steps:
				_gen_opt() { # $1: type, $2:src, $3:dest_port
					_b="firewall.$2_$1"
					echo "$_b=rule
					$_b.dest_port=$3
					$_b.src=$2
					$_b.name=$2_$1
					$_b.proto=tcp
					$_b.target=ACCEPT"
				}
				
				# STEP: open firewall for MQTT on Gluon (only on Gluon)
				if T "$nLvl" -ge 4 -a "yup" -a ! "$bDoExperiment" ; then # on Gluon
					# similar to https://ffmuc.net/wiki/doku.php?id=knb:ssh#webseite_des_ff-knoten_aus_dem_lan_aufrufen :
					cEcho "Assuming Gluon: add firewall rules for incoming HTTP from LAN..."
					_gen_opt http wan 80 | cSsh "xargs ${bVerbose:+-t} -n 1 uci set && uci commit"						
					# /etc/init.d/firewall reload
					# uci delete firewall.wan_http
					
					# TRY LATER: wan over wifi: https://harz.freifunk.net/wiki/doku.php/anleitungen/gulon/wwan

					cEcho "Assuming Gluon: add firewall rules for incoming MQTT..." # outgoing should be working anyways
					# works for Ulmer Software w/o Gluon, too... DONT KNOW IF NECESSARY ON ALL GLUON VERSIONS
					{ _gen_opt mqtt wan 1883 ; _gen_opt mqtt mesh 1883
					} | cSsh "xargs ${bVerbose:+-t} -n 1 uci set && uci commit"
				fi
				
				_rlfw() { cSsh -v "/etc/init.d/firewall reload" || dbg FW "Failed to reload firewall." ; cOut ;}
				_rlfw
				
				# STEP: add more firewall rules (only on Gluon)
				if T "$nLvl" -ge 4 -a "$bDoExperiment" ; then
					cEcho "... adding other firewall rules for outgoing MQTT..."
					for x in loc_client wan mesh ; do
						_gen_opt mqtt $x 1883
					done | cSsh "xargs ${bVerbose:+-t} -n 1 uci set ; uci commit"					
					_rlfw
					exit 55
				fi
				
				# STEP: add a regular MQTT "beacon" to crontab on Linux-like systems
				if cMqttBeacon && T "$nLvl" -ge 2 ; then
					if cSsh -v "crontab -l | grep \"$sMe\"" ; then
						cEcho
						dbg MODIFY "A crontab line already containing '$sMe' was found... Leaving crontab unmodified."
					else
						cEcho "crontab entry with '$sMe' not found... adding a simple one... pls adapt it later!!"
						_line="0 * * * * sleep 50 ; $sMe -M -c echo+LOCALCHIME${_branch:+,machine-data,statistics} -m $hPubMqtt,$LH"
						cSsh "{ crontab -l ; echo \"$_line\" ;} | crontab - ; ${bVerbose:+echo crontab is now: ; crontab -l}"
						cEcho
					fi
				fi

				# STEP: copy a local, generic public key for login (only to /tmp, has then to be finished manually)
				_f=~/.ssh/id_rsa_piraten.pub # put your own key there!
				cR "$_f" && { dbg PUBKEY "Copying $_f" || echo "Public key file: $_f";} &&
						cat $_f | cSsh 'cat >> /tmp/pubkey ; ls -l /tmp/pubkey'

				# ... FIXME: still not implemented: installing it as an MQTT daemon on OpenWrt/Gluon ...
				_f=/etc/rc.local
				cSsh "cat $_f"
				if T "$nLvl" -ge 3 ; then # FIXME: linux should be sufficient
					if cOut|grep $sMe ; then
						dbg MODIFY "The $_f line containing '$sMe' was found above... Leaving $_f unmodified."
					else
						cEcho "$_f entry with '$sMe' not found... adding a simple one... pls modify it later!!"
						_line="\( sleep 240 \; $sMe -c echo+BOOTED,machine-data,statistics -m $hPubMqtt,$LH ; \) \&"
						cSsh "sed -i.sav -e  \"s/^exit 0/$_line\\nexit 0/\" $_f ; 	${bVerbose:+echo $_f is now: ; cat $_f }"
						cEcho
					fi
				fi
				;;
			filecopy|selfcopy)
				cProbeNOMQTT
				_check() { bash -xn $1 && cCmv ash && ash -xn $1 ;} # smoke test syntax of compressed script with bash and ash
				fFile="${cmdopts:+$HOME/.local/bin/$(basename $cmdopts)}" # file is supposed to be in ~/.local/bin or a symbolic link there!
				fFile="${fFile:-$0}" # take this script as default
				fPath="$fFile"
				fBase="${fPath##*/}"
				#DELETE_BEGIN#   # Marks the following script part for deletion when compressing the script
				_fn=$dCache/$fBase.$(date +%M)
				cp -Lpr "$fPath" $_fn || { cEcho "Copying $fPath to $_fn failed." ; exit 77 ;}
				_check $_fn
				rc=$?
				if T ! "$bDoAll" -a $rc = 0 ; then				
				  sed -e '/^[ \t]*#DELETE_BEGIN#/,/^[ \t]*#DELETE_END#/d' -e '/#DELETE_LINE#[ \t]*$/d' -i $_fn &&
					sed -e 's/^[ \t]*//' -e 's/\(^[ \t]*\| \+\)#\($\|#*[\t ]\+[^"].*$\)//g' -i $_fn &&
					#      ^Whitespace      WhiteSpace # Comment
					  sed -e 's/() *{/(){/' -e 's/[\t ]*\t[\t ]*/\t/g' -e '/^$/d' -e 's/ *;/;/'   -e 's/  *"/ "/g' -e 's/"  */" /g' -e 's,\$( ,$(,g' -e 's, )",)",g'  -e 's,\$(echo ,$(e ,g' -e 's,\t+$,,g' -e 's,^local ,l ,'  -e 's,^echo ,e ,'  -e 's,\<cntnue\>$,c,'  -e 's,\<return\>,r,' -e "s,\<command\>,\$C,g" -e 's,_msg\>,_m,g'  -e 's,\<cMqtt,cM,g'  -i $_fn &&
					  #  kompr: () *{            Whitesp tab Whitespace  emptyline  any WS before ;  WS bef DouQts   WS after DblQts  spaceAfter$(     spaceBefore)"    echo to e after $(     tab at eol     local to alias l    echo to e          cntnue to c            return to r          command  to  $C        suffix _msg to _m    command with cMqtt...
						cp -p $_fn /tmp &&
						  sed -E -i $_fn -e 's/([^\];) +/\1/g'  -e 's,[ \t]*(&&|>|>>|\|)[ \t]*,\1,g' -e '/awk|lua|printf|test|:/!s,"([a-z0-9/-][a-z0-9/._-]+)",\1,g' && #  -e 's,[^\)]\) [^a-zA-Z],),g'  &&
						  #                  WS after ;       Whitesp around && or | , but not << or <  pure strings > 1c in double quotes   #FRAGILE
						    _check $_fn
				  rc=$?
				  dbg $cmd "$fPath ($(wc -c <$fPath)) trimmed to $_fn ($(wc -c <$_fn)): rc=$rc" # && cp $_fn /tmp/$(basename $_fn).$(date +%M)				
				fi
				T $rc != 0 && cErrAndExit "Verifying target script $_fn returned error $rc"
				if T ! "$bDoAll" -o "$hDone" && diff -Nq $_fn $_fn.save && find $_fn.save -mmin -30 > $fNul ; then
					_msg="No changes in $_fn or no copy."
					cMR OK "No copy."
				elif T $sSshUser = LOCAL ; then
					_msg="No target host."
				else
					cp -p $_fn $_fn.save
					cp -p $_fn $dCache/$fBase.last
					fPath=$_fn
				#DELETE_END#
					_t="/sbin/$fBase"
					if scp -O -p ${bQuiet:+-q} "$fPath" "$sSshUser:$_t" ; then
						_msg="$fPath copied to $_t"
						cMR OK "path=$_t"
						cAddSuccHost
					else
						_t="/tmp/$fBase"
						if scp -O -p "$fPath" "$sSshUser:$_t" && cSsh "rm /sbin/$fBase ; ln -s $_t /sbin" ; then
							_msg="$fPath copied to $_t and linked to /sbin"
							cMR OK "path=$_t"
							cAddSuccHost
						else
							_msg="scp $fPath to /sbin or /tmp both failed"
							cMR ERROR "$_msg:"
						fi
					fi
				#DELETE_BEGIN#
				fi
				#DELETE_END#
				dbg FILECOPY "$_msg"
				T $bQuiet || cSsh "[ -r .config/$MP ] && $fBase -c echo+FILECOPY || $fBase -m $LH,$hPubMqtt -c echo+FILECOPY" 2>$fNul & # dont wait for this...
				sleep 2
				rm $_fn #DELETE_LINE#
				;;
			sh)
				cProbeNOMQTT
				for i in $(seq "${cmdopts:-1}") ; do
					cMR ONGOING "Trying shell (i=$i at $(date +%T))"
					ping -W1 -c1 $hTarget >$fNul ; _rc=$?
					T $_rc = 0 -o $_rc = 2 && ssh $sSshUser && break
					dbg PING "rc=$_rc"
					cS 4
				done
				;;
			homie-update|discovery-update)
				cProbeGET
				_cmd="cat /proc/uptime"
				homieuptime="$( T "$hFull" = $LH && $_cmd || $0 -h "$hFull" "$_cmd"  )" && hLine \$stats/uptime "${homieuptime%%.*}" -M # "$(p "$homieuptime" | cCut . )" -M
				cStackCmd "localclients,wifistate,gluondata,machine-data"
				;;
			homie-delete|discovery-delete)
				cProbeSET
				homie="$(cLower $hTarget)" # duplicated code...
				cDisco "$homie" -d
				;;
			wifidown) # stop Gluon public interface
				cProbeSET
				cGetPubIF || cntnue # also sets sPubIfs and sSsidBase
				dbg PREPARING "$cmd($cmdopts) on $hTarget (if=$sPubIf0,$sPubIf1) ..."
				cSsh "{ iw dev $sPubIf0 del ${sPubIf1:+; iw dev $sPubIf1 del >$fNul} ;} 2>&1"
				_tmp="$(cOut|xargs)"
				if T $ssh_rc = 237 -o $ssh_rc = 1 ; then
					cMR OK "$_tmp (rc=$ssh_rc)"
					hLine publicwifi/clientscount 0 && _tmp=""
				elif T -z "$_tmp" -a $ssh_rc != 0 ; then
					cMR ERROR "tempstr=$_tmp:"
					hLine publicwifi/clientscount 0 && _tmp=""
				else
					cMR OK "tempstr=$_tmp"
				fi
				cStackCmd wifistate
				;;
			wifiup|wifistate) ## determine state of open/guest wifi network, N.B. ffstatus etc. is obsoleted
				cProbeGET
				cIsNonGluon && { cMR -e ERROR "$hTarget is NONGLUON:" ; cntnue ;}
				cGetPubIF || cntnue # abort command if no public interface is found (error msg emitted in cGetPubIF)
				cIsOpt OFF && cStackCmd wifidown && continue
				cIsOpt ON  && cmd=wifiup
				dbg PREPARING "$cmd($cmdopts) on $hTarget (if=$sPubIf0,$sPubIf1) ..."
				_scmd="command -v iw >$fNul 2>&1 && iw $sPubIf0 info || uci show wireless.client_radio0.ssid || uci show wireless.ap_gn_g.ssid" # .. fallback to uci-setting ... and ignoring any 2nd interface for now
				ssh_data=""
				if cIsCmd wifiup ; then
					cProbeSET
					_scmd="wifi up && sleep $nWifiSleep && $_scmd"
					cMR ONGOING "Running $_scmd"
					cSsh "$_scmd"
				elif T "$sNewSSID" ; then
					ssh_rc=0
					dbg REUSED "sNewSSID=$sNewSSID"
				else
					cMR ONGOING "Running $_scmd"
					cSsh "$_scmd"
				fi
				ssh_data="$(cOut|tail -14)" # shorten away the long redundant error msg from stdout from iw
				# dbg TAILED "$ssh_data"
				if ! T "$sNewSSID" ; then # ... was cached or if not cached, not unreachable
					sNewSSID="$(cOut|sed -n -e "/\.ssid=/{s/.*=//;s/[']//g;p;q}" -e "/ssid/{s/\tssid //;p;q}")" # coerced uci and iw output to get results # for iwinfo: -e '/ESSID:/{s/[^:]*: //;s/\"//g;p;q}'
					if T $ssh_rc = 0 && T "${ssh_data#"Interface $sPubIf0"}" != "${ssh_data}" -o "${ssh_data#wlan}" != "${ssh_data}" ; then
						dbg SUCCESS "$ssh_data"
						sChannel24="$(cOut|awk '$1=="channel" {print$2}' )" # works for iw
						cMS 	/publicwifi/state	ON -M
						hLine	publicwifi/state	true  -M
						cBothMqtt 	radio/channel24 	"$sChannel24" -M
					else
						if cData ; then
							dbg "command=$cmd, rc=$ssh_rc, ssh_data=$ssh_data"
							if T $ssh_rc = 255 || cOut | grep -w -q -E "open failed|connect failed" ; then # unreachable
								cMR OFF "rc=$ssh_rc ($ssh_msg)"
								( cS 60 ; echo PERIODIC NOOP sooner ) > $fPipe & # inject for a sooner repeat
							elif T "${ssh_data#"$sPubIf0"}" = "${ssh_data}" ; then
								cMR OFF "rc=$ssh_rc (interface missing or down)"
							else
								cMR ERROR "rc=$ssh_rc // $(cOut|xargs)"
							fi
						fi
						cMS 	/publicwifi/state	OFF 	-M
						hLine	publicwifi/state	false	-M
						cBothMqtt 	publicwifi/clientscount 0
					fi
				fi
				if T "$sNewSSID" ; then
					cEcho "$sNewSSID"
					_ssid="$( p "$sNewSSID" | sed -e 's,.*/,,' -e 's,\",,g' )"
					cMR OK "$sNewSSID"
					cBothMqtt publicwifi/ssidshort "$_ssid" -M
					cBothMqtt publicwifi/ssid "$sNewSSID" -M
					sNewSSID= # empty cached SSID
				else	
					cMR ERROR "SSID is empty:"
				fi
				;;
			ffcond)
				cntnue # FIXME
				cProbeGET
				cGetPubIF || cntnue # also sets sPubIfs
				cSsh '{ for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | tee $dCache/wifis ; echo ++++++++++++ ; iwinfo | grep sPubIf0'
				ifresult="$(cOut|grep -A 3 '++++++++++' | grep -m 2 "client0 *ESSID:" )"
				cErrAndExit UNFINISHED # FIXME
				if cOut|grep -A 9 -w '6e:a3:09:ea:31:e00' | grep -w "SSID:.$sSsidBase"
				then
					cEcho "To be upped..."
					T "$ifresult" || cStackCmd wifiup
				else	
					cEcho "To be downed..."
					T "$ifresult" && cStackCmd wifidown # FIXME: Correct && ?
				fi
				dbg cmdsToDo "$cmdsToDo"
				# ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )	) || ( iwinfo | fgrep client0 && iw dev client0 del ; echo if downed )
				;;
			ffchannel24|ffchannel24-*|channel24|channel24-*|radiochannel24set)   # FIXME: only implemented for 2.4Ghz (=first) radio
				cProbeGET
				cGetPubIF 0 || cntnue # gets sPubIfs, sSsidBase, and prepares channel
				_val="$cmdopts"
				T "$_val" || _val=$cmd
				_val="${_val#ff}" ; _val="${_val#channel24}" ; _val="${_val#-}" #  remove any of ffchannel24- ffchannel24 channel24- channel24
				IFS=_ set -- $_val
				unset IFS
				cmd=channel24
				if T "$1" ; then
					if T "$(cSaniNum "$1$2" )" || T $1 -lt 1 -o $1 -gt 13 || { T "$2" && T $2 -lt 36 -o $2 -gt 165 ;} ; then
						cMR ERROR "Illegal channel: $1 or $2"
						cntnue
					else
						_r1=wireless.radio0.channel
						_r2=wireless.radio1.channel
						cMR ONGOING "Setting $_r1=$1 ${2:+$_r2=$2 }(if=$sPubIf0,$sPubIf1)"
						cSsh "uci set $_r1=$1 && ${2:+uci set $_r2=$2 &&} wifi up && sleep $nWifiSleep && { iwinfo $sPubIf0 info ${2:+; iwinfo $sPubIf0 info} ;} | grep -wi channel 2>&1" || # FIXME: ignoring any 2nd interface # iwinfo $sPubIf0 info
							cMR ERROR
						dbg "_result=****$ssh_data****"
					fi
				fi
				cStackCmd wifistate # ... implicitly followed by a wifistate
				;;
			limit) # deprecated use of _ and - in cmdopts
				cProbeSET
				_tmp="$cmdopts"
				T "$_tmp" || _tmp=$cmd
				_tmp=$(cSaniNum "${_tmp#limit-}") || cntnue # abort for security reasons
				# cErrAndExit UNIMPLEMENTED  # FIXME
				T "$_tmp" -lt 50 -a "$_tmp" -ne 0 && cMR -E ERROR "Illegal limit: $_tmp" && cntnue
				cMR ONGOING "Setting gluon.mesh_vpn.limit_*gress=$_tmp"
				cSsh "uci set gluon.mesh_vpn.limit_ingress=$_tmp && uci set gluon.mesh_vpn.limit_egress=$_tmp && gluon-reconfigure 2>&1" || # FIXME: ignoring any 2nd interface # iwinfo $sPubIf0 info
					cMR ERROR
				dbg "_result=***$ssh_data***"
				# FIXME: more code to be added
				# ...
				;;
			wifissid) # deprecated use of _ and - in cmdopts
				# dbg "cmd=$cmd,cmdopts=$cmdopts"
				cProbeGET
				cGetPubIF 0 || cntnue # sets sPubIfs and sSsidBase
				# dbg XXX "cmd=$cmd($cmdopts)"
				T "$sSsidBase" || { cMR ERROR "Current SSID base empty - no change" ; cntnue ;}
				# _tmp="${cmdopts:-welt}"
				_tmp="${cmd#wifissid_}"
				_tmp="${_tmp#wifissid-}"
				_tmp="${_tmp#wifissid}"
				_tmp="${_tmp:-$cmdopts}"
				T "$_tmp" || { cStackCmd wifistate ; cntnue ;}
				_ssid="$(cTrd '}{)( ,=' "${_tmp:-welt}")"
				_domain="$(expr substr "$_ssid" 1 \( "$_ssid" : ".*/\|.*\.[0-9a-z]*" \) )"
				_ssid="$(expr substr "$_ssid" $(( ${#_domain} + 1 )) 99)"				
				dbg ssid "$_domain  $_ssid"
				T "$_ssid" = MYHOSTNAME && _ssid="%s"
				# further checks for allowed and legal SSID values among the gluon domains ....
				if { T "$_ssid" = OFFLINE -o "$_ssid" = "%s" -o "$_ssid" = $hTarget || 
							expr "$(cGetGluonDomainsStarred)" : ".*[*]$_ssid[*]" >$fNul && T "$_ssid" ;}  &&
						{ T -z "$_domain" || expr "$_domain" : "[a-z0-9]*.freifunk.net" ;} ; then
					_ssid="${_domain:-$sSsidBase/}$_ssid"
					cMR ONGOING "Intended SSID: $_ssid:"
					dbg INTENDEDSSID "$_ssid"
				else
					cMR -E ERROR "Illegal (short) ssid: $_domain$_ssid"
					cMS /gluondata/gluon-domains "$(cGetGluonDomainsStarred)"
					cntnue
				fi
				cSsh ": set -x &&
						_hn=\"\$(tr A-Z a-z <$fHost)\" &&
						prevssid=\"\$( iwinfo $sPubIf0 info | sed -e 's/: /:/' -e '1q' | cut -d: -f2 | xargs )\"  &&
						other=\"\$( printf %s \"$_ssid\"| sed -e \"s,%s,\$_hn,\" )\"  &&
						otheresc=\"\$( ec\"ho\" \"\$other\" | sed -e 's,/,\\\\/,' )\"  &&
						ec\"ho\" SSIDPREV:\$prevssid | awk \"{print} /\$otheresc/ { exit(99) }\"  &&
						[ \"\$prevssid\" ] &&
						iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' | awk \"{print} /\$otheresc/ { exit(99) }\" &&
						uci set wireless.client_radio0.ssid=\$other ${sPubIf1:+&& : $sPubIf1 && uci set wireless.client_radio1.ssid=\$other} &&
				        wifi up && sleep $nWifiSleep ;
						[ $bDoAll ] && uci commit ;
						iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDNEW/' -e '1q' " # FIXME: ignoring any 2nd or further interface
				# echo ----------------
				dbg RESULT "$ssh_data"
				prev_ssid="$(cOut | awk -F: '/SSIDPREV:/ {print$2;exit}')"

				if ! cData ; then
					cMR -E ERROR "error: $ssh_rc ($ssh_msg) OR ssh data empty, aborting command $cmd..."
				elif T "$prev_ssid" ; then
					sNewSSID="$(cOut|grep -m 1 SSIDNEW: | cCut : 2 | xargs)"
					_m="previous=$prev_ssid, new=$sNewSSID"
					if T "$prev_ssid" = "$sNewSSID" ; then
						_m="$_m (NO CHANGE)"
					else
						sNewSSID=""
					fi
					cMR OK "$_m"
					cStackCmd wifistate # ... implicitly followed by a wifistate
				fi
				;;
			gluonreconfigure)
				cProbeSET
				cGetPubIF || cntnue # sets sPubIf* and sSsidBase
				cMR	ONGOING "Affected interfaces: $sPubIfs"
				# 6 seconds needed for s after wifi up !
				cSsh "iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' ; gluon-reconfigure | tail -3 ; wifi up ; sleep $nWifiSleep ; iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDNEW/' -e '1q' "
				dbg $cmd "$ssh_data"
				prev_ssid="$(cOut |grep SSIDPREV| cCut : 2 )" # client0;SSIDPREV:"muenchen.freifunk.net/jupiter";Access Point: 26:7E....
				new_ssid="$( cOut |grep SSIDNEW	| cCut : 2 )"
				cEcho "$hTarget: Ran gluon-reconfigure, previously $prev_ssid, then wifi up, then $new_ssid.\n"
				T "$prev_ssid" != "$new_ssid" && cStackCmd localclients # ... will clear previous values
				cStackCmd wifistate # ... implicitly followed by a wifistate
				;;
			site)
				cProbeGET
				# cGetSitecode FRESH
				if T "$sSite" ; then
					cmd=gluondata # FIXME: Is this an artefact ?
					cEchoPub site $sSite
				else
					sSite=UNKNOWN
					cMR -e ERROR
				fi
				;;
			gluondata)
			  if ! os_data="$(cGetOSData)" ; then
			  	cMR -E ERROR "Empty OS data"
			  else
			    # get all infos in one call (line by line):
				cSsh "{ uci get autoupdater.settings.branch && uci get autoupdater.settings.enabled && uci get gluon.core.domain ;
					lua -e 'print(require(\"platform_info\").get_model())' ; cat $dGluon/gluon-version ; cat $dGluon/release ;} 2>&1"
	
				cEchoPub os-data "$os_data"	
				cEchoPub autoupdater-branch 	"$(cLine 1)"
				cEchoPub autoupdater-enabled	"$(cOut|sed -n -e 2s/0/false/ -e 2s/1/true/ -e 2p)"
				cEchoPub core-domain	"$(cLine 3)"
				cEchoPub model	"$(cLine 4)"
				cEchoPub gluon-version	"$(cLine 5)"				
				cEchoPub release	"$(cLine 6)" "$(cOut|sed -n -e 's/^v//' -e 6p)"
				cEchoPub gluon-domains	"$(cGetGluonDomainsStarred)"
				cEchoPub site $sSite
			  	cMR OK
			  fi
			  ;;
			gluon-info)
				cProbeGET
				if cSsh "gluon-info" ; then
					cEcho
					data="{$(cOut|awk -F: '{gsub(/^[[:space:]]*/,"",$2); printf c "*%s*:*%s*", $1, $2 ; c="," }' )}"
					cMS /$cmd ""
					cAddSuccHost
				else
					cMR -e ERROR
				fi
				;;
			machine-data)
				os_data="$(cGetOSData)"
				dbg os_data "$os_data"
				cSsh "command -v $MP || echo NONE ; cat /proc/version /proc/cpuinfo ; command lscpu > /dev/null 2>&1 && lscpu" # deal with different output formats
				data="$(cOut|awk -v os_data="$os_data" '
					NR==1 {mpub=$1}
					NR==2 {lxversion=$3 ; FS=": " }
					/^machine|^Hardware|^Model|odel name/ { FS=": " ; printf "{*mosquitto*:*%s*,*linuxversion*:*%s*,*machine*:*%s*,%s}", mpub, lxversion, $2, substr(os_data,2,length(os_data)-2) ; exit 0 }
					' )"

				if T "$data" ; then
					cEcho "$(cStarredToJSON)"
					cMS /$cmd "" -M
				else
					cMR -e ERROR "$cmd failed: no output data"
				fi
				;;
			speedtest|speedtest0*)
				cProbeGET
				_spparam="${bVerbose:+-q}" ; _spparam="-q --no-check-certificate"
				sLastSpeed="$(cCRead .lastspd 1)" && sLastSpeed=",*lastSpeedMb*:$sLastSpeed"
				_spcmd="$( T $bDoAll || cCRead .lastspdcmd 2)" # prefer the previous one for at most 2 days
				T -z "$_spcmd" -o $cmd = speedtest0 -o $cmd != "${cmd#"$_spcmd"}" && _spcmd=$cmd # make it at least as big as the previous max.
				# _u="15MB 30MB 70MB 150MB 250MB 300MB" # https://link.testfile.org/15MB
				# _u="1MB 5MB 10MB 50MB 100MB 512MB 1GB 2GB 5GB 10GB" # http://speedtest.tele2.net/1MB
				_u="5MB 10MB 20MB 50MB 100MB 200MB 512MB 1GB" # http://ipv6.download.thinkbroadband.com/5MB.zip
				# _u="100M 1G 10G" # http://speedtest.belwue.net/100M
				T "$_spcmd" = speedtest && _spcmd=speedtest0
				_sht=${_spcmd#speedtest}
				_url="$(e $_u | cut -d" " -f ${#_sht} )" # cut out the x'th element
				if T -z "$_url" ; then
					cErr "speedtestcmd '$_spcmd' too excessive or fetching failed!"
					cMR ERROR "Last result ${_val}s or file size ${filesize}B too small"
					cCWrite .lastspdcmd speedtest0
					cntnue
				fi
				# _url="https://link.testfile.org/$_url" ;
				# _url="http://speedtest.tele2.net/$_url.zip" ;
				_url="https://ipv6.download.thinkbroadband.com/$_url.zip"
				# _url="http://ipv4.download.thinkbroadband.com:80/$_url.zip" # IPV4 doesn't work in Freifunk?
				# _url="http://129.143.4.238/$_url"
				# _url="http://speedtest.belwue.net/$_url"
				# dbg SPEEDTEST "Using $_url ..."
				cMR ONGOING "Trying $_url"
				if cSsh "date -u +%s; wget $_spparam -O - $_url | wc -c ; date -u +%s" ; then
					starttime="$(cLine 1)"
					filesize="$(cLine 2)"
					endtime="$(cLine 3)"
					_val="$((endtime - starttime))"
					speedMB="$( awk "BEGIN { printf \"%.2g\" , $filesize*8 / ($_val+0.000001) / 1048576}" )"
					if T "$filesize" -lt 20000 ; then
						dbg "File size ${filesize}B for $_url too small, will abort."
						cStackCmd speedtest0000000000 # head for abort
					elif T "$_val" -lt 11 ; then
						_spcmd="${_spcmd}0" # try next bigger size
						_s="Result ${_val}s too small for file size ${filesize}B"
						cMR ONGOING "$_s. Retrying larger file (*speedMb*:*$speedMB*)"
						cCWrite .lastspdcmd "$_spcmd" # cache bigger file speedtest for next time
						cStackCmd "${_spcmd}"
					else
						cEcho "$speedMB"
						cMS /speedtest "{*speedMb*:$speedMB,*filesize*:$filesize,*elapsed*:$_val,*unit*:*Mb/s*${sLastSpeed}}"
						cCWrite .lastspd "$speedMB"
						cAddSuccHost
					fi
				else
					cMR -e ERROR "{*ERROR*:*$ssh_rc*,*url*:*$_url*${sLastSpeed}}"
				fi
				;;
			state)
				cSsh "cat /proc/uptime /proc/loadavg && df -k" || { cMR -e ERROR ; cntnue ;}
				cEcho
				data="$(cOut|awk -v v=$sMeAge -v r=$(cRan) '
					NR==1 { printf "{*uptime*:%d", $1 }
					NR==2 { printf ",*load*:%.2f,*version*:*%s*,rantime=%d",$1,v,r } # uptime in seconds
					$6 == "/" { printf ",*available*:%d,*percent*:%d}",$4,100-$5 }' )"
				cMS /$cmd
				;;
			printmap) 
				# for older non-Gluon systems, probably gone in 2023 or before
				cProbeGET
				cSsh print_map.sh || { cMR -e ERROR ;cntnue;} # Freifunk node info as JSON for non-Gluon systems, e.g. from earlier Ulm firmware
				cOut|json_pp
				cMS /$cmd "$ssh_data"
				;;			
			localclientscount)  
				# works  for ffmuc only currently
				# wget https://gw04.ext.ffmuc.net/nodelist.json
				# jsonfilter -e '@.nodes[@.name="Ares"].status.clients' < n.json
				cProbeGET && cCmv jq || { cStackCmd localclients && cntnue ;}
				_w="https://gw04.ext.ffmuc.net/nodelist.json"
				_f=$dCache/nodelist.json
				# if no file or older then 1 minute then get a new one
				T -f $_f && T $(date +%s -r $_f) -gt $(( $(date +%s) - 60 )) && { dbg "$_f" "is fresh" ; : ;} ||
					{ dbg "$_f" "not fresh" ; wget ${bQuiet:+-q} $_w -O - | jq . - > $_f ;} || { cMR ERROR "wget failed" ; cntnue ;}
				# extract the clients count from the json file where name is hTarget
				_n=$(jq -r ".nodes[] | select( (.name|ascii_downcase) ==\"$hTarget\") | .status.clients" < $_f)
				T ${_n:-0} -gt 0 && { dbg COUNT "$_n" ; cStackCmd localclients ;} && cntnue # if there are clients, then get them later
				T "$_n" = 0 && cEcho "$_n" || cErr "No client count found for $hTarget" 
				cMS /publicwifi/localclients "{ *count*:${_n:-null}, *localclients*:[],*node*:*$hTarget* }" $(T "$cmdopts" || e "-M")
				T $bWorkAllClients && nLocClients=$((nLocClients + _n))
				;;
			localclients)
				cProbeGET
				T ! -d $dGluon -a $hFull = $LH && { ! T $bWorkAllClients && cMR -e ERROR "$cmd on Gluon" ; cntnue ;}
				fCollection=$dTmp/clientcollection
				touch $fCollection && chmod g+w $fCollection
				fClients=$fCollection.$hTarget
				# fManu=$dCache/manuf
				cR $fMacIDs || touch $fMacIDs || fMacIDs=$fNul

				# get the two table of the local clients on the node together, split them in awk further down
				if ! cSsh "batctl dc && echo === && batctl tl" ; then
					_msg="$sSshUser unreachable or batctl" # .. failed
				  	cMR -E ERROR "$_msg:"
					cntnue
				fi
				cAddSuccHost
				dbg "**1" " result batctl dc/tl ***" && cOut # output of both batctl commands
				# Split and merge all data together... :
				cOut|awk -v a=$bDoAll 'ARGIND==1 {FS=";";s[$1]=$2;next}  ARGIND>1 {FS=" "}  $1=="*" {i[$3]=$2;l[$3]=$5;next}  $3=="[....W.]" {print $1";"s[$1]";" strftime("%F" (a?"_%T":"")) ";" i[$1] ";" l[$1]}' $fMacIDs - > $fClients
				dbg "**2" " fClients=$fClients ***" && cat $fClients # mac;name;time;ipv4

				_n=$(cCount<$fClients)
				hLine publicwifi/clientscount $_n -M

				while IFS=\; read -r _mac _name _time _ipv4 _seen ; do
					_vdr="$(cGetMacVendor "$_mac")"
					_ping=null ; T $sSshUser = LOCAL && { ping -q -W 2 -c 3 $_ipv4 >$fNul && _ping=1 || _ping=0 ;}
					_m=${_seen%:*} # the minutes
					_seen=${_seen#*:} # the seconds
					T "$_seen" && _seen="$(( 60 * _m + ${_seen#0} ))" # convert mm:ss to seconds
					_line="$_time;$_mac;$hTarget;$_vdr;$_name;$_ipv4;$_ping;$_seen"
					dbg IP "*$_mac* *$_name* *$_vdr* *$_time* *$_ipv4* *$_ping* *$_seen*" # IP: *6e:95:18:16:87:58* *Thomas3* *MySamsung* *2024_**
					p "$_line" >> $fCollection # NEW! : # write  time;mac;node;vendor;name  to collection file, too
					p "$_line"
					cMS "$sSite/$sArea/$(cTrd : "$_mac")" "{*node*:*$hTarget*,*mac*:*$_mac*,*name*:$(s "$_name"),*vendor*:$(s "$_vdr"),*ipv4*:*$_ipv4*,*pingable*:$_ping,*lastseen*:$_seen}" -M
				done <$fClients >$fClients.2
				data="{*count*:$_n,*localclients*:[$(awk -F\; -v bA=$bDoAll -v hname=$hTarget '{
						printf lim "{*addr*:*%s*,*name*:*%s*,*vendor*:%s,*ipv4*:*%s*,*pingable*:%s%s}", $2, $5=="" ? $2 : $5, $4=="null" ? "null" : "*"$4"*" , $6, $7, (bA) ? ",*lastseen*:"$8 : "" ; lim="," }' $fClients.2 |
						shorten_ethernet_addr_in_json no)],*node*:*$hTarget*${cmdopts:+,*opts*:*$cmdopts*}}"
				cEcho "$(cStarredToJSON|json_pp)"
				cMS /publicwifi/localclients ""	$(T "$cmdopts" || e "-M")
				T $bWorkAllClients && nLocClients=$((nLocClients + _n))
				collectedclients="$collectedclients $(xargs <$fClients.2)"
				collectedclients="${collectedclients% }" # trim any leading spaces
				rm -f $fClients $fClients.2
				;;
			nodeinfo|neighbours|statistics)
				cProbeGET
				## ssh_rc=0
				ffnodeip="$(cCRead .nodeip)" || ffnodeip="::1"
				T "$ffnodeip" = NONGLUON && { cMR -e ERROR "Non-Gluon node" ; cntnue ;}
				## _msg="IP of remote node undeterminable ($ffnodeip)"
				## if T $ssh_rc = 1 -o "$ffnodeip" = NONGLUON ; then  # FIXME
				##   	cMR -E ERROR "$_msg:"
				## 	## T $ssh_rc = 1 && cCWrite .nodeip NONGLUON
				## 	cntnue
				## elif T $ssh_rc != 0 ; then
				##   	cMR -E ERROR "$_msg:"
				## 	cntnue
				## fi
				## ## cCWrite .nodeip "$ffnodeip" # cache the value
				_cGNI="gluon-neighbour-info -i br-client -r $cmd" # ipaddr will be appended further down ...
				T $sExtraOption && hFull="$sExtraOption" && sExtraOption="" # use another host to query the remote one ...
				cSsh "$_cGNI -d $ffnodeip"
				dbg $cmd "Had called $_cGNI -d $ffnodeip (rc=$ssh_rc,${#ssh_data} bytes)" && _val="$ssh_data"
				if T ${#ssh_data} -le 1  ;  then
					T $ssh_rc = 127 && cCWrite .nodeip NONGLUON # non-Gluon node: gluon-neighbour-info cmd missing
					cMR -e ERROR # "result empty (ssh_data=$ssh_data):"
				else
					cAddSuccHost
					cCWrite .nodeip "$ffnodeip" # cache the value # FIXME: currently no sense because always ::1
					p "$ssh_data" >$fTmpMqtt
					cCWrite .$cmd # cache the whole data to support change detection in the future
					cEcho
					cMqtt /$cmd "$ssh_data" -M
					if cIsCmd statistics ; then
						# node_id=$( jq -r .node_id $fTmpMqtt )
						# cMqtt /nodeid "$node_id" "-r"
						### cMqtt "$sSite/$node_id/$cmd"  "$(cat $fTmpMqtt)"  "-r"
						# cMqtt /ipv6 "$ffnodeip" "-r"
						### cMqtt "$sSite/$node_id/ipv6"      "$ffnodeip" "-r"
						cFilter .clients.wifi < $fTmpMqtt
						# echo $ssh_data
						#		cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi RX bytes"   "value_json.traffic.rx" counter
						# 		cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi TX bytes"   "value_json.traffic.tx" counter
						cMS /clients "" -M
						T $bWorkAllClients && nLocClients="$(( nLocClients + data ))"
						# cMqtt "$sSite/$node_id/clients" "$data"
					fi
				fi
				;;
			showsite|addresses)
				cProbeGET
				cIsCmd addresses && _scmd="ip -6 -j addr show" || _scmd="gluon-show-site"
				if cSsh "$_scmd" ; then
					cMqtt /$cmd "$ssh_data"
					T $bQuiet || cOut | json_pp
					cAddSuccHost
				else
					cMR -e ERROR
				fi
				;;
			memory)
				cProbeGET
				if cSsh 'free -t | tr -cd "0-9 a-zA-Z:\n"' ; then
					# cStarredToJSON "$(cOut|cTableToJSON 1)" | json_pp
					cEcho
					cMS /$cmd "$(cOut|tr -d :|cTableToJSON 1)"
					cAddSuccHost
				else
					cMR -e ERROR
				fi
				;;
			sleep)
				cProbeNOMQTT
				o=51
				cIsOpt "" || o="$cmdopts"
				T "${o%%[0-9]*}" = var && n=${o#var} && o=$(printf %d "'$(cLower $hTarget)") && o=$(( (o-97)/4+4+ ${n:-0} ))
				T $o -gt 12 && dbg $cmd "Sleeping $o secs..."
				T $cmdsToDo && cMR ONGOING :
				cS "$o"
				;;
			ps|pstree)
				cProbeNOMQTT
				_n=6
				if cIsCmd pstree && cSsh "pstree -sptal|grep -v \"$_n $cmdopts\"|grep -C $_n \"$cmdopts\"" ; then
					cEcho
				elif cIsCmd pstree && cSsh "{ ps axu 2>$fNul || ps w ;} |awk 'NR==1 || ( /$cmdopts/ && ! /$cmd.$cmdopts/) {gsub(/ busybox /,\" \");print}'" ; then
					cEcho
					cMS /$cmd "{*table*:$(cOut|cTableToJSON), *grepexp*:$(s "$cmdopts"), *count*:$(( $(cOut|cCount) - 1))}"
					cMS "/$cmd${cmdopts:+/$(cTrd -c "A-Za-z0-9.!-+" "$cmdopts")}" "{*table*:$(cOut|cTableToJSON), *grepexp*:*$cmdopts*, *count*:$(( $(cOut|cCount) - 1))}"
				else
					cMR -e ERROR
				fi
				;;
			mountsizes|mountsizes_prev)
				cProbeGET
				T $cmd != mountsizes_prev && cSsh "df -PhT" # little workaround to preserve the before/after datas when using "install"
				cmd=mountsizes
				if T $ssh_rc -ne 0 ; then
					cMR -e ERROR
				else
					cEcho
					data="[$(cOut | sed -E -e 's,([0-9])\.0K,\1K,g' | grep -E ' 0 |/$|tmp|boot|overlay' | awk '{print lim "{*mountpoint*:*" $7 "*,*type*:*"$2"*,*filesystem*:*"$1"*,*spaceavail*:*"$5"*,*spaceused*:*"$4"*,*percentused*:*"$6 "*,*spacetotal*:*" $3 "*}" ; lim="," }' )]"
					cMqtt "${sSite:-UNSET}/$hTarget/$cmd" "$(cStarredToJSON)"
				fi
				;;
			jsonify)
				cProbeNOMQTT
				cMS /$cmd "$(cTableToJSON)" # transforms stdin to JSON table consuming header line and column leads (see "memory" above)
				;;
			reboot)
				cProbeNOMQTT
				cMR ONGOING :
				_key="gluon-setup-mode.@setup_mode[0].enabled"
				cIsOpt config && _more="&& uci set $_key=1 && uci commit" || _more="" # reboot to config mode on next boot
				if cSsh "uci show $_key $_more && $cmd"  ; then
					dbg $cmd "$(cOut)"
					cMR OK # might not even get here if run locally ...
					cAddSuccHost
				else
					cMR -e ERROR
				fi
				;;
			# BEGIN_DELETE
			debug_msub) # FIXME: remove this after explore mosquitto_sub stalling bug
				# for i in $(seq 20) ; do  $MP -t ffmuc/herkules/echo/get -m $i ; echo $i ; cS 0 ; done
				if cIsOpt s ; then
					cMqttSub -t $sSite/\# -v -R | awk -v f=$fPipe '{print "//" $0 ; system("sleep 1") }'
					exit 0
				else
					for i in $(seq "${cmdopts:-5}") ; do
						# cMqtt /wifistate/get $i
						# cMqtt /state/get $i
						cMqtt /date/get $i
						cEcho $i
					done
				fi
				exit 0
				;;
			# END_DELETE
			checkprocs) # explore number of process started in pipe
				cProbeNOMQTT
				_n=20
				_d=$(cPid)
				for i in $(seq $_n) ; do
					# echo %s $i | awk '{print}'
					# echo %s $i | awk '{print}'
					# history | awk '{print}' > $fNul
					# cat $fNul | cat | awk '{print}'
					# date | awk '{print}'
					printf y
				done
				dbg $cmd "$(awk "BEGIN {print ( $(cPid) - $_d - 4) / $_n }" )" # number of processes started for one command in the for loop above
				;;
			networkprobe)
				cProbeNOMQTT
				cmdopts="${cmdopts##0}"
				_n="${cmdopts:-1}" # times to be repeated

				_awk() {
					awk -F: -v key="$1" '$1 ~ "\"" key "\"" && $0 !~ ".255.255" { gsub(/,$/, "",$2) ; gsub( / *\"$/, "",$2) ; gsub(/^ *\"/, "",$2) ; print $2 }'
				}
				
				# 0. determine exact network to scan
				_m=24 # 24 for /24, 27 for /27
				if T "$sExtraOption" ; then
					network="$sExtraOption" && sExtraOption=""
				elif ! network="$(cCRead .network 2)" ; then   # network="192.168.178.0" #  was fixed previously
					if cSsh "ip -j -p -4 addr show scope global" ; then
						network="$(cOut | _awk broadcast | sort -n | head -1)" && # numerically smallest, /24 network for now
						network="${network%.255}.0"
						cCWrite .network "$network" # cache the value
					else
						cMR ERROR # FIXME: Merge with cErr ?
						cErr "Command $cmd aborted:"
						cntnue
					fi
				fi
				# sRemoveList="^iPhoneSH ^GalaxyS20FE ^S20-FE-von-S ^A52s-von-S ^constructa" # FIXME: optionalize this
				fScanTmp=$dTmp/$cmd
				fList=$dCache/$network.list.txt

				# 1. scan for known devices and provide local, reverse DNS....
				# https://nmap.org/book/reduce-scantime.html
				# https://hackertarget.com/nmap-cheatsheet-a-quick-reference-guide/
				dbg2 NMAP1a "nmap -oG - -sL $network/$_m"
				ssh_data=$( cSsh "nmap -oG - -sL $network/$_m" && cOut |
						awk '$3 ~ /^\(.+\)/ {print $2 ";" gensub(/[)()]/,"","g",$3)}' ) || # all hosts known by DNS
					cntnue # FIXME: more error info, e.g. nmap not properly installed ?
				cEcho
				cOut > $fList
				T "$fFile" && cOut > $fFile.list.txt && dbg "NMAP1b" "Also saved to $fFile.list.txt"
				cMS "/$cmd/$network/known" "{ *knowndevices* : $( { echo ";name" ; cOut ;} | cTableToJSON 0 \; ), *count*:$(cCount<$fList) }"
				
				# fFile: 192.168.178.23;fritz.repeater;32:91:AB:43:EA:FB;VENDOR;pingyes;http://192.168.178.23;;https://192.168.178.23

				# 2. ... now scan for (some) open ports....
				clean_scan() {
					# Starting Nmap 7.93  https://nmap.org  at 2024-01-09 10:30 CET
					# Nmap scan report for fritz.box (192.168.178.1)    ### if HOST MISSING > VPN-member
					# Host is up 0.0088s latency.
					# MAC Address: DC:39:6F:E4:4C:55 AVM Audiovisuelles Marketing und Computersysteme GmbH
					# ...
					awk -v OFS=\; '{
							if ($0 ~ /^Nmap scan report for/) { line=( $6!="" ? gensub(/[)(]/,"","g",$6) : $5 ) ";" $5 }
							if ($0 ~ /^Host is up/) { next }
							if ($0 ~ /^MAC Address:/) { print line,$3, gensub(/[)(]/,"","g", substr($0, index($0, $4))) }
						}' # | tee /tmp/bbb   # IP;HOSTNAME;MAC;VENDOR
				}
				netprobe() {
					#  FIXME: /24 instead /25 /26 (was for debugging!)
					nmap -sn "$network/$_m" | clean_scan | awk -F\; -v OFS=\; -v v=$bVerbose -v vv=$bVeryVerbose '{
						sfx=".tcp *open"
						nmapcmd="ping -q -W 1 -c 2 " $1 " >/dev/null && echo 0/tcp open && { nmap --host-timeout 1m --top-ports=10000 " $1 " && nmap -pT:5007,1883,9443 " $1 " ;} | grep -E \"^[0-9]+/tcp\" || echo 0/tcp NOT"
						if (v) { print "NMAP2+: running " (vv ? nmapcmd : $1) > "/dev/stderr" }
						while (nmapcmd | getline line) { res = res ";" line ; if (line~sfx) { ports=ports gensub(sfx ".*", "", 0, line) "," } }
						print $2,$1,$3,$4, res ~ ";0" sfx ? "pingyes" : "pingno", res ~ ";80" sfx ? "http://" $1 : "", res ~ ";22" sfx ? "ssh://" $1 : "", res ~ ";443" sfx ? "https://" $1 : "", gensub(",$","",0,ports)
						res=""
						ports=""
					}' # | tee /tmp/scanni.$USER
					set +x
				}
				genRemoveCmd() {
					printf "sed "
					echo "${*:-xyzx}" | awk -v RS=" " -v ORS=" " '{printf " -e /^%s/d", $1}'
				}

				dbg2 NMAP2 "nmap -sn $network/$_m ($_n times)"
				while T "$_n" -gt 0 ; do # now scan _n times for ports
					cMR ONGOING "Will do $cmd($network/$_m) number $_n."
					# IP;HOSTNAME;MAC;VENDOR;http://IP;ssh://IP :
					netprobe | eval "$(genRemoveCmd "$sRemoveList")" |
						awk -F\; -v OFS=\; 'ARGIND==1 {a[$2]=$3 OFS $4 OFS $5 OFS $6 OFS $7 OFS $8;next} {print $0 , a[$1] }' $fList > $fScanTmp
					dbg "NMAP3" "Scanned hosts of $network/$_m (n=$_n, $(date +%F), $(wc -l $fScanTmp) line in $fScanTmp )" && cat $fScanTmp

					diffres1="$(diff -N -bw -up -B -U 0 $fScanTmp.prev $fScanTmp 2>&1 | grep -v "^-$" )"
					diffres2="$(p -n "$diffres1" | grep -E '^\+[^+]|^\-[^-]' )" # only lines with one +/-

					T "$diffres2" && echo "$diffres2" | sed -E -e "s/^(.)/& $(date +%F) /" # insert space after +/-  # 1. Stdout Output
					echo "$diffres2" | grep "^+" |
						while IFS=\; read -r ip host mac vdr httpopen sshopen rest ; do    # 2. MQTT output only for lines with "+"
							ip="${ip#+}"
							cMqtt /$cmd/$network/member/$ip "$host  ${httpopen:+http://}$ip"
							cEcho "$host  ${httpopen:+http://}$ip ${sshopen:+ssh://$ip}"
						done
					# generate text file of the hosts and convert it to a very simple html:
					T "$fFile" && ! diff ${bQuiet:+-q} -U 0 $fScanTmp $fFile.scan.txt && {
						dbg NETWORKPROBE "Creating new $fFile.scan.html from $fScanTmp"
						cp -p $fScanTmp $fFile.scan.txt &&
							awk -F\; -v dat="$(date +%F_%H)" 'BEGIN {print "0.0.0.0", dat "<br/>"} /http/ {printf "%s <a href=\"%s\">http://%s</a><br/>\n", $1, ($8>"") ?$8:$6, $2 ;next} {print $1, $2 "<br/>"}' $fFile.scan.txt > $fFile.scan.html
						}
					cp $fScanTmp $dCache
					mv $fScanTmp $fScanTmp.prev
					_n=$((_n-1))
					T $_n = 0 || cS 9
				done
				cMR OK "Command $cmd($cmdopts): $network/$_m"
				;;
			networkscan) # use nmap to scan the local network for IP devices and for ports (option -a), too
				cProbeNOMQTT
				# -sV: Probe open ports to determine service/version info
				# --version-intensity 6 # the higher the more intense, default is 7
				# -O: OS detection
				# SPECIAL: nmap must be run as root or must have been privileged:  sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip $(which nmap)
				T $bDoAll && _opts="-sV --osscan-guess --version-intensity 5" || _opts="--osscan-limit --version-intensity 1"
				_opts="$_opts --privileged" # assure to nmap that is has the required privileges
				cmdopts="$(p "${cmdopts:-192.168.178.0/24}" | tr _ / )" # network to be scanned
				cMR ONGOING "With nmap options: $_opts:"
				data="$(nmap $_opts "$cmdopts" 2>&1 |
					awk '/scan report/ { ip=substr($6,2,length($6)-2) ; printf "%s{\"IpAddr\":\"%s\",\"host\":\"%s\"", lim, ip, gensub(/\..*/,"","g",$5) }
						/OS details:/ { gsub("OS details: ",""); printf ",\"OS\":\"%s\"}\n", $0 ; lim="," }
						/MAC Address:/ { gsub("MAC Address: ",""); printf ",\"mac\":\"%s\",\"vendor\":\"%s\"}\n", gensub(" .*","",0) , gensub(".* (","",0,gensub(")$","",0)) ; lim="," }
						/Failed to / { printf "*details*:*%s (or nmap rights?)*", $0 ; cExit99 }
					')"
				rc=$?
				if T $rc = 0 ; then
					cEcho "[ $data ]"
					cMqtt /$cmd "[ $data ]"
					cMR OK
				else
					cMR ERROR "{ $data }"
					T $rc = 99 && cErrAndExit "$data ; getcap: $(getcap "$(which nmap)") ;"
				fi
				;;
			wifiscan)
				cProbeNOMQTT
				# relies on the following entry in root's crontab, since only root is allowed to do a full wifi scan
				# SHELL=/bin/bash
				# * * * * * { /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ;} | fgrep SSID  | cut -d: -f 2 | xargs -n1 | sort -u > /tmp/wifis.txt
				# { for i in 2 2 2 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | fgrep SSID  | cut -d: -f 2 | xargs -n1 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt
				# * * * * * { for i in 1 2 1 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | egrep -w '^BSS|SSID'| sed -e 's/BSS *//' -e 's/(.*//' -e 's/\t*SSID: //' -e 's/^$/./' | xargs -L2 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt
				cGetPubIF || cntnue # sets sPubIf*

				if cSsh "[ \"$(id -u)\" = 0 ] || echo ERROR && iw dev $sPubIf0 scan ${sPubIf1:+&& iw dev $sPubIf1 scan}" ; then
					# data="$(cOut | awk '$1 ~ /^SSID/ { sub("\t*SSID: *", "") ; if (length($0)) print } {next}' | sort -u | cWordsToJsonArray)"
					ssh_data="$( printf "MAC\tsignal\tchannel\tauth\tSSID\n"
						cOut | awk '
							/^BSS / 	{ MAC 	= gensub("(.*", "", 1, $2) }
							/signal:/  	{ signal[MAC] 	= gensub(".00", "", 1, $2) }
							/SSID:/  	{ ssid[MAC] 	= gensub (".*: ", "", 0, $0) }
							/ Authentication suites:/  	{ auth[MAC] 	= gensub(" ", ";", 1, gensub(".*: ", "", 0, $0)) }
							/primary channel:/ { channel[MAC] = $NF }
							END {
								for (mac in ssid) { printf "%s\t%s\t%s\t%s\t%s\n", mac, signal[mac], channel[mac], auth[mac]==""?"null":auth[mac], ssid[mac] }
							} ' | sort -n -r -k 2 )"
					cEcho
					cMS /$cmd "$(cOut|cTableToJSON)"
				else
					cMR -e ERROR "rc=$ssh_rc // $ssh_data"
				fi
				cntnue

				# FIXME:
				dbg "$sMe: command scandirty grepping for **$sGrepSsid**"
				grep -wi "$sGrepSsid" "$dCache/wifis.txt"
				rm -f "$dCache/wifis.txt.hint"
				# exit 0
				;;
			*)
				_msg="Illegal command=:$cmd:"
				cProbeSET || cErrAndExit "$_msg"
				cErr "$_msg"
			esac
			T "$sSite" = UNDET -a "$ssh_rc" = 0 && cGetSitecode FRESH # retry getting site code if UNDETermined
		done
	fi
	
	T $# -gt 0 && { # ... everything that's left in "$*" is taken as additional shell commands, too....
		cSsh "$@" || cErr :
		cOut
	}
	hDone="$hDone,$hFull"
done

if T "$nLocClients" -o "$bWorkAllClients" ; then
	T "$bVerbose" -o "$nGiveHost" && ECHO "\n######  ALL CLIENTS(#$nHosts${nMaxGoneDays:+,${nMaxGoneDays}d}) " "$@" "######" >&${nGiveHost:-1} 2>&1
	T $nLocClients && cMqtt "$sArea/publicwifi/nodesseen" "${hDone#,}" -M && cMqtt "$sArea/publicwifi/allclientscount" $nLocClients -M

	if T $nLocClients && cR $fCollection ; then
		cSortAndTailFile $fCollection 2
		dbg fCollection "$fCollection:" && cat $fCollection # time;mac;node;vendor;name

		T "$bVerbose" -a "$bWorkAllClients" &&
			cMS "$sSite/$sArea/alllocalclients/debug" "$( { echo "addr;date;node;vendor;name;ipv4;pingable;seen" ; sort -t \; -k 1 $fCollection ;} | cTableToJSON 0 \; )"			

		 data="{*count*:$nLocClients,*hostcount*:$nHosts,*hosts*:$(echo $sHosts|xargs -n 1|cWordsToJsonArray),*id*:*$sArea*,*localclients*:[ $( awk -F\; -v quiet=$bQuiet '
			function s(str) {return (str=="null")?"null":"*"str"*"}
			{ printf lim "{*addr*:*%s*,*name*:*%s*,*vendor*:%s,*node*:%s,*time*:%s,*ipv4*:%s,*pingable*:%s,*seen*:%s}",
					$2, $5==""?$2:$5,s($4),s($3),s(quiet? "" : $1),s($6),s($7),$8; lim="," }' < $fCollection |
			shorten_ethernet_addr_in_json no) ]}"
		# cEcho "$data"
		cEcho "$(cStarredToJSON | json_pp)"
		# cEcho "$(cStarredToJSON | json_pp | tee /tmp/$sBase.lc.json)"
		cMS "$sSite/$sArea/alllocalclients" "" -M
		rm -f fCollection
	fi
fi

exit # now calling trap_EXIT()
# End of main.

# { echo TRUE  ; true  ;} || { echo TRUE  ; true ;} && echo YES ; cEcho ===
# { echo FALSE ; false ;} || { echo TRUE  ; true ;} && echo YES ; cEcho ===
# { echo TRUE  ; true ;}  || { echo FALSE ; false ;} && echo YES ; cEcho ===
# { echo FALSE ; false ;} || { echo FALSE ; false ;} && echo YES ; cEcho ===
# { echo TRUE  ; true  ;} || { echo TRUE  ; true ;} || echo YES ; cEcho ===
# { echo FALSE ; false ;} || { echo TRUE  ; true ;} || echo YES ; cEcho ===
# { echo TRUE  ; true ;}  || { echo FALSE ; false ;} || echo YES ; cEcho ===
# { echo FALSE ; false ;} || { echo FALSE ; false ;} || echo YES ; cEcho ===