#!/usr/bin/env ash
# shellcheck shell=ash

#
# manage_gluon_mqtt
#
# Monitor and control Freifunk nodes (Gluon) or OpenWrt nodes - by command line and MQTT
#
# Repo: https://github.com/sheilbronn/Manage-Gluon-MQTT

# Some fixed constants and prelimenary (fixed) settings ...
# semi-hungarian notation for vars: i(n)teger, (s)tring, (d)irectory, (c)ommand, (b)oolean usage, (f)ile, (h)ost, (_) local meaning only

# manage_gluon_mqtt -m localhost -v -c noop,ignore,echo,date,loop,filecopy,wifidown,wifiup,wifistatus,limit,ffcond,gluonreconfigure,site,gluondata,speedtest,status,printmap,localclients,nodeinfo,neighbours,statistics,showsite,memory

nWifiSleep=7 # seconds to sleep after "wifi up"
dGluon=/lib/gluon
sSite="" #  will be set to something like "ffmuc".... but you could also freeze it here
fMacIDs=/srv/openhab-conf/phones # file is only for presence detection in mapping known phones to known people at....
fNul=/dev/null
MP=mosquitto_pub
LH=localhost
C=comman"d"

cCmv()	{ command -v "$@" >$fNul ;} # find out whether a command exists
# cLower() { { [ "$*" ] && echo "$*" || cat ;} | awk '{print tolower($0)}' ;}
cLower() { awk -v s="$*" 'BEGIN {print tolower(s)}' < $fNul ;} # simplified for args only
# set -x ; cLower "AA Bb" ; exit 99
cPid() { sh -c 'echo $$' ;}
# echo TEST: ; cPid ; cPid ; exit 99

if cCmv busybox ; then # prefer busybox for performance, memory usage and compatibility
	alias awk="busybox awk"
	alias sed="busybox sed"
	alias tr="busybox tr"
	alias grep="busybox grep"
	alias xargs="busybox xargs -r"
	alias diff="busybox diff"
fi
	[ "$(ec\ho -e)" = "-e" ] && alias ECHO=ec\ho || alias ECHO="echo -e" # some echo's know -e, some not. /bin/echo would be needed for color generalized interpretation, in case -e not understood
	alias e=ec\ho
	# alias e="printf \"%b %b %b\\n\""
	alias l=loc\al # special quoting needed when compressing script for reduced storage
	alias cntnue=continue # word continue to be compressed (outside of awk!)
	alias c=con\tinue
	alias r=ret\urn
	alias p='pri\ntf %s\\n'

cTrd() { p "${3:-$2}" | tr -d ${3:+$1} "${3:+$2}$([ "$3" ] || p "$1")" ;} # delete some chars or their complement (-c) from a string
# set -x ; cTrd _- "Aa_Bb" ; echo ; cTrd -c _- "Aa_Bb" ; echo ; exit 99
alias cSanitize="tr -cd A-Za-z0-9_.%,\ -" # remove special, leave spaces and ,._-
cSaniOpt() { cTrd -c "/A-Za-z0-9_.%,\ -" "$OPTARG";}
alias cData='[ "$ssh_data" ]'
alias cOut='printf "%s\n" "$ssh_data"'
cLine() { cOut | sed -n "$1"p ;} # print line n of ssh_data

# Initialize our own variables:
bQuiet=""
bVerbose="" # set it to y here for debugging right from the start
set -o noglob  # set noglob will limit security and escaping problems
sMe=$(cTrd -c A-Za-z0-9_.- "${0##*/}") # script fails on purposes if its name contains white space
sBase=$(p $sMe | sed 's/\..*//')
sMe2="$(cTrd _ $sBase)"
sMID="$sMe2-$$"
sID=$(cTrd -c a-zA-Z0-9 $sMID) # sanitize the ID
sMeAge="$(date +%Y-%m-%d -r "$(readlink -f "$0")")"
sManufacturer=Linux
export ssh_rc=0
export ssh_data=

dUser=$HOME/.$sBase # user-specific data
fHost=/proc/sys/kernel/hostname
sArea=$(cat $fHost 2>$fNul || hostname || e UNKNOWN)
[ $sArea = openHABianPi -o $sArea = UNKNOWN ] && sArea="${sArea}-$( awk -F: '{print$5$6}' </sys/class/net/eth0/address )"
sArea=$(cLower "$sArea") # lowercase only
sSsidBase=UNKNOWN # would be an an error
sPubIfs= # will be determined on first call to every node, then cached
nMqttSleep=1199 # 1190
sHassPrefix=homeassistant/sensor
hPubMqtt=test.mosquitto.org
basetopic=xyz  # default MQTT topic prefix
sGrepSsid='.*'

umask -S u=rwx,g=rx,o= # no rights for others
alias cX="local - && set +x" # stop the local verbosity

# Notes for future enhancements:
# ping ff node and up/down own public if accordingly
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8ba && echo yes ) || echo no
# ( ping -c 3 2001:608:a01:103:62e3:27ff:febd:b8be && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iw dev client0 del ; echo if downed )
# scan repeatedly for public Wifi and up/down own public if accordingly:
# ( { for i in 1 1 1 1 2 ; do iw dev mesh0 scan ; sleep $i ; done } | fgrep -w '6e:a3:09:ea:31:e1' && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iw dev $sPubIf0 del ; echo if downed )
# ( { for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | egrep -A 9 -w '6e:a3:09:ea:31:e0' | grep SSID:.muenchen.freifunk.net/muc_sued && ( ( iwinfo | grep $sPubIf0 ) || ( wifi up ; echo wifi upped. ) ) ) || ( iwinfo | grep $sPubIf0 && iw dev $sPubIf0 del ; echo if downed )
# func() { echo yyy ; false ;} ; x="$(func)" && echo yes || echo no ; exit 

cHelp() {
  echo "Usage: $sMe ... -v -m mqttserver -p -s node -c command ...
   Execute commands on Gluon/Freifunk/OpenWrt nodes using uci and other commands. Returns output on stdout and/or MQTT.
   Either automatic (e.g. key-based) access to the Freifunk node using SSH or remote execution is supported.
   Implemented commands:" 1>&2
   _cel='\)(\s*#.*|)$' # = comment til eol
  grep -E "^\s*[a-z_|-]+$_cel" "$0" | sed -E -e "s,$_cel,," -e 's,\|, ,g'  | xargs echo 1>&2 # extract coammands from this shell script
  }

cSortAndTailFile() { # $1=file $2=col(1) $3=sep $4=lines(40) 
	cX
	local fTmp=$dTmp/tf
	local nCol="${2:-1}"

	[ -r "$1" ] && [ -w "$1" ] && sort -t "${3:-;}" -k $nCol "$1" | awk -F"${3:-;}" "!seen[\$$nCol]++" | tail -"${4:-99}" | sort -k $nCol > $fTmp &&
			cat "$fTmp" > "$1" && rm -f "$fTmp"
	[ "$bVeryVerbose" ] && dbg "cSortAndTailFile($1,$2,$3,$4): lines: $(wc -l <"$1")"
	}

cExtractVals() {
	local _tmp="$(e "$@" | xargs -n1)"
	_tmp="${_tmp#*=}"
	# dbg "cExtractVals returns: <$_tmp>" 1>&2
	e "$_tmp"
	}

cExpand() { # expand some shortcuts: $w: site, %s: host name of target, %g: intended MQTT group
	[ "$*" ] && awk -v a="$*" "BEGIN {gsub(\"%w\",\"$sSite\",a);gsub(\"%s\",\"$hTarget\",a);gsub(\"%g\",\"$mqttGroup\",a);print a}"
	}
# echo $(cExpand w=%w s=%s g=%g) ; exit 0

_helper() {
		cOut|awk -F= "/^$1=/"' {gsub("\"","");print$2}' 
    }
cGetOSData() {
	cX
	if ! _val="$(cCRead .os_data 1)" ; then
		cSsh "cat /usr/lib/os-release" || return $? # cancel func
		if cData ; then
			_val="$(cOut|awk -F= '
				BEGIN { lim="{*os*:{" } END {printf "}}"}
				{ gsub("\"", "*", $2) ; printf lim "*" tolower($1) "*:" $2 ; lim="," }' )" # generate new value
			cCWrite .os_data	"$_val"  # cache new obtained value
			cCWrite .os_pretty_name	"$(_helper PRETTY_NAME)"
			cCWrite .os_name	"$(_helper NAME)"
			cCWrite .os_id	"$(_helper ID)"
		fi
	fi
	p "$_val" 
	[ "$_val" ] # return 0 if non-empty
	}

cGetSitecode() { # $1=cachetimeout
	cX
	local data="$(cCRead .site 9)" # site code is quite stable...
	if [ -z "$data" -o "$1" ] ; then
		[ "$1" ] || data="$(cCRead .sitenotfound 1)" # dont do it every time, read a default for the rest of the day
		if [ -z "$data" -o "$1" ] ; then
			if cSsh "[ -d $dGluon ] && jsonfilter -e @.site_code <$dGluon/site.json || echo UNDET" 2>$fNul ; then
				[ "$ssh_data" = UNDET ] && data="$(cCRead .os_id 9)" || data="$ssh_data" # use a OS ID as site fallback if not on Gluon		
				cCWrite .site "$data"
			else
				data="$(cMostFrequentSite)" #  hack: use the most frequent local standard...
			fi
			[ "$1" ] || cCWrite .sitenotfound "$data"
		fi
	fi
	sSite="$data"
	dbg cGetSitecode "sSite=$sSite arg1=$1"
	}

cMostFrequentSite() {
		cX
		_tmp="$(find $dCache -name \*.site | xargs cat | sort | uniq -c | awk '{print$2;exit}' )"
		e "${_tmp:-UNKNOWN}"
	}

cGetHostname() { # $2=cachetimeout
	cX
	if ! ssh_data="$(cCRead .hostname "${1:-9}")" ; then
		cSsh "tr A-Z a-z <$fHost" || ssh_data="$hTarget"
		dbg cGetHostname "ssh_data=$ssh_data"
		cCWrite ".hostname"
	fi
	cEcho
	}

cCut() { cut -d"$1" -f${2:-1} $3 ; } # $1=seperator, $2=field(s) or 1, $3=file(s) or other options

cSsidBase() {
		sSsidBase="$(cOut | awk -F\; '{print$2;exit}' | tr -d \" | awk -F": " '{gsub("/.*","",$2); print $2}' )"
	}

cGetPubIF() { # $1=cachetimeout  ## TODO ## -1 for forced reloading
	cX
	sPubIfs=""
	sPubIf0=""
	sPubIf1=""
	if ! ssh_data="$(cCRead .ifs "${2:-9}")" ; then
		cSsh "$C -v iwinfo >$fNul && iwinfo" || { cErr "no iwinfo" ; cMqttReply ERROR "no iwinfo:" ; return $ssh_rc ;} # only iwinfo works for this
		ssh_data="$( { cOut ; echo "" ;} | awk '/^$/ {if (l~/Mode: Master;.*;Encryption: none/) print l;l="";next} {gsub("^ +",";") ; gsub(" {2,9}",";") ;l=l$0 ;next}' )"
		dbg REMOTE "Interfaces returned: $( cOut | head -10)"
		cSsidBase
		cData && [ "$sSsidBase" ] && cCWrite .ifs # ... cache only if at least one public Freifunk interface is up and running
	fi
	# set global variables $sPubIfs, $sPubIf0, $sPubIf1 and sSsidBase as side effects...
	sPubIfs="$(cOut | cCut \; | xargs | cSanitize )"
	if ! [ "$sPubIfs" ] ; then
		sPubIfs=ERROR
		_msg="Public interfaces empty, sPubIfs="
		dbg PUBLIC "$_msg"
		cErr "$_msg"
		cMqttReply ERROR "$_msg::"
		sSsidBase=""
		return $ssh_rc
	fi
	set -- $sPubIfs
	sPubIf0="$1" # 1st interface
	sPubIf1="$2" # 2nd interface if any (e.g. 5 Ghz)
	cSsidBase
	dbg PUBLIC "Interfaces: if0=$sPubIf0,if1=$sPubIf1 (ifs=$sPubIfs), ssidbase=$sSsidBase"
	return 0
	}

# echo :"$IFS":
# h() { local - ; IFS='' ; set -- $@ ; echo $2 ; }
# h "eins zwei" drei
# echo :"$IFS":   ;   exit 
# set -x ; d=yy ; h() {  if local d=xx ; ! false ; then echo yes$d ; else echo no$d ; fi ; echo $d: ; } ; h ; echo $d ; exit

cTableToJSON() { # table is read from stdin. numerical values are made unquoted. $1: (optional) number of missing headers, e.g. 1 in free -t
	cX
	awk -F "${2:- }" -v missHead="$1" '
		BEGIN { OFS=""
			getline
			NH=NF+missHead # NF: number of fields, NH: number of headers
			for (i=1; i<=NF; i++) names[i+missHead] = $i   # consume all the headers
			printf "["
		} {
			printf lim "{*%s*:{", tolower($1)
			for (i=2;i<=NF||i<=NH;i++) {
				if (i<NH){ 
					o=$i # take field value as output (be it empty or not)
				} else { # more fields than headers
					if (o>""&&$i>"") o=o" "
					o=o $i # collect extraneous fields into the last field
					if (i<NF) continue
					# now all fields are consumed
				}
				dq=(o ~ /^-?(0|([1-9][0-9]*))(\.[0-9]+)?$/) ? "" : "*"    # put no double quotes around numbers
				printf "*%s*:%s%s" , names[(i>NH)?NH:i] , o=="" ? "null" : dq o dq, (i<NF||i<NH) ? "," : "" # print it
				o=""
			}
			printf "}}"
			lim=",\n"
		}
		END {print "]"} '
  }
  # set +x ; { echo spalte1 spalte2 ; echo a1 11 12 13 14 15 16; echo b1 2x ; echo c1 31 32; echo d1 ;} | cTableToJSON 1 ; exit
  # set +x ; { echo "spalte1;spalte2" ; echo "a1;11;12;13;14;15;16" ; echo "b1;2x" ; echo d1 ;} | cTableToJSON 1 \; ; exit

cDelSimpleJsonAttr() { # $1: attr, $2: JSON-string  # but only covers very simple cases, i.e. with quotes or not  :(
    # jq -c "del($1)" <<< "$2"
	# attr="$1"
	#                     a) not the last in the set (,)            b) only one or last in the set
	echo "$2" | sed -E -e "s;\"$1\":(\"[^\"]*\"|[^,}]*)[ ]*,;;" -e "s;[ ]*,[ ]*\"$1\":(\"[^\"]*\"|[^,}]*)[ ]*};;"
	}

cFirstJsonAttr() { # take string and extract the value of the first attribute if JSON, whole string otherwise. eliminating any non-alpha chars
	cX
	local m="$*"
	[ "${m#{}" = "$m" ] && e "$m" && return # non-JSON
	e "$m" | sed -e 's/[,}].*//g' -e 's/[^:]*://' -e 's/[^a-zA-Z0-9]*//g' # ... else JSON
	}
# set -x ; x='{ eins:"first" , zwei="second" }' ; cFirstJsonAttr "$x" ; cFirstJsonAttr "blabla,bla:blub" ; exit # TEST

cWordsToJsonArray() {
	cX
	awk 'BEGIN {printf "["} {printf lim "*" $0 "*" ; lim="," } END {printf "]"}'
  }
  # set -x ; echo -n eins zwei | cWordsToJsonArray ; echo -n "" | cWordsToJsonArray ; exit 

cGetGluonDomainsStarred() {
	cX
	ssh_data="$(cCRead .gluondomains 1)"
	if ! cData ; then
		cSsh "ls -1 $dGluon/domains 2>&1" || return $?  # cancel function
		cData && {
			ssh_data="$(cOut | sed -e 's/[^_]*_//' -e 's/.json//')"
			cCWrite .gluondomains
		}
	fi
	cOut | cWordsToJsonArray
	}

cLogger() {
		logger -p daemon.$1 -t "$sMe $hTarget" "$2"
	}
	# set -x ; cLogger info "blabla" ; exit 1

cErr() {
	cX
	_tmp="$1"
	[ "$1" = : ] && _tmp="ssh to $sSshUser for $cmd failed" # default msg is ....
	[ "$1" != "${1%:}" ] && _tmp="${_tmp%:} (rc=$ssh_rc,$ssh_msg)" # if $1 ends in :, then add rc and msg
	shift
	ECHO "${OnRed}ERROR$Rst:" "$_tmp" "$@" 1>&2
	[ -t 2 ] || cLogger error "$_tmp" "$@"
	}

cErrAndExit() {
	cX
	cMqttReply EXITING "$*."
	cErr "$* ... Exiting."
	exit 1
	}

jsonfilter=$($C -v jq) || jsonfilter=$($C -v jsonfilter) || cErrAndExit "jsonfilter or jq must be made available."
jsonfilter=$(basename "$jsonfilter")

cEcho() { # log and output stuff (in color) unless to be quiet
	cX
	[ "$bQuiet" ] && return
	o="${*:-$ssh_data}"
	# local _out="$*"
	# FIXME:  [ "$1" = "${1#\{\*}" -a "$1" = "${1#\[\*}" ] && _out="$(cStarredToJSON "$*" | json_pp)"  # expand (only) "starred" pseudo-JSON
	ECHO "$Cyan$o$Rst"
	cLogger info "$o"
	}
	# set -x ; cEcho -e -e zwei ; exit 1

dbg() { # output its args to stderr if verbosity set
	cX
	[ "$bVerbose" ] || return 1
	{ [ "$#" = 2 ] && ECHO "$Yellow$1:$Rst" "$2" || ECHO "${Yellow}debug$Rst" "$*" ; 
			[ "$bVeryVerbose" ] && cLogger info "$*" ; } 1>&2
	true # return true if verbose
	}

cShortenString() { # shorten string $1 to at most $2 chars plus ....
	cX
	printf "%.${2:-5}s%s" "$1" "$( [ ${#1} -gt "${2:-5}" ] && printf "...")"
	}

for d in $TEMP $TMPDIR /var/log /tmp /data/data/com.termux/cache ; do # find a suitable writable dir. Prefer /var/log over /tmp on openhabian (because of zram).
	dCache=$(cTrd -c A-Za-z0-9_.-/ "$d/$sBase.$(id -nu)" ) # ensure a good dir name
	dTmp=$dCache/$$
	dbg dTmp $dTmp
	[ -d "$dCache" ] || { mkdir -p "$dCache" 2>$fNul && chmod o-rwx "$dCache" ;} && mkdir $dTmp && break || id # ... && chmod o-rwx $dTmp
done

# cDirFromStoreType() { [ $1 = cache ] && e $dCache || e $dUser ;}

cStoreWrite() { # write a key/value pair to a dir: key,value,dir,filesuffix # if key starts with "." prefix the hTarget
	cX 
	_dir="$3" # "$(cDirFromStoreType $3)"
	_f="$_dir/$([ "${1#.}" = "$1" ] || e $hTarget)$1"
	_t=STORE_WRITE
	[ "$1" ] || {
		e "$_t: #INVALIDPARAM#"
		cErrAndExit "$_t($1, \"$2\", $_dir) = #INVALIDPARAM#"
	}
	mkdir -p $_dir && echo "$2" > "$_f"
	_rc=$?
	dbg $_t "($1,\"$2\",$3) = $_rc"
	return $_rc
  }
cUserWrite() {  # write a key/value pair permanently across script invocations
	cStoreWrite "$1" "$2" "$dUser"
	}
cCWrite() { # write a key/value pair to be cached across script invocations from the same user
	cStoreWrite "$1" "${2:-$ssh_data}" "$dCache"
	}
	# echo TEST: ; set -x ; cCWrite test1 shouldnotfail ; ls -al $_f ; cCWrite "" shouldfail ; exit 

cStoreRead() { # read key/value pair from cache or user storage  (1:key, 2:cachetime, 2: filesuffix, 3:dir)
	cX
	local _fn="$3/$([ "${1#.}" = "$1" ] || e $hTarget)$1"
	local _nMin=$([ "$2" = 0.1 ] && e 58 || e $((${2:-2}*60*24-5)) ) # default 2 days,  0.1=1 hour=59 minutes
	local _res="#NOTFOUND#" # cache is invalid or non-existent
	local _val=""
	local _deloutput

	if [ -r $_fn ] ; then
		[ "$4" = cache ] && _deloutput="$( find $_fn -mmin +"$_nMin" | head -1 | xargs -t rm 2>&1)" # cache invalidated after n days and remove file
		if [ -z "$_deloutput" ] ; then
			_val="$(cat $_fn)" && _res="#OK#"  # read value from cache file
			[ "$_val" ] || _res="#EMPTY#"
		fi
	fi
	dbg STORE_READ "($1,$2,${_fn#/var/log/})=\"$(cShortenString "$_val" 23)\",$_res)" 
	p "$_val"
	[ "$_val" ] # return 1 if empty, 0 otherwise
  }

cUserRead() { # read a user-specific key/value pair across script invocations
	cX
	cStoreRead "$1" "$2" "$dUser"
  }
  # set -x ; bVerbose=yes ; cUserRead myhosts ; cUserRead myhosts ; exit

cCRead() { # read a key/value pair to be cached across script invocations from the same user; empty cache after $2=n day(s)
	cX
	cStoreRead "$1" "$2" "$dCache"
  }
  # set -x ; bVerbose=y ; dCache=/var/log/manage_gluon_mqtt.openhabian ; cCRead jupiter.site ; cCRead jupiter.os_id ; sleep 1 ; exit

if [ -t 1 -a "$NO_COLOR" ] ; then # only color code on terminals and not when NO_COLOR is set
	F='\e[' # https://gist.github.com/bcap/5682077#file-terminal-control-sh
	Yellow="${F}33m" ; Cyan="${F}36m" ; OnRed="${F}41m" ; Rst="${F}0m"
	# Reg="${F}22;24m" ; RegF="${F}39m" ; RegB="${F}49m"  # Reset all coloring and style
fi

cFilter() {  #  cFilter(filterexpr,moreparam), filterexpr is a jq or jsonfilter expression
	cX
	if [ "$jsonfilter" = jsonfilter ] ; then
		data="$(jsonfilter -e "@$1" "${2:---}" )" # -- if $2 empty
	elif [ "$jsonfilter" = jq ] ; then
		data="$(p "$2" |jq -r "$1")"
	else
		cErrAndExit "\$jsonfilter is undefined"
	fi
	# p "$_data"
  }
# set -x ; cFilter .addr '{ "addr": "addr_value\\n" }' ; cOut ; exit 99

cGetMacVendor() { # $1=mac address
	cX
	local _mac="$(cLower "$1" | tr - : )" #  allow for different seperators in mac adress to be looked up
	local _short="$(p "$_mac" | cCut : 1-3 )" # only the first three bytes (OUI) determine the vendor
	local _vd="$(cCRead "mac-$_short.vendor" 9)" # try to find in cache
	if ! [ "$_vd" ] ; then
		_vd="$(wget -q -O - "https://api.macvendors.com/$_mac")"
		_vd="$(cTrd -c "A-Za-z0-9_.%, -()" "${_vd:-UNKNOWN}" | cCut " " 1-7)" # only first n words of the vendor name
		cCWrite "mac-$_short.vendor" "$_vd"
	fi
	echo "$_vd"
	}
	# set -x ; cGetMacVendor 38:B4:d3 ; cGetMacVendor  Aa:87:0b:24:61:b3 ; cGetMacVendor  A4:2A:95:45:20:B6 ; exit
	# set -x ; cGetMacVendor 6e:95:18:16:87:58 ; cGetMacVendor  Aa:87:0b:24:61:b3 ; cGetMacVendor F0-8A:76:A9:57:80 ; exit
	# set -x ; for m in $(arp -a| cut -d " " -f 4 | grep : ) ; do cGetMacVendor "$m" ; cGetMacVendor "$(p $m | sed 's/..:..:..$/00:00:00/' )" ; echo ==== ; done ; exit
	# set +x ; for m in $(arp -a| cut -d " " -f 4 | grep : ) ; do echo $m ; wget -q -O - "https://api.macvendors.com/$(p $m | sed 's/..:..:..$/00:00:00/' )" ; echo " " ; echo ==== ; done ; exit

shorten_ethernet_addr_in_json() { # remove some bytes für anonymization
	[ "$1" ] && cat && return 0
	sed -E -e 's/([*"][a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9]:)[a-f0-9][a-f0-9]:[a-f0-9][a-f0-9](:[a-f0-9][a-f0-9][*"])/\1..\2/g' "$@"
	}

cProbe() { # returns 0, if command is to be executed, 1 if not, and 255 if last ssh connection failed
	cX # any local command line command is always trusted for now:
	[ "$cmdsToDo" != bridge ] && { [ $ssh_rc = 255 ] && return 255 || return 0 ;} # if node wasn't reachable (255) don't tray again
	[ "$hMqtt" != $LH ] && { cEcho "Untrusted MQTT $1 command .$cmd. ignored for .$fHost." ; return 1;} # for now: only trust commands from a MQTT broker on the same host.
	return 0 # FIXME: covered by catchall
	}
alias cProbeGET="cProbe GET || cntnue"
alias cProbeSET="cProbe SET || cntnue" # FIXME: logic not implemented consistently
alias cProbeNOMQTT="cProbe NOMQTT || cntnue" # FIXME: covered by catchall

cStackCommand() { cmdsToDo="$1${cmdsToDo:+,$cmdsToDo}" ; dbg STACKCOMMAND "$1 ($cmdsToDo)" ;}

bMosqFile=$( [ -r $HOME/.config/$MP ] && echo yes)

cMqtt() { # cMqtt(topic,msg, options) # expanding a leading / in topic to $sSite/$hTarget/
	cX
	[ "${cMPub:-:}" = : ] && return
	local _comp="" && [ "$3" = "-M" ] && _comp=y || _o="$3"
	local _topic="$1"
	[ "$1" != "${1#/}" ] && _topic="$sSite/$hTarget$1" # ... expand shortcut starting with "/"
	dbg PUB_MQTT "$_topic  $2  ${3:+OPTIONS=$3}${bVeryVerbose:+ (hMqtt=$hMqtt;hTarget=$hTarget)}"
	[ "$_comp" -a "$bModified" ] && _f="mqtt.$(p $_topic|cSanitize)" && _pv="$(cCRead $_f 0.1)" && [ "$_pv" = "$2" ] && return 0 # ... skip if value is unchanged
	for h in $hMqtt ; do
		#  passing $3 without quotes on purpose:
		$cMPub ${h:+-h $h} ${sMID:+-i $sMID} -t "$_topic" -m "$2" -i "${sSite}_$hTarget" $_o	|| dbg "$cMPub(host=$h): rc=$?"
	done && [ "$_comp" -a "$bModified" ] && cCWrite "$_f" "$2" # ... cache the message
  }
  # set -x ; cMqtt ss/tt mm ; cMPub=mosquitto_pub ; export hMqtt=localhost ; cMqtt sss/ttt mm ; exit 99
  # set -x ; cMPub=mosquitto_pub ; export hMqtt=localhost ; echo ==1== ; cMqtt hhh mmm -M ; echo ==2== ; cMqtt hhh mmm -M ; echo ==3== ; cMqtt hhh mm2 -M ; exit 99

cStarredToJSON() {
	awk -v a="${*:-$data}" 'BEGIN { gsub("\"","'\''",a) ; gsub("*","\"",a) ; print a }' # " => ' , then * => "
	}

cMqttStarred() {		# cMS(expandableTopic,message,moreMosquittoOptions)
		cX
		[ "$hMqtt" -o "$homie" -o "$bMosqFile" ] && [ $cMPub != : ] &&
			cMqtt "$1" "$(cStarredToJSON "${2:-$data}")" "$3" # ...  replace double quotes by single quotes and stars by double quotes
	}
	alias cMS=cMqttStarred

cMqttReply() { # $1=status $2_reply $3=moreopts|-M
		cX
		local _cmd="${cmd%%[0-9]*}" # clean trailing digits from the MQTT command
		local _ms="$2"
		[ "$2" = "${2%:}" ] || _ms="${2%:} (rc=$ssh_rc${ssh_msg:+,$ssh_msg})" # if $2 ends in a colon then append ssh_rc and ssh_msg
		cMS /$_cmd/log "{*status*:*$1*${_ms:+,*details*:*$_ms*}${3:+,$3}${fPipe:+, *daemon*:*yes*}}" $3
		[ "$1" != OK -a "$1" != ONGOING ] && cLogger info "$1: $_ms $3"
		dbg MQTTREPLIED "$1: $_ms : $3"
	}
	alias cMR=cMqttReply

cMqttBeacon() {
	_pubcmd="$cMPub -h $hPubMqtt" # caution: Freifunk/Gluon seems to need IPV6 connectivity, not all brokers have it!
	# _pubcmd="$cMPub -h broker.hivemq.com"
	_topic="\"$sSite/\`tr A-Z a-z < $fHost\`/installation\"" # tr shall run on the remote node with apostrophes!
	dbg BEACON "$_pubcmd $_topic"
	cSsh "$_pubcmd -t $_topic -r -m TEST_$cmd"
	_rc=$ssh_rc
	if [ $_rc != 0 ] ; then
		cErr "$_pubcmd -t $_topic -r -m TEST_$cmd had failed with $ssh_rc ($ssh_msg) on remote node (check why!)"
	else
		dbg BEACON "$_pubcmd $_topic had succeeded, now removing this (retained) msg again..."
		cSsh "mosquitto_sub -h $hPubMqtt -t $_topic -v -C 1 -W 5 --remove-retained"
	fi
	return $_rc
}

# Parameters for cHassAnnounce:
# $1: MQTT "base topic" for states of all the device(s), e.g. "rtl/433" or "ffmuc"
# $2: Generic device model, e.g. a certain temperature sensor model
# $3: MQTT "subtopic" for the specific device instance,  e.g. ${model}/${id}. ("..../set" indicates writeability)
# $4: Text for specific device instance and sensor type info, e.g. "(${id}) Temp"
# $5: JSON attribute carrying the state
# $6: device "class" (of sensor, e.g. none, temperature, humidity, battery),
#     used in the announcement topic, in the unique id, in the (channel) name,
#     and FOR the icon and the device class
# Side effects using global variables:
# $sID:    , $sManufacturer: ... used in device description
# Examples:
# cHassAnnounce "$basetopic" "Rtl433 Bridge" "bridge/state"  "(0) SensorCount"   "value_json.sensorcount"   "none"
# cHassAnnounce "$basetopic" "Rtl433 Bridge" "bridge/state"  "(0) MqttLineCount" "value_json.mqttlinecount" "none"
# cHassAnnounce "$basetopic" "${model}" "${model}/${id}" "(${id}) Battery" "value_json.battery_ok" "battery"
# cHassAnnounce "$basetopic" "${model}" "${model}/${id}" "(${id}) Temp"  "value_json.temperature_C" "temperature"
# cHassAnnounce "$basetopic" "${model}" "${model}/${id}" "(${id}) Humid"  "value_json.humidity"       "humidity"

# cHassAnnounce "ffmuc"     "$ad_devname" "$node/publi../localcl.."     "Readable Name"  ""   "$icontype"
# cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set"      "Radio channel 2.4GHz" "" "counter"
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort/set" "Public SSID Short"  "" "wifi"  # 5: value_json.count
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"          "Public SSID"        "" "wifi"  # 5: value_json.count
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "" "counter"
# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" "switch"

cHassAnnounce() {
	cX
	dbg cHassAnnounce "$*"
    local _topicpart="${3%/set}" # if $3 ends in /set it is settable, but remove /set from state topic
	local _command_topic_str="$( [ "$3" != "$_topicpart" ] && echo ",*cmd_t*:*~/set*" )"  # determined by suffix ".../set"
    # local _name="$(p "${2:+$2-}$4" | tr " " "-" | tr -d "[)()]/" )"
    local _dev_class="${6:-none}"
	local _state_class
	local _jsonpath
	local _jsonpath_red
	local _value_template_str
    if [ "$5" ] ; then
		_jsonpath="${5#value_json.}" #  "${_jsonpath//[ \/-]/}"
		_jsonpath_red="$(cTrd "][. /-_" "$_jsonpath")"    # cleaned and reduced, needed in unique id's
		_value_template_str=",*value_template*:*{{ $5 }}*"
		local _devid="$(basename "$_topicpart")"
		local _configtopicpart="$(cTrd "][ /-" "$_topicpart")"
		local _dev_unique_id="$sMe2$2" #   ="${sID}$2"
	    local _dev_name="$2 ${_devid}" # "$2 ${_devid^}"
	else
		local _devid="$2"
		local _configtopicpart="$(cLower "$_topicpart" | tr -d "][ /-" )"
		local _dev_unique_id="${sMe2}$2" # remove the trailing process-id
	    local _dev_name="$2"
    fi
    local _topic="${sHassPrefix}/$1${_configtopicpart}$_jsonpath_red/$_dev_class/config"  # e.g. homeassistant/sensor/rtl433bresser3ch109/{temperature,humidity}/config
    local _sensortopic="${1:+$1/}$_topicpart"
	# local *friendly_name*:*${2:+$2 }$4*,

    local _icon_str=",*icon*:*mdi:mdi-$_dev_class*"  # mdi icons: https://cdn.materialdesignicons.com/5.4.55/
    local _unit_str=""
    # local _channelname="$_dev_name ${_dev_class}" # ${_dev_class^}"
   	local _channelname="$_dev_name $4" # take something meaningfull
    case "$_dev_class" in
        temperature*)	_unit_str=",*unit_of_measurement*:*°C*"	; _state_class=measurement ;;
        humidity)		_unit_str=",*unit_of_measurement*:*%*"	; _state_class=measurement ;;
        counter)		_unit_str=",*unit_of_measurement*:*#*"	; _state_class=total ;; # UOM must have a content to trigger recognition as a number on OpenHab
		clock)			_icon_str=",*icon*:*mdi:clock-outline*" ;;
        switch)			_icon_str=",*icon*:*mdi:mdi-toggle-switch*" ;;
		none)			_icon_str="" ;;
        # battery*)     _unit_str=",*unit_of_measurement*:*B*" ;;  # 1 for "OK" and 0 for "LOW".
    esac
	local _dev_model="$2$( [ "$2" != "$_devid" ] && echo " on channel $_devid" )"
    local _device_string="*device*:{*identifiers*:[*$_dev_unique_id*],*manufacturer*:*$sManufacturer*,*model*:*$_dev_model*,*name*:*$_dev_name*,*sw_version*:*$sMe*}"
    local _msg="*name*:*$_channelname*,*~*:*$_sensortopic*,*state_topic*:*~*,$_device_string,*device_class*:*$_dev_class*"
	_msg="$_msg,*unique_id*:*${sMe2}${_configtopicpart}$_jsonpath_red*${_unit_str}${_value_template_str}${_command_topic_str}$_icon_str${_state_class:+,*state_class*:*$_state_class*}"

   	cMS "$_topic" "{$_msg}" "-r" # publish retained announcement
  }

cMqttSub() {
		mosquitto_sub ${hMqtt:+-h $hMqtt} ${sMID:+-i $sMID} "$@" || dbg ERROR "mosquitto_sub to $hMqtt terminated/failed." # would fail when used with multiple hosts...
	}

cHomieReady() {
		cX
		_ret="$(cMqttSub -W 2 -C 1 -t "homie/$1/\$state" 2>$fNul)"
		[ "$_ret" = ready ] # return 0 if matching ready
	}

hLine() {
		[ "$homie" -a ! "$bHassOnly" -o "$1" = \$state ]  &&  cMqtt "homie/$homie/$1" "$2" "$3"
	}

hMeta() {
		cX
		dbg hMeta "($1,$2,$3)"
		local _msg="$2" ; [ "$bDeleteAnnouncement" ] && _msg="" # bDeleteAnnouncement used in an intended side effect from this global var
		local _topic="$(p "$1" | sed -E -e 's,([^/]*)$,$\1,' )" # ... insert a $ before last part of topic 

		hLine "$_topic" "$_msg" -r
	}

hMulti() { # 1: topic, 2: name, 3: retained, 4: settable, 5: datatype, 6: unit, 7: format
		# cX
		# hMulti publicwifi/clientscount "Public WiFi client count" false "" integer "#" "-1:9999"
		# dbg2 "hMulti($1,$2,$3,$4,$5,$6)"
		o="$1"
		if [ "$bDeleteAnnouncement" ] ; then
			cHassAnnounce "" "$ad_devname" "homie/$hTarget/$o" "$2"  ""  sensor
		else
						hMeta $o/name "$2"
			[ "$3" ] && hMeta $o/retained	"${3:-true}"  # default: true
			[ "$4" ] && hMeta $o/settable	"${4:-false}" # default: false
			[ "$5" ] && hMeta $o/datatype	"$5"
			[ "$6" ] && hMeta $o/unit	"$6"
			[ "$7" ] && hMeta $o/format	"$7"

			cHassAnnounce "" "$ad_devname" "homie/$homie/$o$( [ "$4" = true ] && echo "/set" )" "$2" "" sensor
			# cHassAnnounce "" "$ad_devname" "$sSite/$hTarget/statistics"         "Public Wifi RX bytes"   "value_json.traffic.rx" "counter"
			# cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi TX bytes"   "value_json.traffic.tx" "counter"
		fi
	}

cBothMqtt() {
		cMS		"/$1" "$2" "$3"
		hLine	"$1" "$2" "$3"
	}

cEchoPub() {
		cEcho	"$2"
		cBothMqtt "$cmd/$1" "${3:-$2}"
	}

announce_disco() { # $1: <homie-host>,  $2: "-d" if retained advertisements are to be deleted.
	# NB: $hTarget and optionally $bDeleteAnnouncement must have been set!

	local -
	local _nDay="$(cCRead .AnnounceDay 999)"

	if [ "$2" = "-d" -o "$bDeleteAnnouncement" ] ; then
		cMqtt "debug/$1" "DELETE ANOUNCEMENTS BEGIN: $1,bDeleteAnnouncement=$bDeleteAnnouncement"
		bDeleteAnnouncement=yes # used in side effect in hMeta, will be resetted further down
		# use "remove-retained" feature from newer mosquitto-clients versions:
		_top="homie/$homie/#"
		cMqttSub -W 1 -t "$_top" --remove-retained --retained-only >$fNul 2>&1
		_rc=$?
		[ "$_rc" -ne 0 -a "$_rc" -ne 27 ] && dbg "Removal of retained topics below $_top returned $_rc"

	    _topic="$sHassPrefix/#" # deletes eveything below "homeassistant/sensor/..." !
		dbg "Removing all announcements matching $_topic ... (timeout ok)"
		cMqttSub -W 1 -t "$_topic" --remove-retained --retained-only >$fNul
		_rc=$?
		[ "$_rc" -ne 0 -a "$_rc" -ne 27 ] && dbg "Removal of retained topics below $_topic returned $_rc"
		cMS "$sSite/$1/state" "{*event*:*cleaned*,*note*:*removed all announcements starting with $_topic*}"
	else
		# cMqtt "debug/$1" "MQTT ANOUNCEMENTS BEGIN (arg2=$2)"
		[ "$sSshUser" = NOUSER ] && { hLine \$stats/uptime "$(cCut . </proc/uptime)" ;}
		# cHomieReady "$1" ; echo DEBUG: $?
		if [ "$_nDay" ] && [ "$(date +%j)" -eq "$_nDay" ] && cHomieReady "$1" ; then
			dbg announce_disco ": skip announcements, homie state is ready... " # (re-)announce ONLY IF restart or new day or necessary
			return 0
		fi
		os_data="$(cGetOSData)" || 
			{ dbg announce_disco "WarningNo OS Data obtainable" ; return 1 ;} # abort

		dbg announce_disco ": WILL ANNOUNCE ... (arg1=$1,arg2=$2"
		ad_devname="$(p "$1" | awk '{print toupper(substr($i,1,1)) substr($i,2) }' )"
		ad_fwid="$(cCRead .os_id 9)"
		ad_fwname="$(cCRead .os_name 9)"
		ad_fwversion="$(cCRead .os_pretty_name 9)"
		ad_impl="$(cCRead .os_id 9)"
		dbg announce_disco "($1,$2): announcing ad_devname=$ad_devname,ad_fwname=$ad_fwname,ad_fwversion=$ad_fwversion,ad_impl=$ad_impl"

		# https://www.home-assistant.io/docs/mqtt/discovery/
		cHassAnnounce "$sSite" "$ad_devname" "$1/radio/channel24/set" "Radio channel 2.4GHz" "" "counter"
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssidshort/set" "Public SSID Short"  "" "wifi" 
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/ssid"      "Public SSID"        "" "wifi" 
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/localclients" "Local Clients Count" "value_json.count" "counter" # 5: value_json.count
		cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/state/set"    "Public SSID State"   "" "switch"
		# cHassAnnounce "$sSite" "$ad_devname" "$1/publicwifi/lastdate"    "Last date wifi check" "" "clock"
	fi
	hMeta homie "3.0.1"
	hMeta state init
	hMeta name  "$ad_devname"

	[ "$ad_fwname"    -o "$2" ] && hMeta fw/name        "$ad_fwname"
	[ "$ad_fwversion" -o "$2" ] && hMeta fw/version     "$ad_fwversion"
	[ "$ad_impl"      -o "$2" ] && hMeta implementation "$ad_impl"
	
	sManufacturer="$ad_fwversion"

	# hMeta $1 "stats/interval" 600
	# hMulti() { # 1: name, 2: retained, 3: settable, 4: datatype, 5: unit, 6: format }
	# Defaults are ... settable=false   retained=true
	hMeta nodes		"publicwifi,gluondata,radio"
	hMeta radio/name       "Wifi Radio"
	hMeta radio/type       "Wifi Radio Hardware"
	hMeta radio/properties "channel24"
	hMulti radio/channel24         "Radio channel 2.4"        false "" integer ""  "1:13"

	hMeta publicwifi/name       "Public Wifi"
	hMeta publicwifi/type       "Public Wifi Network"
	hMeta publicwifi/properties "clientscount,state,ssidshort,ssid"
	hMulti publicwifi/clientscount "Public WiFi client count" false "" integer "#" "-1:9999"
	# hMulti publicwifi/lastdate "Last date sent" false "" DateTime "" ""
	hMulti publicwifi/state        "Public WiFi state"        "" true boolean "" ""

	if _gluondomains=$(cCRead .gluondomains 9) ; then
		_wifi_domains="$(cTrd "][*" "$_gluondomains" | awk -F= '{ printf lim $1 ; lim="," }' )" # rough hack...
		dbg wifi_domains "$_wifi_domains"
			# 1: root, 2: name, 3: retained, 4: settable, 5: datatype, 6: unit, 7: format
		hMulti publicwifi/ssidshort "Public WiFi short SSID" false true enum "" "$_wifi_domains" # rough hack...
	else
		hMulti publicwifi/ssidshort "Public WiFi short SSID" false "" string "" ""
	fi
		hMulti publicwifi/ssid      "Public WiFi SSID"       false true string "" ""

	hMeta gluondata/name       "Node Data"
	hMeta gluondata/type       "Gluon Data"
	hMeta gluondata/properties "autoupdater-branch,autoupdater-enabled,gluon-version,release,model,core-domain"
	hMulti gluondata/autoupdater-branch "Autoupdater Branch" false "" string "" ""
	hMulti gluondata/autoupdater-enabled "Autoupdater Enabled" false "" boolean "" ""
	hMulti gluondata/gluon-version "Gluon Version" false "" string "" ""
	hMulti gluondata/release "Local Release" false "" string "" ""
	hMulti gluondata/model "Hardware Model" false "" string "" ""
	hMulti gluondata/core-domain "Core Domain" false "" string "" ""
	hMulti gluondata/gluon-domains "Gluon Domains" false "" string "" ""
	hMeta state ready

	cMqtt "debug/$1" "HOMIE/HASS ANOUNCEMENTS END (bDeleteAnnouncement=$bDeleteAnnouncement)"

	bDeleteAnnouncement="" # end of side effect
	cCWrite .AnnounceDay "$(date +%j)" # support reducing re-announcements to only once per day
  }

cAddSuccHost() {
	[ $ssh_rc = 0 ] && nHosts=$((nHosts+1)) && sHosts="$sHosts,$hTarget" # ... since we were successful
  }

OPTIND=1         # reset to 1 in case getopts had been processed previously in this shell.

# Initialize more variables
bDoAll=""
commands="" # commands="mesh-id"
sUciQuery=""
sUciVal=""
cMPub=mosquitto_pub

cCmv $cMPub || { cMPub=":" ; dbg "Variable/command cMPub=*$cMPub* (: is dummy)." ;}
cCmv stdbuf && SB="stdbuf -oL" || dbg WARNING "stdbuf not installed. Delays possible!!" # SB="" # to avoid buffering of stdout
SB=""
cCmv json_pp || alias json_pp=cat
# alias cBeautify="jq -Sm" ; cCmv jq || alias cBeautify=cat

[ $# -eq 0 ] && { cHelp ; exit 1 ;} # at least one parameter on the command line is required

while getopts "?h:GE:vxql:as:pPR:f:Mm:g:n:c:C:o:w:" opt   # https://wiki.bash-hackers.org/howto/getopts_tutorial
do
    case $opt in
    \?) cHelp
		[ $cMPub = : ] && cErrAndExit "$MP is not installed (consider running \"-c install\"!"
        exit 1
        ;;
    h|s) ffhosts="$OPTARG" # one or more Freifunk nodes
		if expr index ."$ffhosts" "+*" >$fNul # substitute '+' or a '*'' for a set of predefined hosts
		then
			# multiple "host1,host2,host3" (without double quotes)
			# values used for + or * should be manually stored in the file $dUser/myhosts.persist:
			_tmp="$(cUserRead myhosts)" || cErrAndExit "config for collection of hosts is missing ($dUser/myhosts.persist)"
			ffhosts="$(p "$ffhosts" | sed "s/[+*]/$_tmp/g" | cSanitize)" # replace + and sanitize
			bWorkAllClients=yes
		fi
        ;;
    G) [ "$nGiveHost" ] && nGiveHost=2 || nGiveHost=1 # file descriptor to send output to: -G = stdout, -G -G = stderr
		;;
	E) nMaxGoneDays="$(cSaniOpt)"
		;;
    v) [ "$bVerbose" ] && bVeryVerbose=yes && nMqttSleep=60 || nMqttSleep=230 # not to small to allow for gathering status in between !
		bVerbose=yes
		dbg DIRS "dUser=$dUser dTmp=$dTmp"
		;;
	x) bVerbose=yes && bTrace=yes
		set -o xtrace
        ;;
	l)  ;;
	q) bQuiet=yes
		;;
	a) [ "$bDoAll" ] && bDoExperiment=yes # set after -a -a ...
		bDoAll=yes
		;;
	M) bModified=yes
		;;
	m)	[ "$OPTARG" -a $cMPub = : ] && cErr "$MP is missing!"
		case "$OPTARG" in     # see http://www.steves-internet-guide.com/mqtt-hosting-brokers-and-servers/
		-)	_m=localhost ;;
		test)	_m=$hPubMqtt ;;
		eclipse) _m="mqtt.eclipseprojects.io"   ;;
        hivemq)	_m="broker.hivemq.com"   ;;
        emqx)	_m="broker.emqx.io"   ;;
		dash)  _m="broker.mqttdashboard.com"    ;; # https://moxd.io/2015/10/17/public-mqtt-brokers/
		*)	_m="$(cSaniOpt | tr , " ")" ;; # clean up for sec purposes, allow comma to seperate multiple hosts
		esac
		hMqtt="${hMqtt:+$hMqtt }$_m"
		;;
	g) mqttGroup="$(cSaniOpt)"
		;;
	p|P) homie=yes ; [ $opt = p ] && bHassOnly=yes
		[ $cMPub = : ] && cErrAndExit "MQTT client $MP is not installed, but -$opt was requested..."
		;;
	R) sArea="$(cSaniOpt)"
		;;
	f) fFile="$(cSaniOpt)"
		# commands=filecopy # Changed: must be now be given as -c filecopy explicitly, too.
		dbg FILE "$fFile"
		;;
	n) sExtraOption="$(cSaniOpt)"
		sGrepSsid="$OPTARG"
		;;
    c) commands="$OPTARG" # one or more, comma-seperated command to be executed
        ;;
	C) nExitAfter="$(cSaniOpt)" # exit after nn MQTT commands
		;; 
    o) sUciQuery="$OPTARG" ; commands=uciquery
		# echo sUciQuery="$sUciQuery"
        ;;
    w) sUciVal="$OPTARG" ; commands=uciwrite
		# echo sUciVal="$sUciVal"
        ;;
    esac
done

shift "$((OPTIND-1))"   # Discard the options parsed so far and leave the rest of the cmd line...

# [ "$bQuiet"	] || alias cEcho=": cEcho"
[ "$bVerbose"	] || alias dbg="false dbg"
[ "$bVeryVerbose" ] && alias dbg2=dbg || alias dbg2="false dbg2"

if [ "$homie" -o "$hMqtt" -o "$bMosqFile" ] ; then # enable MQTT
	: dbg "MQTT commands real."
else
	dbg2 "MQTT commands aliased."
	alias cMS=": cMS"
	alias hLine=": hLine"
	alias hMeta=": hMeta"
	alias cMqttReply=": cMqttReply"
fi

[ -z "$commands" ] && cErr "$sMe: No commands !?"

if [ -d $dGluon -o -x /usr/sbin/print_map.sh ] ; then   # I'm running on Gluon (which is based on OpenWrt)
	[ "$hMqtt" -o "$bMosqFile" ] || hMqtt=$hPubMqtt
	fMacIDs=/tmp/phones
else                                      # on rest-of-world (e.g. Raspi or (FIXME) some fullblown OpenWrt)
	[ "$hMqtt" -o "$bMosqFile" ] || hMqtt=$LH
	fMacIDs=/srv/openhab-conf/phones
fi

fCollection=""
fSleep=$dTmp/sl
nHosts=0
sHosts=""

ffhosts="$(cLower "${ffhosts:-$LH}" | tr -s , " ")" # if none given, take localhost
for hFull in $ffhosts ; do # do it for each given target node (or maybe just one)...
	ssh_rc=0 # reset cache of the last connection return code
	if [ "$hFull" = localhost ] ; then
		sSshUser=NOUSER
		cSsh() {
			[ "$1" = -v ] && shift
			ssh_msg=""
			ssh_data="$(eval "$*")" # FIXME: see https://www.shellcheck.net/wiki/SC2294
			ssh_rc=$?
			[ $ssh_rc -eq 127 ] && { set -- "$@" ; ssh_msg="CMD NOT FOUND: $1" ; }
			return $ssh_rc
		  }
		hTarget="$sArea"
	else
		sSshUser="root@$hFull"
		cSsh() {
			cX			
			ssh_msg=""
			[ "$bVeryVerbose" ] || { [ "$1" = -v ] && shift ; } && dbg SSHRUN "$* ($sSshUser)"
			_r="$(ssh $sSshUser -q "$@")"
			ssh_rc=$?
			ssh_data="$(cTrd '`' "$_r")"
			if [ $ssh_rc -eq 255 ] ; then
				ssh_msg="UNREACHABLE" 
			elif [ "$bVerbose" ] ; then
				_n="$(cCRead .sshcnt)"
				cCWrite .sshcnt $((_n+1))
				: here $_n
			fi
			if [ $ssh_rc -ne 0 ] ; then
				[ $ssh_rc -eq 127 ] && { set -- "$@" ; ssh_msg="CMD NOT FOUND: $1" ; }
				dbg SSH "RETURN CODE=$ssh_rc ($ssh_msg)" 1>&2
				cLogger error "$* = $ssh_rc"
			fi
			return $ssh_rc
  		  }	
		# remove any trailing "-<letter>"  also the domain name
		hTarget=$(p "$hFull" | awk '{ $0=tolower($0) ; gsub("\\..*","") ; gsub("-[a-z]$","") ; print }' )
		[ "$nMaxGoneDays" ] && [ -z "$(cCRead .sshcnt $nMaxGoneDays)" ] && continue # dont even try this node if not seen for x days
	fi
	_string="" && [ "$sSshUser" = "${sSshUser%${hTarget}-e}" -a "$sSshUser" = "${sSshUser%${hTarget}}" ] && _string="($hTarget) "
	[ "$bVerbose" -o "$nGiveHost" ] && ECHO "\n######## ${sSshUser#root@} $_string//${commands:+ $commands //} $*" "#######" >&${nGiveHost:-1} 2>&1
	cGetSitecode # reusing value for all other nodes, too.
	fTmpMqtt=$dTmp/mqtt.$hFull
	sNewSSID=""
	# set -x ; cGetHostname 0 ; exit 1
	
	if [ "$sUciQuery" ] ; then
		cSsh "uci show $1"
		data="$ssh_data"
		if [ "$bDoAll" ] ; then
			echo "$data"
		else
			data="$(cExtractVals "$data")"
			if ! [ "$sUciVal" ]  ; then
				echo "$data" # it was a query only = no writes
			elif expr "$data" : ".*\n" ; then
				cErrAndExit "key :$sUciQuery: returned more than one line!"
			else
				cSsh "uci set $sUciQuery=$sUciVal && uci commit $sUciQuery"
				cOut
			fi
		fi	
	else
		cmdsToDo="$commands"
		if [ "$cmdsToDo" = bridge ] ; then
			# prepare subscibing for MQTT messages...
			mqttGroup="$(cExpand $mqttGroup)"
			fPipe=$dTmp/p
			{ mkfifo $fPipe && chmod go-rwx $fPipe ;} || cErrAndExit "Could not create $fPipe (rc=$?)."
			for t in $hTarget $mqttGroup ; do
				_p="-t $sSite/$t"
				_subscriptions="$_p/+/get $_p/+/+/get $_p/+/set $_p/+/+/set"
			done
			[ "$homie" ] && _subscriptions="$_subscriptions -t homie/$hTarget/+/+/set"
				trap_child() {
					[ "$1" ] && cErr "TRAP_CHLD: param=$1"
				}		
				trap 'trap_child' CHLD

			echo "PERIODIC NONE" > $fPipe & # something has to be in the pipe otherwise it fails due to race condition

			dbg "SUBSCRIBING to MQTT broker: \"$hMqtt $_subscriptions\", homie=$homie, fPipe=$fPipe"
			_last_will_options="--will-qos 0 --will-topic $sSite/$hTarget/bridge/log --will-payload {\"status\":\"OFF\"}"

			# cMqttSub -F "MQTT %t %p" -R $_subscriptions $_last_will_options > $fPipe &    # ... doesn't work: mosquitto_sub exits if pipe not ready....  
			# mosquitto_sub -h localhost -F "MQTT %t %p" -R $_subscriptions $_last_will_options > $fPipe &    # ... doesn't work: mosquitto_sub exits if pipe not ready....  
			# FIXME: proper buffering still doesn't work :( :( :
			cMqttSub -F "MQTT %t %p" -R $_subscriptions $_last_will_options | awk -v f=$fPipe '{print>f;fflush(f)}' & #  pipe non-stale commands from MQTT broker
			nPidMosq=$!
			dbg "SUBSCRIBED: nPidMosq=$nPidMosq" 
			ln -fs $fPipe $dCache/p # for the convenience of injecting debug helpers
			cmd="bridge" && cMR ON "Subscribed $(awk -v a="$_subscriptions" 'BEGIN {gsub("-t ","",a) ; print a}' )"
			
			_ms=${bDoExperiment:+2}5 #  in a bg loop: pipe periodic stuff into the pipe to make it wake up not more often than every $_ms seconds
			: _ms=$_ms
			while sleep $_ms ; do 
				[ -r $fSleep ] && nMqttSleep="$(c $fSleep )" 
				echo PERIODIC TELE "${nMqttSleep}secs" ; sleep "$nMqttSleep" || true ; 
			done > $fPipe &
			nPidPeriodic=$!
			
			_tf=/dev/null ; [ "$bVerbose" ] && _tf=/tmp/$sMe.log ; # _tf=/tmp/mlog
			if cCmv ubus ; then # enable a listener for the ubus bus on OpenWrt
				# ( ubus listen | tee -a $_tf & echo $! > $dTmp/ubusPid ) | awk -v f=$fPipe '{print "UBUS LISTEN "$0 > f ; fflush(f) }' & # print "PERIODIC NOOP xxx" ; 
				# ("tee /dev/null" is a workaround for a bug in OpenWrt")
				# DONT KNOW why piping through awk makes so many buffering problems, so had to workaround further down:
				$SB ubus listen > $fPipe & echo $! > $dTmp/ubusPid
				sleep 1
				nPidUbus="$(cat $dTmp/ubusPid)"
				dbg UBUS "Ubus listen PID is $nPidUbus: others\n$(pgrep -lfa "ubus listen")" # pgrep -s 0 -n -lfa "ubus listen"
				{ sleep 1 ; ubus send $sMe '{"debug":"bridge starting"}' ; } &
				# ubus call system info
				# ubus call hostapd.client1 get_status
				# ubus call hostapd.client0 get_clients			
				# while sleep 1 ; do ubus send "$(date +%T)" ; date ; done	
			fi

			# to debug: manage_gluon_mqtt -c bridge -m - -v -a -a

			if [ "$bDoExperiment" ]  ; then  #  debug lua and flushing
				# DONT KNOW why piping through awk makes so many buffering problems, so had to workaround further down:
				$SB lua -e 'local socket = require("socket"); while true do 
					socket.sleep(3); print(os.date("PERIODIC PULSE %H:%M:%S"))
					end' > $fPipe & echo $! > $dTmp/experimentPid
				sleep 1
				nPidExp="$(cat $dTmp/experimentPid)"
				dbg EXPERIMENT "Background lua PID is: others\n$(pgrep -lfa "lua -e")" 
				{ sleep 1 ; ubus send $sMe '{"debug":"Experiment started"}' ; } &
			fi
			
			if [ "$bDoAll" ] && cCmv logread ; then  #  enable a listener for logread
				_p="daemon.info manage_gluon_mqtt"
				# DONT KNOW why piping through awk makes so many buffering problems, so had to workaround further down:
				# ( logread -f & echo $! > $dTmp/logreadPid ) | awk -v f=$fPipe -v p="$_p" '$0 !~ p {print "LOGREAD LOG " $0 > f ; fflush(f) }' & # NOTE: continous piping didnt work on OpenWrt
				$SB logread -f > $fPipe & echo $! > $dTmp/logreadPid
				sleep 1
				nPidLogread="$(cat $dTmp/logreadPid)"
				dbg LOGREAD "Background logread PID is: others\n$(pgrep -lfa "logread -f")" 
				{ sleep 1 ; cLogger info "Started." ; } &
			fi

			dbg PROCIDS "nPidMosq=$nPidMosq,nPidPeriodic=$nPidPeriodic,nPidUbus=$nPidUbus,nPidLogread=$nPidLogread,fPipe=$fPipe"
			
			trap_function() {
					[ "$cmd" = "bridge" ] && cMR ONGOING "Processing trap function. Removing fPipe=$fPipe"
					rm -f $fPipe
					pids="$nPidPeriodic $nPidMosq $nPidUbus $nPidLogread"
					kill $pids 2>$fNul || true
 					dbg "$sMe: killed $pids, sent MQTT, now stopping at $(date)"
				}		
			trap 'trap_function' INT QUIT TERM SEGV

			[ "$bDoAll" ] && sleep 1
		fi
		# NB: OpenHab Homie autodiscovery didn't like uppercase characters at the beginning...
		[ "$homie" ] && os_data="$(cGetOSData)" && homie="$(cLower $hTarget)" &&  # change "yes" to $hTarget
			 [ "$cmdsToDo" != "homie-delete" ] && announce_disco "$homie" # FIXME: check handling/interpretation of "homie-delete"

		dbg LOOP "START (cmdsToDo=$cmdsToDo)"
		while [ "$cmdsToDo" ] ; do
			if [ "$cmdsToDo" = bridge ] ; then
				cmd=""
				dbg READ "Will read $fPipe ..."
				read -r sType cmd cmdopts <$fPipe
				rc=$?
				dbg RAW "Read sType=$sType,cmd=$cmd,cmdopts=$cmdopts,rc=$rc"
				if [ "$rc" -ne 0 ] ; then
					if [ -p $fPipe ] ; then
						_msg="Read error from pipe (rc=$rc)"
						cMR ERROR "$_msg"
						cErrAndExit "$_msg: $( ls $fPipe 2>&1 )"
					else
						cMR OFF "Exiting (read_rc=$rc)."
						exit 0
					fi
				fi
				# hacky workarounds for the awk problems above
				[ "$cmd" = "$(date +%b)" ] && cmdopts="$sType $cmd $cmdopts" && sType=LOGREAD && cmd=LOG # hacky
				[ "$sType" = "{" ] && cmdopts="$sType $cmd $cmdopts" && sType=UBUS && cmd=LISTEN # hacky

				sType="$(cTrd -c A-Z "$sType")"
				if [ "$sType" = UBUS -o "$sType" = LOGREAD -o "$sType" = "{" ] ; then
					dbg READ "TYPE=$sType,$cmd,$cmdopts" || cEcho "$cmdopts"
					# set -- $cmdopts # cmdopts=27 00:35:35 2024 daemon.info manage_gluon_mqtt herkules: READ Will read /var/log/manage_gluon_mqtt.root/4458/p ...,rc=0
					# [ "$6" = daemon.info -a "$7" = $sMe ] && cntnue
					[ "$(e "$cmdopts" | cCut " " 6,7)" = "daemon.info $sMe" ] && cntnue
					cMqtt "/$(p "$sType" | tr A-Z a-z)/log" "$cmdopts" 
					cntnue
				elif [ "$sType" = PERIODIC ] ; then
					dbg "\nREAD" "TYPE=$sType,$cmd,$cmdopts ($(date +%T))"
					# FIXME Reenable: 
					[ "$bVerbose" ] && cMS /bridge/state "{*TelePeriod*:$nMqttSleep}" # FIXME: might have been modified in subshell
					[ "$cmd" = PULSE ] && cmdsToDo="echo+pulse,$cmdsToDo"
					[ "$cmd" = TELE  ] && cmdsToDo="wifistatus,statistics,$cmdsToDo"
					cntnue
				elif [ "$sType" = MQTT ] ; then
					nMqttCommands=$((nMqttCommands + 1))
					[ "$nExitAfter" ] && [ $nMqttCommands -gt $nExitAfter ] && trap_function && cErrAndExit "More than $nExitAfter MQTT commands received..."
					_prefix="$(p "$cmd" | cCut / 1-2 )" # first two parts of topic
					cmdopts="$(cFirstJsonAttr "$cmdopts")"
					cmdopts="$(cExpand "${cmdopts%(null)}")"
					dbg READ "command: $cmd  $cmdopts  (prefix=$_prefix, sSite=$sSite)" || cEcho "$cmd $cmdopts"
					case "$_prefix" in
					"homie/$hTarget"|"$sSite/$hTarget"|"$sSite/${mqttGroup:-$hTarget}")
						cmd="$(p "$cmd" | cCut / 3- )" ; cmd="${cmd%/get}"
						# cmd="$(p "$cmd" | awk -v FS=/ 'NF && NF-1 { print $3 ( $4 && $4=="get" ? "" : "/" $4 ) ( $5 && $5=="get" ? "" : "/" $5 ) }' )"
						case "$cmd" in
						localclients*|publicwifi/localclients*)				cmd="localclients" ;;
						publicwifi/ssidshort/set) cmd="wifissid_$cmdopts" ;;
						radio/channel24/set)		cmd="channel24" ;;
						publicwifi/state/set) 	{ [ "$cmdopts" = true  -o "$cmdopts" = ON  -o "$cmdopts" = 1 ] && cmd="wifiup" ;} ||
												{ [ "$cmdopts" = false -o "$cmdopts" = OFF -o "$cmdopts" = 0 ] && cmd="wifidown" ;} ||
												cErr "Illegal cmdopts=$cmdopts"
											;;
						wifistatus*|radio/channel24|publicwifi/state|publicwifi/ssidshort|publicwifi/ssid) cmd="wifistatus" ;;
						wifiup*|wifidown*|echo*|loop*|sSite*) cmd="${cmd%\*}"  ;;
						gluon-data*)	cmd="gluondata" ;;
						machine-data*)	cmd="machine-data" ;;
						wifissid*)	cmd="wifissid_$cmdopts" ;;
						esac
						;;
					*) cmd="$(p "$cmd" | awk -v FS=/ 'NF && NF-1 {print ($(NF-1)) }' )"
						;; # extract second last part of topic, must have at least one /
					esac
					cmd=${cmd%/get} && cmd=${cmd%/GET}
					dbg READ "Remapped MQTT to command: $cmd"
				else
					cErr "Unknown sType=$sType from pipe $fPipe (rc=$rc)"
					# cErrAndExit "Unknown sType=$sType from pipe $fPipe (rc=$rc)"
				fi
			else
			    	 cmd="$(p "$cmdsToDo"	| cCut ,  		)"
				cmdsToDo="$(p "$cmdsToDo"	| cCut , 2- -s	)"
			     cmdopts="$(p "$cmd"		| cCut + 2- -s	)" # split further...
				     cmd="$(p "$cmd"		| cCut +   		)"
			fi		
			    cmd="$(p "$cmd" 	| cSanitize)" # for security reasons
			cmdopts="$(p "$cmdopts" | cSanitize)"
			dbg2 COMMAND " $cmd ($cmdopts) (REMAIN: $cmdsToDo)"
			case "$cmd" in
			help) # really hacky implementation: grepping this script code for singular case branches that look like a command ....
				cProbeGET
				_msg="$( awk '$1 ~ /^[a-z]{3,}[a-z|]+)/ { gsub(/)/,"",$1); gsub(/\|/," ",$1); if ($1=="help") doit=1 ; if (doit) printf $1 " " }' "$0")"
				cEcho "$_msg"
				cMR OK "Command $cmd($cmdopts): $_msg"				
				;;
			clearcache)
				cProbeSET
				ssh_data="$( cd "$dCache" && find . -maxdepth 1 -name "${hTarget:-XXX}.*" -type f -print -exec rm '{}' \; 2>&1 )"
				ssh_rc="$(cOut | wc -l)"
				cOut
				cMR OK "Command $cmd($cmdopts): $ssh_rc"				
				;;
			bridge|noop|ignore|echo|date)
				dbg COMMAND "cmd=$cmd,$cmdopts,($(date +%T))"
				[ $cmd = echo ] && { cMR OK "Command $cmd($cmdopts=$(cExpand "$cmdopts")) from $(cat $fHost) at $(date +%c) (version: $sMeAge)" ; [ "$cmdopts" = TESTERROR ] && cErr "Test error" ;}
				[ $cmd = date ] && { _msg="$(date) (PID=$(cPid))" ; cEcho "$_msg" ; cMR OK "Command $cmd($cmdopts): $_msg" ;}
				;;
			beacon)
				cProbeGET
				cMqttBeacon
				;;
			autossh)
				cProbeSET
				_ml="$((${cmdopts:-12} * 3600 - 15	))" # Default = almost 12 hours
				dbg AUTOSSH "maxlife=${_ml}s : ffhosts=$ffhosts"
				# if [ "${ffhosts#"$hFull"}" != "$ffhosts" ] ; then # do it for all hosts at once, in the first iteration

					# AUTOSSH_GATETIME    # how long must an ssh session be established before we decide it really was established
					#                       (in seconds). Default is 30 seconds; use of -f  flag sets this to 0.
					# AUTOSSH_LOGFILE     # file to log to (default is to use the syslog facility)
					# AUTOSSH_LOGLEVEL    # level of log verbosity, corresponding to the levels used by syslog; so 0-7 with 7 being the chattiest
					export AUTOSSH_MAXLIFETIME=$_ml # set the maximum time to live (seconds) # 604800s = 1 week
					export AUTOSSH_MAXSTART=-1    # max times to restart (default -1 means no limit)
					# AUTOSSH_MESSAGE     # message to append to echo string (max 64 bytes)
					# AUTOSSH_PATH        # path to ssh if not default
					export AUTOSSH_PIDFILE=$dTmp/autossh.pid     # write pid to this file
					export AUTOSSH_POLL=40        # how often to check the connection (default 600 seconds)
					# AUTOSSH_FIRST_POLL  # time before first connection check (seconds)
					# AUTOSSH_PORT        # port to use for monitor connection
					# AUTOSSH_DEBUG       # turn logging to maximum verbosity and log to                           stderr
					[ "$bVerbose" ] && env | grep AUTOSSH | xargs 1>&2
					# set -x #  manage_gluon_mqtt -m localhost -c bridge -v
					if [ "var1" ] ; then
						_mpcmd="$cMPub -r -h localhost -t $sSite/$hTarget/autossh/checktime"
						cSsh "d=\$(date '+%c (heartbeat)') && $_mpcmd -m \"\$d\" && $sMe -m localhost -c memory"
						_msg="${cmdopts:+($cmdopts) }"
						if [ $ssh_rc = 0 ] ; then
							cMR OK "${_msg}already had MQTT listener, doing nothing."
						else
							_msg="${_msg}check result: ${ssh_msg:-$ssh_rc}, "
							if [ $ssh_rc = 127 ] ; then
								_msg="${_msg}no $MP? - run -c install first!"
								dbg AUTOSSH "$_msg"
								cErr "$_msg"
								cMR ERROR "$_msg:"
							elif [ $ssh_rc = 255 ] ; then
								_msg="${_msg}doing nothing."
								dbg AUTOSSH "$_msg"
								cMR ERROR "$_msg:"
							else
								_msg="${_msg}will start autossh ($cmdopts) and run check"
								dbg AUTOSSH "$_msg"
								_spec="[::]:1883:localhost:1883" # "[::]:1883:localhost:1883"
								# this line must be in /etc/config/dropbear:
								# option GatewayPorts 'on'
								autossh -f -N -T ${bVeryVerbose:+-v} -R "$_spec" $hFull "$sMe -m localhost -c bridge ${mqttGroup:+-g $mqttGroup}" # || dbg AUTOSSH "rc=$?"
								sleep 3
								_pid="$(cat $AUTOSSH_PIDFILE)"
								dbg AUTOSSH "pid=$_pid"
								cSsh "date '+%c (restarted autossh)' | $_mpcmd -l"
								# cSsh "netstat -l | grep 1883"
								cMR OK "Command $cmd $cmdopts executed."								
							fi
						fi
						cAddSuccHost
#DELETE_BEGIN#
					else
						# nPidAutoSSH=$! # nPidAutoSSH="$(cat $AUTOSSH_PIDFILE)"
						# dbg AUTOSSH "pid=$nPidAutoSSH for: $ffhosts"
						sleep 10
						trap_autossh() {
							cmd="autossh" && cMR ONGOING "exiting."
							jobs
							wait $nPidAutoSSH
							kill $nPidAutoSSH 2>$fNul || :
							dbg AUTOSSH "Killed nPidAutoSSH=$nPidAutoSSH, now stopping at $(date)"
						}		
						trap 'trap_autossh' EXIT
#DELETE_END#
					fi
				# fi
				;;
			loop)
				cProbeGET
				cmdopts="${cmdopts:-5}"
				cMR ONGOING "$cmd'ing $cmdopts times"
				if [ "$cmdopts" -ge 1 -a "$cmdopts" -le 99 ] ; then
					_cmd='cSsh date -u +%s'
					$_cmd ; data="$ssh_data" && cEcho "$data"
					for i in $( seq $((cmdopts - 1)) ) ; do
						$_cmd
						dbg "$cmd" "$ssh_data"
					done && cEcho
					cMR OK "Command $cmd: Performed $cmdopts-times /bin/date in $(( ssh_data - data)) seconds: $data-$ssh_data"
				else
					cMR ERROR "$cmd: Invalid parameter '$cmdopts'"
				fi
				;;
			install)
				cProbeNOMQTT
				cSsh -v "id -nu"
				_user="$(cOut|cSanitize)"
				if ! [ "$_user" ] ; then
					cErr "targetuser on targethost could not be determined. Debug your SSH setup:"
					cntnue # abort install
				fi
				_auto="" # use autoupdater_branch setting as indicator for seeing if we are on Gluon
				_lxlvl=1 # determine "Linux level", 0=Basic/1=GNU_Linux-like/2=e.g. Debian-like/3=OpenWrt (implied UCI)/4=Gluon

				if [ "$hFull" != localhost -o "$(dirname "$0")" != /sbin ] && [ "$_user" = root ] ; then
					cEcho "Remote targetuser is $_user: Will try to copy this script to /sbin later..."
					cStackCommand filecopy
					fFile="$0"
				fi

				os_data="$(cGetOSData)"
				dbg "$os_data"

				# STEP: log memory size at the beginning
				cSsh -v "df -PhT"
				_sizedata="$ssh_data" # TODO: duplicated code from "mountsizes", save result for later

				# STEP: try to install mosquitto, if not there yet
				cSsh "command -v $MP"
				if cData ; then # FIXME: remove false after debugging
					cEcho "$MP already installed on $hFull..."
				else
					cEcho "$hFull: $MP not found .. determining install cmd .."
					cSsh "command -v opkg || command -v apt || echo nothing" 2>$fNul
					_scmd="$(basename "$ssh_data")" && _c="$_scmd update && $_scmd install mosquitto"
					case "$_scmd" in
					opkg|X)
						# FIXME on newer Gluon - might needed for SSL downloads:
						# 1) temporarily change https to http for "openwrt_packages" in /etc/opkg/distfeeds.conf
						# 2) opkg install libustream-tls && opkg install ca-certificates  #   or opkg ... --no-check-certificate
						_c="$_c-client-nossl coreutils-stdbuf"
						;;
					apt|X)
						_c="$_c-clients coreutils"
						;;
					nothing|X)
						cErrAndExit "ERROR: opkg/apt not found on $hFull. Stopping..." # never returns here afterwards
						;;
					esac
					cEcho "Executing: $_c (please wait)"
					cSsh "$_c" # || { cEcho "cSsh failed: $_c, aborting ..." ; cntnue ;}
					_msg="$ssh_data (rc=$ssh_rc)"
					dbg INSTALL "$_msg" || cEcho "Installer returned $_msg"
				fi
				[ $ssh_rc -ne 0 ] && { cEcho "cSsh failed: $_c, aborting ..." ; cntnue ;}

				# STEP: change the shell prompt PS1
				# PS1='\[\033[31;1m\]\h \[\033[32;1m\]$PWD\[\033[0m\] \[\033[31m\]\$\[\033[0m\] ' # nicer prompt on OpenWrt
				# 'X=${SHLVL#1}' \; 'X=${X:+($X)}' ...
				echo PS1=\''\[\033[31;1m\]\h \[\033[32;1m\]$PWD\[\033[0m\] '\#\ \' | cSsh 'd=/etc/profile.d ; [ -d $d ] && ! grep -sq PS1= $d/my.sh && cat >> $d/my.sh' &&
					_lxlvl=2 && dbg INSTALL "Prompt written" # Debian-like

				# STEP: get autoupdater settings (use as indicator for seeing if we are on Gluon)
				# now comes a Gluon-specific part - determine Gluon by checking for the UCI entry autoupdater_branch
				cSsh -v "uci get autoupdater.settings.branch" && _lxlvl=4 # Gluon
				_auto="$ssh_data"
				dbg AUTOUPDATER "branch=$_auto"
				[ ! "$bDoAll" ] && {  
					# only minimal install requested: abort here				
					cEcho "Done partly install for target $hTarget (autoupdater_branch=$_auto,bDoAll=$bDoAll)..."
					ssh_data="$_sizedata" # inject the previously saved size data...
					cmdsToDo="mountsizes_prev${cmdsToDo:+,$cmdsToDo},mountsizes"
					cntnue # quit installation here, unless on Gluon or $bDoAll = yes
				}
				cCWrite .autoupdater_branch
				
				# STEP: open firewall for MQTT on Gluon (only on Gluon)
				if [ "$_lxlvl" -ge 4 -a "yup" -a ! "$bDoExperiment" ] ; then # on Gluon
					# similar to https://ffmuc.net/wiki/doku.php?id=knb:ssh#webseite_des_ff-knoten_aus_dem_lan_aufrufen :
					# uci set firewall.wan_http=rule
					# uci set firewall.wan_http.name=wan_http
					# uci set firewall.wan_http.src=wan
					# uci set firewall.wan_http.proto=tcp
					# uci set firewall.wan_http.dest_port=80
					# uci set firewall.wan_http.target=ACCEPT
					# uci commit
					# /etc/init.d/firewall reload
					# uci delete firewall.wan_http
					
					# TRY LATER: wan over wifi: https://harz.freifunk.net/wiki/doku.php/anleitungen/gulon/wwan

					cEcho "Assuming Gluon: add firewall rules for incoming MQTT..." # outgoing should be working anyways
					# works for Ulmer Software w/o Gluon, too... DONT KNOW IF NECESSARY ON ALL GLUON VERSIONS
					cSsh "xargs ${bVerbose:+-t} -n 1 uci set ; uci commit" << EOF
						firewall.wan_mqtt=rule
						firewall.wan_mqtt.name='wan_mqtt'
						firewall.wan_mqtt.src=wan
						firewall.wan_mqtt.proto='tcp'
						firewall.wan_mqtt.dest_port='1883'
						firewall.wan_mqtt.target='ACCEPT'
						firewall.mesh_mqtt=rule
						firewall.mesh_mqtt.name='mesh_mqtt'
						firewall.mesh_mqtt.src=mesh
						firewall.mesh_mqtt.proto='tcp'
						firewall.mesh_mqtt.dest_port='1883'
						firewall.mesh_mqtt.target='ACCEPT'
EOF
					cSsh -v "/etc/init.d/firewall reload" || dbg "Failed to reload firewall."
					cOut
				fi
				
				# STEP: add more firewall rules (only on Gluon)
				if [ "$_lxlvl" -ge 4 -a "$bDoExperiment" ] ; then 
					cEcho "... adding other firewall rules for outgoing MQTT..."
					# works for Ulmer Software w/o Gluon, too... DONT KNOW IF NECESSARY ON ALL GLUON VERSIONS
					{
					# echo firewall.any_mqtt=rule
					# echo firewall.any_mqtt.src_port='1883'
					# echo firewall.any_mqtt.dest='mesh'
					# echo firewall.any_mqtt.name='any_mqtt'
					# echo firewall.any_mqtt.target='ACCEPT'
					# echo firewall.any_mqtt.proto='tcp'
					for x in loc_client wan mesh ; do
						_r="${x}_mqtt"
						echo firewall.$_r.name="$_r"
						echo firewall.$_r=rule
						echo firewall.$_r.dest_port="1883"
						echo firewall.$_r.src="$x"
						echo firewall.$_r.target="ACCEPT"
						echo firewall.$_r.proto="tcp"
					done
					} | cSsh "xargs ${bVerbose:+-t} -n 1 uci set ; uci commit"
					
					cSsh -v "/etc/init.d/firewall reload" || dbg "Failed to reload firewall."
					cOut
					exit 55
				fi
				
				# STEP: add a regular MQTT "beacon" to crontab on Linux-like systems
				if cMqttBeacon && [ "$_lxlvl" -ge 2 ] ; then
					if cSsh -v "crontab -l | grep \"$sMe\"" ; then
						cEcho
						dbg MODIFY "A crontab line already containing '$sMe' was found... Leaving crontab unmodified."
					else
						cEcho "crontab entry with '$sMe' not found... adding a simple one... pls adapt it later!!"
						_line="0 * * * * sleep 50 ; $sMe -M -c echo+LOCALCHIME${_auto:+,machine-data,statistics} -m $hPubMqtt,localhost"
						cSsh "{ crontab -l ; echo \"$_line\" ;} | crontab - ; ${bVerbose:+echo crontab is now: ; crontab -l}"
						cEcho
					fi
				fi

				# STEP: copy a local, generic public key for login (only to /tmp, has then to be finished manually)
				_f=~/.ssh/id_rsa_piraten.pub # put your own key there!
				[ -r "$_f" ] && { dbg PUBKEY "Copying $_f" || echo "Public key file: $_f";} && 
						cat $_f | cSsh 'cat >> /tmp/pubkey ; ls -al /tmp/pubkey'

				# ... FIXME: still not implemented: installing it as an MQTT daemon on OpenWrt/Gluon ...
				_f=/etc/rc.local
				cSsh "cat $_f"
				if [ "$_lxlvl" -ge 3 ] ; then # FIXME: linux should be sufficient
					if cOut|grep $sMe ; then
						dbg MODIFY "The $_f line containing '$sMe' was found above... Leaving $_f unmodified."
					else
						cEcho "$_f entry with '$sMe' not found... adding a simple one... pls modify it later!!"
						_line="\( sleep 240 \; $sMe -c echo+BOOTED,machine-data,statistics -m $hPubMqtt,localhost ; \) \&"
						cSsh "sed -i.sav -e  \"s/^exit 0/$_line\\nexit 0/\" $_f ; 	${bVerbose:+echo $_f is now: ; cat $_f }"
						cEcho
					fi
				fi
				;;
			filecopy|selfcopy)
				cProbeNOMQTT
				fFile="${fFile:-$cmdopts}" # file must be in the local directory or a symbolic link in the local directory!
				fFile="${fFile:-$0}"
				fPath="$fFile"
				fBase="$(basename "$fPath")"
				#DELETE_BEGIN#   # Delete the following script part when compressing the script
				_fn=$dCache/$fBase.$(date +%M)
				cp -Lpr "$fPath" $_fn
				if [ ! "$bDoAll" ] ; then
				  sed '/[ \t]#DELETE_BEGIN#/,/[ \t]#DELETE_END#/d' -i $_fn &&
					sed -e 's/^[ \t]*//' -e 's/\(^[ \t]*\| \+\)#\($\|#*[\t ]\+[^"].*$\)//g'  -i $_fn &&
					#      ^Whitespace      WhiteSpace # Comment
					  sed -e 's/() *{/(){/' -e 's/[\t ]*\t[\t ]*/\t/g' -e '/^$/d' -e 's/ *;/;/'   -e 's/  *"/ "/g' -e 's/"  */" /g' -e 's,\$( ,$(,g' -e 's, )",)",g'  -e 's,\$(echo ,$(e ,g' -e 's,\t+$,,g' -e 's,^local ,l ,'  -e 's,^echo ,e ,'  -e 's,\<cntnue\>$,c,'  -e 's,\<return\>,r,' -e "s,\<command\>,\$C,g" -e 's,_msg\>,_m,g'  -e 's,\<cMqtt,cM,g'  -i $_fn &&
					  #       () *{            Whitesp tab Whitespace  emptyline  any WS before ;  WS bef DouQts   WS after DblQts  spaceAfter$(     spaceBefore)"    echo to e after $(     tab at eol     local to alias l    echo to e          cntnue to c            return to r          command  to  $C        suffix _msg to _m    command with cMqtt...
						cp -p $_fn /tmp &&
						  sed -E -i $_fn  -e 's/([^\];) +/\1/g'  -e 's,[ \t]*(&&|>|>>|\|)[ \t]*,\1,g' -e '/awk|lua|printf|test|:/!s,"([a-z0-9/-][a-z0-9/._-]+)",\1,g' && #  -e 's,[^\)]\) [^a-zA-Z],),g'  &&
						  #                  WS after ;       Whitesp around && or | , but not << or <  pure strings > 1c in double quotes   #FRAGILE
						    bash -x -n $_fn && cCmv ash && ash -x -n $_fn # smoke test syntax of compressed script with bash and ash
				  rc=$?
				  dbg $cmd "$fPath ($( wc -c < $fPath )) trimmed to $_fn ($( wc -c < $_fn )): rc=$rc" # && cp $_fn /tmp/$(basename $_fn).$(date +%M)
				  [ $rc != 0 ] && cErrAndExit "Reducing script $_fn returned error $rc!"
				fi
				if [ ! "$bDoAll" -o "$hDone" ] && diff -Nq $_fn $_fn.save && find $_fn.save -mmin -30 > $fNul ; then
					_msg="No changes in $_fn (therefor no copy)"
					cMR OK "source unchanged."
				else
					{ cp -p $_fn $_fn.save ; cp -p $_fn $dCache/$fBase.last ;} # 2>$fNul
					fPath=$_fn
				#DELETE_END#
					if _t="/sbin/$fBase" ; scp -O -p ${bQuiet:+-q} "$fPath" "$sSshUser:$_t" ; then
						_msg="$fPath copied to $_t"
						cMR OK "path=$_t"
					elif _t="/tmp/$fBase" ; scp -O -p "$fPath" "$sSshUser:$_t" && cSsh "rm /sbin/$fBase ; ln -s $_t /sbin" ; then
						_msg="$fPath copied to /tmp and linked to /sbin"
						cMR OK "path=$_t"
					else
						_msg="scp $fPath to /sbin or /tmp both failed"
						cMR ERROR "$_msg:" 
					fi
				#DELETE_BEGIN#
				fi
				#DELETE_END#
				dbg FILECOPY "$_msg"
				cSsh "$fBase -m localhost,$hPubMqtt -c echo+FILECOPY ; sleep 1 ; [ -r .config/$MP ] && $fBase -c echo+FILECOPY" 2>$fNul & # dont wait for this...
				sleep 1
				#DELETE_BEGIN#
				rm $_fn
				#DELETE_END#
				;;
			sh)
				cProbeNOMQTT
				for i in $(seq "${cmdopts:-1}") ; do
					cMR ONGOING "Trying shell (i=$i)"
					ssh $sSshUser && break
					sleep 5
				done ;;
			homie-update|discovery-update)
				cProbeGET
				_cmd="cat /proc/uptime"
				homieuptime="$( [ "$hFull" = localhost ] && $_cmd || $0 -h "$hFull" "$_cmd"  )" && hLine \$stats/uptime "$(p "$homieuptime" | cCut . )" -M
				cStackCommand "localclients,wifistatus,gluondata,machine-data"
				;;
			homie-delete|discovery-delete)
				cProbeSET
				homie="$(cLower $hTarget)" # duplicated code...
				announce_disco "$homie" -d
				;;
			wifidown) # stop Freifunk public interface
				cProbeSET
				cGetPubIF || cntnue # also sets sPubIfs and sSsidBase
				dbg PREPARING "$cmd on host $hTarget (if=$sPubIf0,$sPubIf1) ..."
				cSsh "{ iw dev $sPubIf0 del ${sPubIf1:+; iw dev $sPubIf1 del >$fNul} ;} 2>&1"
				_tmp="$(cOut|xargs)"

				if [ $ssh_rc -eq 237 -o $ssh_rc -eq 1 ] ; then
					cMR OK "$_tmp (rc=$ssh_rc)"
					hLine publicwifi/clientscount 0 && _tmp=""
				elif [ -z "$_tmp" -a $ssh_rc != 0 ] ; then
					cMR ERROR "tempstr=$_tmp:"
					hLine publicwifi/clientscount 0 && _tmp=""
				else
					cMR OK "tempstr=$_tmp"
				fi
				dbg wifidown "Now starting wifistatus"
				cStackCommand wifistatus
				;;
			wifiup|wifistatus|ffup|ffstatus) ## determine status of open/guest wifi network, n.b. ff... are being obsoleted
				cProbeGET
				cGetPubIF # keep going
				dbg PREPARING "$cmd on host $hTarget (if=$sPubIfs) ..."
				_scmd="command -v iw >$fNul 2>&1 && iw $sPubIf0 info || uci show wireless.client_radio0.ssid || uci show wireless.ap_gn_g.ssid" # .. fallback to uci-setting ... and ignoring any 2nd interface for now
				ssh_data=""
				if [ $cmd = wifiup ] ; then
					cProbeSET
					cMR ONGOING "Running $_scmd"
					cSsh "wifi up && sleep $nWifiSleep && $_scmd"
				elif [ "$sNewSSID" ] ; then
					ssh_rc=0
					dbg REUSED "sNewSSID=$sNewSSID"
				else
					cMR ONGOING "Running $_scmd"
					cSsh "$_scmd"
				fi
				ssh_data="$(cOut|tail -14)" # shorten away the long redundant error msg from stdout from iw
				# dbg TAILED "$ssh_data"
				if ! [ "$sNewSSID" ] ; then # ... was cached or if not cached, not unreachable
					sNewSSID="$(cOut|sed -n -e '/\.ssid=/{s/.*=//;p;q}' -e '/ssid/{s/\tssid //;p;q}')" # coerced uci and iw output to get results # for iwinfo: -e '/ESSID:/{s/[^:]*: //;s/\"//g;p;q}' 
					if [ $ssh_rc = 0 ] && [ "${ssh_data#"Interface $sPubIf0"}" != "${ssh_data}" -o "${ssh_data#wlan}" != "${ssh_data}" ] ; then
						dbg SUCCESS "tempstr=$ssh_data"
						# cEcho "$sNewSSID"
						sChannel24="$(cOut|awk '$1=="channel" {print$2}' )" # works for iw
						cMS 	/publicwifi/state	ON -M
						hLine	publicwifi/state	true  -M
						cBothMqtt 	radio/channel24 	"$sChannel24" -M
					else
						if cData ; then
							dbg "command=$cmd, rc=$ssh_rc, ssh_data=$ssh_data"
							if [ $ssh_rc = 255 ] || cOut | grep -w -q -E "open failed|connect failed" ; then # unreachable
								cMR OFF "rc=$ssh_rc ($ssh_msg)"
								( sleep 60 ; echo PERIODIC NOOP "sooner" )  > $fPipe & # inject for a sooner repeat
							elif [ "${ssh_data#"$sPubIf0"}" = "${ssh_data}" ] ; then
								cMR OFF "rc=$ssh_rc (interface missing or down)"
							else
								cMR ERROR "rc=$ssh_rc // $(cOut|xargs)"
							fi
						fi
						cMS 	/publicwifi/state	OFF 	-M
						hLine	publicwifi/state	false	-M
						# cEchoPub publicwifi/clientscount 0
						cBothMqtt 	publicwifi/clientscount 0
					fi
				fi
				if [ "$sNewSSID" ] ; then
					cEcho "$sNewSSID"
					_ssid="$( p "$sNewSSID" | sed -e 's,.*/,,' -e 's,\",,g' )"
					cMR OK "$sNewSSID"
					cBothMqtt publicwifi/ssidshort "$_ssid"
					cBothMqtt publicwifi/ssid "$sNewSSID"
					sNewSSID="" # delete cached SSID
				else	
					cMR ERROR "SSID is empty:"
				fi
				;;
			ffcond)
				cntnue # FIXME
				cProbeGET
				cGetPubIF || cntnue # also sets sPubIfs
				cSsh '{ for i in 1 2 2 ; do iw dev mesh0 scan ; sleep $i ; done } | tee $dCache/wifis ; echo ++++++++++++ ; iwinfo | grep sPubIf0'
				ifresult="$(cOut|grep -A 3 '++++++++++' | grep -m 2 "client0 *ESSID:" )"
				cErrAndExit "UNFINISHED" # FIXME
				if cOut|grep -A 9 -w '6e:a3:09:ea:31:e00' | grep -w "SSID:.$sSsidBase"
				then
					# client0   ESSID: "muenchen.freifunk.net/welt"
					cEcho "To be upped..."
					[ "$ifresult" ] || cStackCommand wifiup
				else	
					cEcho "To be downed..."
					[ "$ifresult" ] && cStackCommand wifidown # FIXME: Correct && ?
				fi
				dbg cmdsToDo "$cmdsToDo"
				# ( ( iwinfo | fgrep client0 ) || ( wifi up ; echo wifi upped. ) )	) || ( iwinfo | fgrep client0 && iw dev client0 del ; echo if downed )
				;;
			ffchannel24|ffchannel24-*|channel24|channel24-*|radiochannel24set)   # FIXME: only implemented for 2.4Ghz (=first) radio
				cProbeGET
				cGetPubIF 0 || cntnue # gets sPubIfs, sSsidBase, and prepares channel
				_val="$cmdopts"
				[ "$_val" ] || _val=$cmd
				_val="${_val#ff}" ; _val="${_val#channel24}" ; _val="${_val#-}" #  remove any of ffchannel24- ffchannel24 channel24- channel24
				IFS=_ set -- $_val
				unset IFS
				cmd=channel24
				if [ "$1" ] ; then
					if [ "$(cTrd 0-9 "$1$2" )" ] || [ $1 -lt 1 -o $1 -gt 13 ] || { [ "$2" ] && [ $2 -lt 36 -o $2 -gt 165 ] ; } ; then
						cMR ERROR "Illegal channel: $1 or $2"
						cntnue
					else
						_r1=wireless.radio0.channel
						_r2=wireless.radio1.channel
						cMR ONGOING "Setting $_r1=$1 ${2:+$_r2=$2 }(if=$sPubIf0,$sPubIf1)"
						cSsh "uci set $_r1=$1 && ${2:+uci set $_r2=$2 &&} wifi up && sleep $nWifiSleep && { iwinfo $sPubIf0 info ${2:+; iwinfo $sPubIf0 info} ; } | grep -wi channel 2>&1" # FIXME: ignoring any 2nd interface # iwinfo $sPubIf0 info
						dbg "_result=****$ssh_data****"
					fi
				fi
				cStackCommand wifistatus # ... implicitly followed by a wifistatus
				;;
			limit|limit-*)
				cProbeSET
				_tmp="$cmdopts"
				[ "$_tmp" ] || _tmp=$cmd
				_tmp=$(cTrd -c 0-9 "${_tmp#limit-}") # for security reasons
				cmd=limit
				# cErrAndExit "UNIMPLEMENTED"  # FIXME
				if [ $_tmp -lt 50 -a $_tmp -ne 0 ] ; then
					cMR ERROR "Illegal limit: $_tmp"
					cntnue
				fi
				cMR ONGOING "Setting gluon.mesh_vpn.limit_*gress=$_tmp"
				cSsh "uci set gluon.mesh_vpn.limit_ingress=$_tmp && uci set gluon.mesh_vpn.limit_egress=$_tmp && gluon-reconfigure 2>&1" # FIXME: ignoring any 2nd interface # iwinfo $sPubIf0 info
				dbg "_result=****$ssh_data****"
				# FIXME: more code to be added
				# ...
				;;
			wifissid|wifissid_*|wifissid-*)
				# dbg "cmd=$cmd,cmdopts=$cmdopts"
				cProbeGET
				cGetPubIF 0 || cntnue # sets sPubIfs and sSsidBase
				[ "$sSsidBase" ] || { cMR ERROR "Current SSID base empty - no change" ; cntnue ;}
				# _tmp="${cmdopts:-welt}"
				_tmp="${cmd#wifissid_}"
				_tmp="${_tmp#wifissid-}"
				_tmp="${_tmp#wifissid}"
				_tmp="${_tmp:-$cmdopts}"
				# ! [ "$_tmp" ] || cEcho "Empty shortssid from cmd=$cmd ($cmdopts), using 'welt'"
				_ssid="$(cTrd '}{)( ,=' "${_tmp:-welt}")"
				dbg _ssid "$_ssid"
				cmd=wifissid
				# further checks for allowed and legal SSID values among the gluon domains ....
				if [ "$_ssid" = OFFLINE -o "$_ssid" = MYHOSTNAME -o "$_ssid" = %s -o "$_ssid" = $hTarget ] || expr "$(cGetGluonDomainsStarred)" : ".*\*${_ssid}[*]" >$fNul ; then
					cMR ONGOING "Intended SSID suffix: $_ssid"
					otherssid="$sSsidBase/$_ssid"
					dbg INTENDEDSSID "$otherssid"
				else
					cMR ERROR "Illegal shortssid: $_ssid"
					cMS /gluondata/gluon-domains "$(cGetGluonDomainsStarred)"
					cEcho "Illegal shortssid: $_ssid"
					cntnue
				fi
				# echo ================
				cSsh ": set -x &&
						_hn=\"\$(tr A-Z a-z <$fHost)\" &&
						other=\"\$( printf %s \"$otherssid\" | sed -e \"s,MYHOSTNAME,\$_hn,\" -e \"s,%s,\$_hn,\" )\"  &&
						otheresc=\"\$( ec\"ho\" \"\$other\" | sed -e 's,/,\\\\/,' )\"  &&
						prevssid=\"\$( iwinfo $sPubIf0 info | sed -e 's/: /:/' -e '1q' | cut -d: -f2 | xargs )\"  &&
						ec\"ho\" SSIDPREV:\$prevssid | awk \"{print} /\$otheresc/ { exit(99) }\"  &&
						[ \"\$prevssid\" ] &&
						iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' | awk \"{print} /\$otheresc/ { exit(99) }\" &&
						uci set wireless.client_radio0.ssid=\$other ${sPubIf1:+&& : $sPubIf1 && uci set wireless.client_radio1.ssid=\$other} &&
				        wifi up && sleep $nWifiSleep ;
						[ \"$bDoAll\" ] && uci commit ;
						iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDNEW/' -e '1q' " # FIXME: ignoring any 2nd or further interface
				# echo ----------------
				dbg RESULT "=***$ssh_data***"
				prev_ssid="$(cOut | awk -F: '/SSIDPREV:/ {print$2;exit}')"

				if ! cData ; then
					_log="error: $ssh_rc ($ssh_msg) OR ssh data empty, aborting command $cmd..."
					cEcho "$_log"
					cMR ERROR "$_log"
				elif [ "$prev_ssid" ] ; then
					sNewSSID="$(cOut|grep -m 1 SSIDNEW:  | cCut : 2 | xargs)"
					_log="previous=$prev_ssid, new=$sNewSSID"
					if [ "$prev_ssid" = "$sNewSSID" ] ; then
						_log="$_log (no change)"
					else
						sNewSSID=""
					fi
					dbg "$_log"
					cMR OK "$_log"
					cStackCommand wifistatus # ... implicitly followed by a wifistatus
				fi
				;;
			gluonreconfigure)
				cProbeSET
				cGetPubIF || cntnue # sets sPubIf* and sSsidBase
				cMR	ONGOING "Affected Interface(s): $sPubIfs"
				# 6 seconds needed for s after wifi up !
				cSsh "iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDPREV/' -e '1q' ; gluon-reconfigure | tail -3 ; wifi up  ; sleep $nWifiSleep ; iwinfo $sPubIf0 info | sed -e 's/: /:/' -e 's/ESSID/SSIDNEW/' -e '1q' "
				dbg $cmd "$ssh_data"
				prev_ssid="$(cOut |grep SSIDPREV| cCut : 2 )" # client0;SSIDPREV:"muenchen.freifunk.net/jupiter";Access Point: 26:7E....
				new_ssid="$( cOut |grep SSIDNEW	| cCut : 2 )"
				cEcho "$hTarget: Ran gluon-reconfigure, previously $prev_ssid, then wifi up, then $new_ssid.\n"
				if [ "$prev_ssid" != "$new_ssid" ] ; then
					cStackCommand localclients
				fi
				cStackCommand wifistatus # ... implicitly followed by a wifistatus
				;;
			site)
				cProbeGET
				cGetSitecode FRESH
				if [ "$sSite" ] ; then
					cmd=gluondata 
					cEchoPub site $sSite
				else 
					sSite=UNKNOWN
					cMR ERROR
				fi
				;;
			gluondata)
			  if ! os_data="$(cGetOSData)" ; then
			  	cMR ERROR "Empty OS data"
			  else
			    # get all infos in one call (line by line):
				cSsh "{ uci get autoupdater.settings.branch && uci get autoupdater.settings.enabled && uci get gluon.core.domain ;
					lua -e 'print(require(\"platform_info\").get_model())' ; cat $dGluon/gluon-version ; cat $dGluon/release ;} 2>&1"
	
				cEchoPub os-data "$os_data"	
				cEchoPub autoupdater-branch 	"$(cLine 1)"
				cEchoPub autoupdater-enabled	"$(cOut|sed -n -e 2s/0/false/ -e 2s/1/true/ -e 2p)"
				cEchoPub core-domain	"$(cLine 3)"
				cEchoPub model	"$(cLine 4)"
				cEchoPub gluon-version	"$(cLine 5)"				
				cEchoPub release	"$(cLine 6)" "$(cOut|sed -n -e 's/^v//' -e 6p)"
				cEchoPub gluon-domains	"$(cGetGluonDomainsStarred)"
				cEchoPub site $sSite
			  	cMR OK
			  fi
			  ;;
			machine-data)
				os_data="$(cGetOSData)"
				dbg os_data "$os_data"
				cSsh "command -v $MP || echo NONE ; cat /proc/version /proc/cpuinfo"
				data="$(cOut|awk -v os_data="$os_data" '
					NR==1 {mpub=$1}
					NR==2 {lxversion=$3 ; FS=": " }
					/^machine|^Hardware/ { FS=": " ; printf "{*mosquitto*:*%s*,*linuxversion*:*%s*,*machine*:*%s*,%s}", mpub, lxversion, $2, substr(os_data,2,length(os_data)-2) ; exit 0 }
					' )"
				if [ "$data" ] ; then
					cEcho "$(cStarredToJSON)"
					cMS /$cmd "" -M
				else
					cMR ERROR "$cmd failed: no output data"
				fi
				;;
			speedtest|speedtest0*)
				cProbeGET
				_spparam="${bVerbose:+-q}" ; _spparam="-q --no-check-certificate"
				sLastSpeed="$(cCRead .lastspd 1)" && sLastSpeed=",*lastSpeedMb*:$sLastSpeed"
				_spcmd="$( [ "$bDoAll" ] || cCRead .lastspdcmd 2)" # prefer the previous one for at most 2 days
				[ -z "$_spcmd" -o $cmd = "speedtest0" -o $cmd != "${cmd#"$_spcmd"}" ] && _spcmd=$cmd # make it at least as big as the previous max.
				# _url="15MB 30MB 70MB 150MB 250MB 300MB" # https://link.testfile.org 
				# _url="1MB 5MB 10MB 50MB 100MB 1GB" # http://speedtest.tele2.net
				_url="5MB 10MB 20MB 50MB 100MB 200MB 512MB 1GB" # http://ipv4.download.thinkbroadband.com
				_url="100M 1G 10G" # http://speedtest.belwue.net/100M
				[ "$_spcmd" = "speedtest" ] && _spcmd="speedtest0"
				_sht=${_spcmd#speedtest}
				_url="$(p $_url | cut -d" " -f ${#_sht} )" # cut out the x'th element
				if [ -z "$_url" ] ; then
					cErr "speedtestcmd '$_spcmd' too excessive or fetching failed!"
					cMR ERROR "Last result ${_val}s or file size ${filesize}B too small"
					cCWrite .lastspdcmd speedtest0
					cntnue
				fi
				# _url="https://link.testfile.org/$_url.zip" ; 
				# _url="http://speedtest.tele2.net/$_url.zip" ; 
				# _url="http://ipv6.download.thinkbroadband.com:8080/$_url.zip"
				# _url=http://ipv4.download.thinkbroadband.com/$_url.zip # 80.249.99.148
				_url=http://129.143.4.238/$_url # http://speedtest.belwue.net/100M
				dbg SPEEDTEST "Using $_url ..."
				cMR ONGOING "Trying $_url"
				cSsh "date -u +%s; wget $_spparam -O - $_url | wc -c ; date -u +%s"
				if [ $ssh_rc = 0 ] ; then
					starttime="$(cLine 1)"
					filesize="$(cLine 2)"
					endtime="$(cLine 3)"
					_val="$((endtime - starttime))"
					speedMB="$( awk "BEGIN { printf \"%.1f\" , $filesize*8 / ($_val+0.000001) / 1048576}" )"
					if [ "$filesize" -lt 20000 ] ; then
						dbg "File size ${filesize}B for $_url too small, will abort."
						cStackCommand "speedtest0000000000" # head for abort
					elif [ "$_val" -lt 11 ] ; then
						_spcmd="${_spcmd}0" # try next bigger size
						_s="Result ${_val}s too small for file size ${filesize}B"
						dbg "$_s, redo with $_spcmd"
						cMR ONGOING "$_s. Retrying larger file." "*speedMb*:*$speedMB*"
						cCWrite .lastspdcmd "$_spcmd" # cache bigger file speedtest for next time
						cStackCommand "${_spcmd}"
					else
						cEcho "$speedMB"
						cMS /speedtest "{*speedMb*:$speedMB,*filesize*:$filesize,*elapsedtime*:$_val,*unit*:*Mb/s*${sLastSpeed}}"
						cCWrite .lastspd "$speedMB"
					fi
				else
					cEcho "ERROR: $ssh_rc"
					cMR ERROR "{*ERROR*:*$ssh_rc*,*url*:*$_url*${sLastSpeed}}"
				fi
				;;
			status)
				cSsh "echo $sMeAge ;cat /proc/uptime /proc/loadavg"
				cEcho
				data="$(cOut|awk '
					NR==1 { age=$0 }
					NR==2 { uptime=sprintf("%d", $1) }
					NR==3 { printf "{*uptime*:%s,*load*:%.2f,*version*:*%s*}",uptime,$1,age }' )" # uptime in seconds
				cMS /$cmd
				;;
			printmap)
				cProbeGET
				cSsh "print_map.sh" || cntnue # Freifunk node info as JSON for non-Gluon systems, e.g. from earlier Ulm
				cOut|json_pp
				cMS /$cmd "$ssh_data"
				;;
			localclients)
				cProbeGET
				fCollection=$dTmp/clientcollection
				touch $fCollection && chmod g+w $fCollection
				fClients=$fCollection.$hTarget
				# fManu=$dCache/manuf
				[ -r $fMacIDs ] || touch $fMacIDs || fMacIDs=$fNul
 
				# get the two table of the local clients on the node together, split them in awk further down
				if ! cSsh "batctl dc && echo ==== && batctl tl" ; then
					_msg="Connection $sSshUser failed or no batctl:"
					cErr "$_msg"
				  	cMR ERROR "$_msg"
					cntnue
				fi
				dbg "**1" " result ***" && cOut # output of both batctl commands
				
				cAddSuccHost

				# Merge all data together...
				cOut|awk -v a=$bDoAll 'ARGIND==1 {FS=";";s[$1]=$2;next}  ARGIND>1 {FS=" "} $1=="*" {i[$3]=$2;next}   $3=="[....W.]" {print $1 ";" s[$1] ";" strftime("%F" (a?"_%T":"")) ";" i[$1]}' $fMacIDs - > $fClients
				dbg "**2" " fClients=$fClients ***" && cat "$fClients" # mac;name;time;ipv4

				_n=$(wc -l <$fClients)
				hLine publicwifi/clientscount $_n -M

				while IFS=\; read -r _mac _name _time _ipv4 ; do
					_vdr="$(cGetMacVendor "$_mac")"
					_line="$_time;$_mac;$hTarget;$_vdr;$_name;$_ipv4"
					echo "$_line" >> $fCollection # NEW! : # write  time;mac;node;vendor;name  to file
					echo "$_line"
					dbg IP "*$_mac* *$_name* *$_vdr* *$_time* *$_ipv4*" # IP: *6e:95:18:16:87:58* *Thomas3* *MySamsung* *2024_**
					cMS "$sSite/$sArea/$(cTrd : "$_mac")" "{*node*:*$hTarget*,*mac*:*$_mac*,*name*:*$_name*,*vendor*:*$_vdr*,*ipv4*:*$_ipv4*}" -M
				done < $fClients > $fClients.2
				data="{*count*:$_n,*localclients*:[$(awk -F\; -v hname=$hTarget '{ 
						printf lim "{*addr*:*%s*,*name*:*%s*,*vendor*:*%s*,*ipv4*:*%s*}", $2, $5=="" ? $2 : $5, $4 , $6; lim="," }' < $fClients.2 |
						shorten_ethernet_addr_in_json $bDoAll) ],*node*:*$hTarget*}"
				cEcho "$(cStarredToJSON | json_pp)"
				cMS /publicwifi/localclients ""	-M
				[ "$bWorkAllClients" ] && nLocClients="$(( nLocClients + _n ))"
				collectedclients="$collectedclients $(xargs <$fClients.2)"
				collectedclients="${collectedclients% }" # trim any leading spaces
				rm -f $fClients $fClients.2
				;;
			nodeinfo|neighbours|statistics)
				# [ ! -d "$dGluon" ] && dbg "Not on Gluon: Skipping cmd $cmd on node $hTarget" && cntnue
				ssh_rc=0
				ffnodeip="$(cCRead .nodeip 9)" || ffnodeip="::1" # localhost, better than next line
				if [ $ssh_rc = 1 -o "$ffnodeip" = NONGLUON ] ; then  # FIXME
					cErr "Command $cmd aborted, output: $ffnodeip:"
				  	cMR ERROR "Remote node IP undeterminable ($ffnodeip):"
					[ $ssh_rc = 1 ] && cCWrite .nodeip NONGLUON
					cntnue
				elif [ $ssh_rc != 0 ] ; then
					cErr "Remote node IP :$ffnodeip: empty. Cmd $cmd aborted...:"
				  	cMR ERROR "IP of remote node undeterminable ($ffnodeip):"
					cntnue
				fi
				cCWrite .nodeip "$ffnodeip" # cache the value
				_cGNI="gluon-neighbour-info -i br-client -p 1001 -r $cmd -d " # ipaddr will be appended further down ...
				[ "$sExtraOption" ] && hFull="$sExtraOption" && sExtraOption="" # use another host to query the remote one ...
				cSsh "$_cGNI $ffnodeip"
				_val="$ssh_data"
				dbg $cmd "Had called $_cGNI $ffnodeip (rc=$ssh_rc,${#ssh_data} bytes)"
				if [ ${#ssh_data} -le 1 ]  ;  then
					cErr "Connection or gluon-neighbour-info failed: Command $cmd on node ip $ffnodeip failed:"
					cMR ERROR "result empty (ssh_data=$ssh_data):"
				else
					cAddSuccHost
					p "$ssh_data" >$fTmpMqtt
					cCWrite .$cmd # cache the whole data to support change detection in the future
					cEcho
					cMqtt "/$cmd" "$ssh_data"
					if [ $cmd = statistics ] ; then
						# node_id=$( jq -r .node_id $fTmpMqtt )
						# cMqtt /nodeid "$node_id" "-r"
						### cMqtt "$sSite/$node_id/$cmd"  "$(cat $fTmpMqtt)"  "-r"
						# cMqtt /ipv6 "$ffnodeip" "-r"
						### cMqtt "$sSite/$node_id/ipv6"      "$ffnodeip" "-r"
						cFilter .clients.wifi < $fTmpMqtt
						# echo $ssh_data
						#		cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi RX bytes"   "value_json.traffic.rx" "counter"
						# 		cHassAnnounce "$sSite" "$ad_devname" "$hTarget/$cmd"    "Public Wifi TX bytes"   "value_json.traffic.tx" "counter"
						cMS /clients "" -M
						[ "$bWorkAllClients" ] && nLocClients="$(( nLocClients + data ))"
						# cMqtt "$sSite/$node_id/clients" "$data"
					fi
					# [ -f $tmpfilejson      ] && mv -f $tmpfilejson $tmpfilejson.prev
					# json_pp < "$fTmpMqtt" > $tmpfilejson
					# chmod g+w $tmpfilejson
				fi
				;;
			showsite|addresses)
				cProbeGET
				_scmd=gluon-show-site ; 	[ $cmd = addresses ] && _scmd="ip -6 -j addr show"
				if cSsh $_scmd ; then
					cMqtt "/$cmd" "$ssh_data"
					[ "$bQuiet" ] || cOut | json_pp
					cAddSuccHost
				else
					cMR ERROR "$cmd failed:"
					cErr :
				fi
				;;
			memory)
				cProbeGET
				if cSsh 'free -t | tr -cd "0-9 a-zA-Z:\n"' ; then
					cEcho
					# cStarredToJSON "$(cOut|cTableToJSON 1)" | json_pp
					cMS /$cmd "$(cOut|tr -d :|cTableToJSON 1)"
				else
					cMR ERROR "$cmd failed:"
					cErr :
				fi
				;;
			mountsizes|mountsizes_prev)
				cProbeGET
				[ $cmd != "mountsizes_prev" ] && cSsh "df -PhT" # little workaround to have before/after datas when using "install"
				cmd=mountsizes
				if [ $ssh_rc -ne 0 ] ; then
					cMR ERROR "$cmd failed:"
					cErr :
				else
					cEcho
					data="[$(cOut | sed -E -e 's,([0-9])\.0K,\1K,g' | grep -E ' 0 |/$|tmp|boot|overlay' | awk '{print lim "{*mountpoint*:*" $7 "*,*type*:*"$2"*,*filesystem*:*"$1"*,*spaceavail*:*"$5"*,*spaceused*:*"$4"*,*percentused*:*"$6 "*,*spacetotal*:*" $3 "*}" ; lim="," }' )]"
					cMqtt "${sSite:-UNSET}/$hTarget/$cmd" "$(cStarredToJSON)"
				fi
				;;
			jsonify)
				cProbeNOMQTT
				cMS /$cmd "$(cTableToJSON)" # transforms stdin to JSON table consuming header line and column leads (see "memory" above)
				;;
			reboot)
				cProbeSET
				cMR ONGOING "Will $cmd($cmdopts)"
				_key="gluon-setup-mode.@setup_mode[0].enabled"
				[ "$cmdopts" = config ] && _more="uci set $_key=1 && uci commit &&" || _more="" # reboot to config mode on next boot
				if cSsh "uci show $_key && $_more $cmd"  ; then
					dbg $cmd "$(cOut)"
					cMR OK # might not even get here if run locally ...
					cAddSuccHost
				else
					cErr :
					cMR ERROR "$cmd: failed:"
				fi
				;;
			debug_msub) # FIXME: remove this after explore mosquitto_sub stalling bug
				# for i in $(seq 20) ; do  $MP -t ffmuc/jupiter/echo/get -m $i ; echo $i ; sleep 0 ; done
				if [ "$cmdopts" = s ] ; then
					# cMqttSub -t $sSite/\# -v -R | { set +x ; while true ; do read -r x ; echo "// $x" ; sleep 1 ; done } # create a stalling pipe
					cMqttSub -t $sSite/\# -v -R | awk -v f=$fPipe '{ print "//" $0 ; system("sleep 1") }' 
					exit 0
				else
					for i in $(seq "${cmdopts:-5}") ; do 
						# cMqtt /wifistatus/get $i
						# cMqtt /status/get $i 
						cMqtt /date/get $i 
						cEcho $i
					done
				fi
				exit 0
				;;
			checkprocs) # explore number of process started in pipe
				cProbeNOMQTT
				_n=20
				_d=$(cPid)
				for i in $(seq $_n) ; do
					# echo %s $i | awk '{print}'
					# echo %s $i | awk '{print}'
					# history | awk '{print}' > $fNul
					# cat $fNul | cat | awk '{print}'
					# date | awk '{print}'
					printf y
				done
				dbg $cmd "$(awk "BEGIN {print ( $(cPid) - $_d - 4) / $_n }" )" # number of processes started for one command in the for loop above
				;;
			networkprobe)
				cProbeNOMQTT
				cmdopts="${cmdopts##0}"
				_n="${cmdopts:-1}" # times to be repeated
				_m=24

				_awk() {
					awk -F: -v key="$1" '$1 ~ "\"" key "\"" && $0 !~ ".255.255" { gsub(/,$/, "",$2) ; gsub( / *\"$/, "",$2) ; gsub(/^ *\"/, "",$2) ; print $2 }'
				}
				
				if [ "$sExtraOption" ] ; then
					network="$sExtraOption" && sExtraOption="" 
				elif ! network="$(cCRead .network 2)" ; then   # network="192.168.178.0" #  was fixed previously
					if cSsh "ip -j -p -4 addr show scope global" ; then 
						network="$( cOut | _awk broadcast | sort -n | head -1 )" && # numerically smallest, /24 network for now
						network="${network%.255}.0"
						cCWrite .network "$network" # cache the value
					else
						cErr "Command $cmd aborted:"
						cMR ERROR "Error:"
						cntnue
					fi
				fi
				sRemoveList="^iPhoneSH ^GalaxyS20FE ^S20-FE-von-S ^A52s-von-S ^constructa" # FIXME: optionalize this
				fScanTmp=$dTmp/$cmd
				fList=$dCache/$network.list.txt

				# 1. scan for known devices and provide local, reverse DNS....
				# https://nmap.org/book/reduce-scantime.html
				# https://hackertarget.com/nmap-cheatsheet-a-quick-reference-guide/
				dbg2 NMAP1 "nmap -v -sL $network/$_m"
				ssh_data=$( cSsh "nmap -v -sL $network/$_m" && cOut | grep "([0-9]*\.[0-9]*" | awk -v OFS=\; '{print gensub(/[)()]/,"","g",$6) , $5}' ) || # all hosts known by DNS
					cntnue # FIXME: more error info, e.g. nmap not installed ?
				cEcho
				cOut > $fList
				[ "$fFile" ] && cOut > $fFile.list.txt
				cMS "/$cmd/$network/known" "{ *knowndevices* : $( { echo ";name" ; cOut ; } | cTableToJSON 0 \; ), *count*:$( wc -l < $fList ) }"
				
				# 2. ... now scan for some open ports....
				clean_scan() {
					# Starting Nmap 7.93  https://nmap.org  at 2024-01-09 10:30 CET
					# Nmap scan report for fritz.box (192.168.178.1)    ### if HOST MISSING > VPN-member
					# Host is up 0.0088s latency.
					# MAC Address: DC:39:6F:E4:4C:55 AVM Audiovisuelles Marketing und Computersysteme GmbH
					# ...
					awk -v OFS=\; '{
							if ($0 ~ /^Nmap scan report for/) { line=( $6!="" ? gensub(/[)(]/,"","g",$6) : $5 ) ";" $5 }
							if ($0 ~ /^Host is up/) { next }
							if ($0 ~ /^MAC Address:/) { print line,$3, gensub(/[)(]/,"","g", substr($0, index($0, $4))) }
						}' # | tee /tmp/bbb   # IP;HOSTNAME;MAC;VENDOR
				}
				netprobe() {
					#  FIXME: /24 instead /25 /26 (was for debugging!)
					nmap -sn "$network/$_m" | clean_scan | awk -F\; -v OFS=\; -v v="$bVerbose" '{   
						sfx=".tcp *open"
						nmapcmd="ping -q -W 1 -c 2 " $1 " >/dev/null && echo 0/tcp open && { nmap --top-ports=200 " $1 " ; nmap -pT:5007,1883,9443 " $1 " ;} | grep -E \"^[0-9]+/tcp\" || echo 0/tcp NOT" 
						while (nmapcmd | getline line) { res = res ";" line ; if (line~sfx) { ports=ports gensub(sfx ".*", "", 0, line) "," } } 
						print $2,$1,$3,$4, res ~ ";0" sfx ? "pingyes" : "pingno", res ~ ";80" sfx ? "http://" $1 : "", res ~ ";22" sfx ? "ssh://" $1 : "", res ~ ";443" sfx ? "https://" $1 : "", gensub(",$","",0,ports)
						res=""
						ports=""				
					}' # | tee /tmp/ccc
				}
				gen_removecmd() {
					printf "sed "
					echo "$* xyzx" | xargs -n1 | awk '{ printf " -e /^%s/d", $1 }' 
				}
				removecmd="$(gen_removecmd "$sRemoveList")"

				dbg2 NMAP2 "nmap -sn $network/$_m"
				while  [ "$_n" -gt 0 ] ; do # now scan _n times for ports
					cMR ONGOING "Will do $cmd($network/$_m) number $_n."
					# IP;HOSTNAME;MAC;VENDOR;http://IP;ssh://IP :
					netprobe | eval "$removecmd" |
						awk -F\; -v OFS=\; 'ARGIND==1 {a[$2]=$3 OFS $4 OFS $5 OFS $6 OFS $7 OFS $8;next} {print $0 , a[$1]  }' - $fList > $fScanTmp
					dbg "Scanned hosts of $network/$_m (n=$_n, $(date +%F) )" && cat $fScanTmp

					diffres1="$( diff -N -bw -up -B -U 0 $fScanTmp.prev $fScanTmp 2>&1 | grep -v "^-$" )"
					diffres2="$(p -n "$diffres1"  | grep -E '^\+[^+]|^\-[^-]' )" # only lines with one +/-

					[ "$diffres2" ] && echo "$diffres2" | sed -E -e "s/^(.)/& $(date +%F) /" # insert space after +/-  # 1. Stdout Output
					echo "$diffres2" | grep "^+" | 
						while IFS=\; read -r ip host mac vdr httpopen sshopen rest ; do    # 2. MQTT output only for lines with "+"
							ip="${ip#+}"
							cMqtt /$cmd/$network/member "$host  ${httpopen:+http://}$ip" 
							cEcho "$host  ${httpopen:+http://}$ip ${sshopen:+ssh://$ip}"
						done
					[ "$fFile" ] && cp $fScanTmp $fFile.scan.txt
					cp $fScanTmp $dCache
					mv $fScanTmp $fScanTmp.prev
					_n=$((_n-1))
					sleep 9
				done
				cMR OK "Command $cmd($cmdopts): $network/$_m"
				;;
			networkscan) # use nmap to scan the local network for IP devices and for ports (option -a), too
				cProbeNOMQTT
				# -sV: Probe open ports to determine service/version info
				# --version-intensity 6 # the higher the more intense, default is 7
				# -O: OS detection
				# SPECIAL: nmap must be run as root or must have been privileged:  sudo setcap cap_net_raw,cap_net_admin,cap_net_bind_service+eip $(which nmap)
				[ "$bDoAll" ] && _opts="-sV --osscan-guess --version-intensity 5" || _opts="--osscan-limit --version-intensity 1"
				_opts="$_opts --privileged" # assure nmap that is has the necessary privileges
				_n="$(p "${cmdopts:-192.168.178.0/24}" | tr _ / )" # network to be scanned
				cMR ONGOING "Will $cmd($_n) with nmap options:$_opts"
				data="$(nmap $_opts "$_n" 2>&1 | 
					awk '/scan report/ { ip=substr($6,2,length($6)-2) ; printf "%s{\"IpAddr\":\"%s\",\"host\":\"%s\"", lim, ip, gensub(/\..*/,"","g",$5) }
						/OS details:/ { gsub("OS details: ",""); printf ",\"OS\":\"%s\"}\n", $0 ; lim="," }
						/MAC Address:/ { gsub("MAC Address: ",""); printf ",\"mac\":\"%s\",\"vendor\":\"%s\"}\n", gensub(" .*","",0) , gensub(".* (","",0,gensub(")$","",0)) ; lim="," }
						/Failed to / { printf "*details*:*%s (or nmap rights?)*", $0 ; exit 99 }
					')"
				rc=$?
				if [ $rc = 0 ] ; then
					cEcho "[ $data ]"
					cMqtt /$cmd "[ $data ]"
					cMR OK
				else
					cMR ERROR "{ $data }"
					[ $rc -eq 99 ] && cErrAndExit "$data ; getcap: $(getcap "$(which nmap)") ;"
				fi
				;;
			wifiscan)
				cProbeNOMQTT
				# relies on the following entry in root's crontab, since only root is allowed to do a full wifi scan
				# SHELL=/bin/bash
				# * * * * * { /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ; sleep 2 ; /sbin/iw dev wlan0 scan ;} | fgrep SSID  | cut -d: -f 2 | xargs -n1 | sort -u > /tmp/wifis.txt
				# { for i in 2 2 2 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | fgrep SSID  | cut -d: -f 2 | xargs -n1 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt
				# * * * * * { for i in 1 2 1 2 ; do /sbin/iw dev wlan0 scan ; sleep $i ; done } | egrep -w '^BSS|SSID'| sed -e 's/BSS *//' -e 's/(.*//' -e 's/\t*SSID: //' -e 's/^$/./' | xargs -L2 | sort -u > /tmp/wifis.new ; mv /tmp/wifis.new /tmp/wifis.txt ; date >> /tmp/wifis.txt

				cGetPubIF || cntnue # sets sPubIf*

				cSsh "[ \"$(id -u)\" = 0 ] || echo ERROR && iw dev $sPubIf0 scan ${sPubIf1:+&& iw dev $sPubIf1 scan}"
				if [ $ssh_rc = 0 ] ; then
					# data="$(cOut | awk '$1 ~ /^SSID/ { sub("\t*SSID: *", "") ; if (length($0)) print } {next}' | sort -u | cWordsToJsonArray)"
					ssh_data="$( printf "MAC\tsignal\tchannel\tauth\tSSID\n"
						cOut | awk '
							/^BSS / 	{ MAC 	= gensub("(.*", "", 1, $2) }
							/signal:/  	{ signal[MAC] 	= gensub(".00", "", 1, $2) }
							/SSID:/  	{ ssid[MAC] 	= gensub (".*: ", "", 0, $0) }
							/ Authentication suites:/  	{ auth[MAC] 	= gensub(" ", ";", 1, gensub(".*: ", "", 0, $0)) }
							/primary channel:/ { channel[MAC] = $NF }
							END {
								for (mac in ssid) { printf "%s\t%s\t%s\t%s\t%s\n", mac, signal[mac], channel[mac], auth[mac]==""?"null":auth[mac], ssid[mac] }
							} ' | sort -n -r -k 2 )"
					cEcho
					cMS /$cmd "$(cOut|cTableToJSON)"
				else
					cEcho "ssh command $cmd failed (rc=$ssh_rc)"
					cMR ERROR "rc=$ssh_rc // $ssh_data"
				fi
				cntnue

				# FIXME:
				dbg "$sMe: command scandirty grepping for **$sGrepSsid**"
				grep -wi "$sGrepSsid" "$dCache/wifis.txt"
				rm -f "$dCache/wifis.txt.hint"
				# exit 0
				;;
			*)
				_msg="Illegal command=:$cmd:"
				cEcho "$_msg"
				cProbeSET || cErrAndExit "$_msg"
				cErr "$_msg"
			esac
			[ "$sSite" = UNDET -a "$ssh_rc" = 0 ] && cGetSitecode FRESH # retry getting site code if UNDETermined
		done
	fi
	
	[ $# -gt 0 ] && {
		# ... everything that's left in "$*" is taken as more shell commands, too....
		cSsh "$@"
		cOut
	}
	hDone="$hDone,$fHost"
done

if [ "$nLocClients" -o "$bWorkAllClients" ] ; then
	[ "$bVerbose" -o "$nGiveHost" ] && ECHO "\n######  ALL CLIENTS($nHosts${nMaxGoneDays:+,$nMaxGoneDays}) " "$@" "######" >&${nGiveHost:-1} 2>&1
	[ "$nLocClients" ] && cMqtt "$sArea/publicwifi/allclientscount" "$nLocClients" -M

	if [ "$fCollection" ] && [ -r "$fCollection" ] ; then
		cSortAndTailFile "$fCollection" 2
		dbg fCollection "$fCollection:" && cat "$fCollection" # time;mac;node;vendor;name

		[ "$bVerbose" -a "$bWorkAllClients" ] && 
			cMS "$sSite/$sArea/alllocalclients/debug" "$( { echo "addr;date;node;vendor;name;ipv4" ; sort -t \; -k 1 "$fCollection" ;} | cTableToJSON 0 \; )"			

		data="{*count*:$nLocClients,*hostcount*:$nHosts,*hosts*:*${sHosts#,}*,*id*:*$sArea*,*localclients*:[ $( awk -F\; -v quiet=$bQuiet '{ 
				printf lim "{*addr*:*%s*,*name*:*%s*,*vendor*:*%s*,*node*:*%s*,*time*:*%s*,*ipv4*:*%s*}", $2 , $5==""?$2:$5,$4,$3, quiet? "" : $1, $6; lim="," }' < "$fCollection" |
			shorten_ethernet_addr_in_json $bDoAll ) ]}"
		cEcho "$data"
		cEcho "$(cStarredToJSON | json_pp | tee /tmp/$sBase.lc.json)"
		cMS "$sSite/$sArea/alllocalclients" "" -M
		rm -f fCollection
	fi
fi

# clean up older stuff...
cd "$dCache" || exit 2
# [ "$bVerbose" ] && ls -alt "$dCache" | head -15
find $dTmp -mindepth 1 -exec mv ${bTrace:+-v} '{}' . \; # move all leftover files from below dTmp to dCache
rmdir $dTmp
find . -maxdepth 1 -path "./[0-9]*" -type d -mtime +6 -exec rm -r '{}' \; # remove old debug files

# End of main.

# { echo TRUE  ; true  ;} || { echo TRUE  ; true ;} && echo YES ; echo =====
# { echo FALSE ; false ;} || { echo TRUE  ; true ;} && echo YES ; echo =====
# { echo TRUE  ; true ;} || { echo FALSE ; false ;} && echo YES ; echo =====
# { echo FALSE ; false ;} || { echo FALSE ; false ;} && echo YES ; echo =========
# { echo TRUE  ; true  ;} || { echo TRUE  ; true ;} || echo YES ; echo =====
# { echo FALSE ; false ;} || { echo TRUE  ; true ;} || echo YES ; echo =====
# { echo TRUE  ; true ;} || { echo FALSE ; false ;} || echo YES ; echo =====
# { echo FALSE ; false ;} || { echo FALSE ; false ;} || echo YES ; echo =====